<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
	  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [

	  <!ENTITY % CommonEntities PUBLIC
		   "-//IU7 LUG//ENTITIES Common Documentation//RU"
		   "common.ent">
	  %CommonEntities;
	  
	  <!ENTITY BASEIMAGES "images/">

]>

<chapter id="chapter-base-admin">
  <title>Базовое администрирование UNIX</title>
  <para>
    Прошлые лекции были посвящены различным особенностям архитектуры UNIX, использованию
    этой операционной системы в локальной и сетевой работе, некоторым аспектам
    администрирования системы. В этой части речь пойдет о двух центральных
    задачах, встающих перед администратором любой
    UNIX-системы&nbsp;&mdash; об управлении службами и управлении
    программным обеспечением. 
  </para>
  <!-- занятие № 11 (лекция) -->
  <sect1 id="base-admin-lect">
    <title>Управление службами</title>
    <para>
      В этой лекции освещаются процесс загрузки UNIX-систем и запуск системных
      служб. Некоторые их них, такие как <emphasis>планировщик заданий</emphasis>
      или <emphasis>системный журнал</emphasis>, рассмотрены более подробно.
    </para>
    <sect2 id="base-admin-lect-sysinit">
      <title>Загрузка операционной системы</title>
      <sect3 id="base-admin-lect-sysinit-stages">
	<title>Этапы загрузки системы</title>
	<presentation number="7-01" name="этапы загрузки системы"/>
	<para>
	  Загрузку операционной системы можно разделить на несколько этапов.  Начальный
	  этап загрузки не зависит от того, какая операционная система установлена на
	  компьютере, он в первую очередь связан с особенностями архитектуры используемого
	  компьютера. Затем следуют этапы загрузчиков, которые также могут не относиться к
	  определённым операционным системам, после чего инициализируется ядро
	  операционной системы и производятся специфические только для этой ОС операции.
	</para>    
	<question id="quest-7-1">Из каких этапов состоит загрузка операционной системы
	UNIX?</question>
	<para>
	  Рассмотрим загрузку операционной системы UNIX как следующую последовательность
	  этапов (<xref linkend="img-system-init"/>): 
	</para>
	<para>
	  <figure id="img-system-init">
	    <title>Этапы загрузки ОС UNIX</title>
	    <graphic fileref="&BASEIMAGES;system_init.png"/>
	  </figure>	
	</para>
	<para>
	  <variablelist>
	    <varlistentry>
	      <term><definition id="def-null-loader">досистемный
	      загрузчик</definition></term>
	      <listitem>
		<para>
		 Как правило, сразу после включения питания программа
		 ПЗУ BIOS проводит тестирование оборудования, затем
		 запускается досистемный загрузчик.
		</para>
		<para>
		  Задача этого этапа&nbsp;&mdash; определить (возможно, с помощью
		  пользователя), с какого устройства будет идти загрузка, загрузить оттуда
		  специальную программу-загрузчик и запустить её. Например, выяснить, что
		  устройство для загрузки&nbsp;&mdash; жесткий диск, считать самый первый
		  сектор этого диска и передать управление программе, которая находится в
		  считанной области.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><definition id="def-first-loader">загрузчик первого
	      уровня</definition></term>
	      <listitem>
		<para>
		  Загрузчик первого уровня занимает обычно не более одного сектора в самом
		  начале диска&nbsp;&mdash; в его загрузочной записи. <definition
		  id="def-mbr" orig="загрузочная запись диска">Загрузочная запись
		  диска</definition> (Master Boot Record)&nbsp;&mdash; первый сектор
		  диска, в котором хранится таблица разделов и код системного загрузчика.
		</para>
		<para>
		  Ядро операционной системы имеет довольно сложную структуру&nbsp;&mdash;
		  а значит, и непростой способ загрузки; оно может быть довольно большим
		  и может располагаться в произвольной области диска, подчиняясь законам
		  файловой системы (например, состоять из нескольких частей, разбросанных
		  по диску). Учесть все это первичный загрузчик не в состоянии, поэтому
		  его задача&nbsp;&mdash; определить, где на диске находится <emphasis>загрузчик
		  второго уровня</emphasis>, загрузить его в память и передать ему
		  управление.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><definition id="def-second-loader">загрузчик второго
	      уровня</definition></term>
	      <listitem>
		<para> 
		  Вторичный загрузчик&nbsp;&mdash; уже более сложная программа с интерфейсом
		  пользователя, которая даёт возможность выбирать операционную систему
		  или параметры загрузки ядра. Чтобы продолжить загрузку, необходимо иметь доступ к образу
		  ядра, поэтому зачастую в код загрузчика включается поддержка <emphasis>файловых
		  систем</emphasis>. Более простые загрузчики в процессе предварительной установки 
		  сохраняют адреса всех блоков диска, в которых располагается файл с
		  образом ядра.
		</para>
		<para> 
		  В любом случае вторичный загрузчик читает образ ядра в определённый
		  адрес памяти и передаёт туда управление.
		</para>
		<para>
		  Большинство операционных систем имеют собственные загрузчики первого и
		  второго уровней. Однако существуют и <emphasis>универсальные
		  загрузчики</emphasis>, не привязанные к конкретной
		  операционной системе, например <application>GRUB</application>.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>инициализация ядра операционной системы</emphasis></term>
	      <listitem>
		<para>
		  Как мы уже выяснили ранее, ядро&nbsp;&mdash; очень сложная программа,
		  взаимодействующая с различным оборудованием, поэтому, прежде чем начать
		  работу с системой, ядро необходимо проинициализировать.
 		</para>
		<para>
		  Этот этап специфичен для различных операционных систем. В UNIX-подобных
		  системах при этом обычно выводится информация
		  отладочного характера о ходе загрузки ядра.
 		</para>
		<para>
		  Первым делом ядро занимается определением параметров вычислительной
		  подсистемы компьютера: выясняет тип и быстродействие центрального
		  процессора, объем оперативной памяти, объем и структуру кэш-памяти;
		  делает предположение об архитектуре компьютера в целом и многое
		  другое.
 		</para>
		<para>
		  На следующем шаге ядро определяет состав и архитектуру всего аппаратного
		  наполнения компьютера: тип и параметры шин передачи данных и устройств
		  управления ими (контроллеров), список внешних устройств, доступных по
		  шинам, настройки этих устройств&nbsp;&mdash; диапазон портов
		  ввода-вывода, адрес ПЗУ, занимаемое аппаратное прерывание, номер канала
		  прямого доступа к памяти и т.&nbsp;п.
		</para>
		<para>
		  Ядро на основании параметра, переданного ему
		  загрузчиком, выбирает корневой раздел&nbsp;&mdash; файловую систему, содержащую будущий
		  каталог <filename>/</filename> и его подкаталоги (для системной
		  начальной загрузки важны каталоги
		  <filename>/etc</filename>, <filename>/bin</filename>,
		  и <filename>/sbin</filename>). Корневой
		  раздел <emphasis>монтируется</emphasis> в
		  качестве <filename>/</filename>. После этого ядро запускает
		  первый процесс&nbsp;&mdash; <command>init</command> (по
		  умолчанию, <filename>/sbin/init</filename>).
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>процесс init</emphasis></term>
	      <listitem>
		<para>
		  С этого момента операционная система обеспечивает полноценную
		  функциональность всем исполняющимся процессам. В UNIX первым запускаемым
		  процессом является <command>init</command>, о котором сказано в следующем разделе.
		</para>
	      </listitem>
	    </varlistentry>
	    </variablelist>
	</para>
      </sect3>
      <sect3 id="base-admin-lect-sysinit-init">
	<title>Процесс init</title>
	<presentation number="7-02" name="процесс init"/>
	<question id="quest-7-2">Какую роль выполняет процесс init в UNIX?</question>
	<para>
	  Процесс <definition id="def-init-proc">init</definition> является обычным
	  процессом операционной системы, однако он имеет некоторые особенности: его PID
	  всегда равен <literal>1</literal>, и этот процесс выполняется всё время, пока
	  работает система.
	</para>
	<para>
	  В UNIX-системах <command>init</command> играет две важные роли:
	  <itemizedlist>
	    <listitem>
	      <para>
		производит инициализацию системы&nbsp;&mdash; как правило, для работы
		запущенного ядра не достаточно, нужно смонтировать все файловые системы,
		загрузить дополнительные драйверы устройств, запустить демоны и т.&nbsp;п.;
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		является родительским для всех процессов в системе&nbsp;&mdash; это
		является гарантией того, что в UNIX для любого процесса в
		любой момент времени будет существовать родительский процесс. 
	      </para>
	      <para>
		<figure id="img-process-hierarchy-example">
		  <title>Пример иерархии процессов в UNIX</title>
		  <graphic fileref="&BASEIMAGES;process_hierarchy.png"/>
		</figure>	
	      </para>
	      <para>
		Это обеспечивается тем, что в UNIX процессы создаются с помощью
		последовательного ответвления (системный вызов
		<command>fork()</command>), а изначальной точкой
		ветвления является <command>init</command>.
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>
	<para>
	  Как правило, процесс <command>init</command> запускается из исполняемого
	  файла <filename>/sbin/init</filename> и работает с
	  некоторыми специфическими особенностями в различных
	  UNIX-системах. Рассмотрим классификацию современных версий UNIX
	  с точки зрения инициализации системы.
	</para>
      </sect3>
      <sect3 id="base-admin-lect-sysinit-inittab">
	<title>Конфигурационный файл init</title>
	<question id="quest-7-3">Для чего служит
	файл <filename>/etc/inittab</filename>?</question>
	<para>
	  Конфигурация процесса <command>init</command> описана в
	  файле <filename>/etc/inittab</filename>. Ниже приведён пример такого файла.
	</para>
	<para>
	  <example>
	    <title>Пример файла <filename>/etc/inittab</filename></title>
	    <programlisting>
# Default runlevel.
id:3:initdefault:

# System initialization, mount local filesystems, etc.
si::sysinit:/sbin/rc sysinit

# Further system initialization, brings up the boot runlevel.
rc::bootwait:/sbin/rc boot

l0:0:wait:/sbin/rc shutdown 
l1:S1:wait:/sbin/rc single
l2:2:wait:/sbin/rc nonetwork
l3:3:wait:/sbin/rc default
l4:4:wait:/sbin/rc default
l5:5:wait:/sbin/rc default
l6:6:wait:/sbin/rc reboot

# TERMINALS
c1:12345:respawn:/sbin/agetty 38400 tty1 linux
c2:2345:respawn:/sbin/agetty 38400 tty2 linux
c3:2345:respawn:/sbin/agetty 38400 tty3 linux
c4:2345:respawn:/sbin/agetty 38400 tty4 linux
c5:2345:respawn:/sbin/agetty 38400 tty5 linux
c6:2345:respawn:/sbin/agetty 38400 tty6 linux

# What to do at the "Three Finger Salute".
ca:12345:ctrlaltdel:/sbin/shutdown -r now

# Used by /etc/init.d/xdm to control DM startup.
x:a:once:/etc/X11/startDM.sh</programlisting>
	  </example>
	</para>
	<para>
	  Основными параметрами загрузки, задаваемыми в этом файле, являются:
	  <itemizedlist>
	    <listitem><para>начальный уровень загрузки (строка с <command>initdefault</command>)&nbsp;&mdash;
	    номер уровня выполения, в который переводится система при
	    старте;</para></listitem>
	    <listitem><para>скрипты для запуска уровней исполнения&nbsp;&mdash; для каждого
	    уровня (0&nbsp;&mdash; 6) указана программа с параметрами, которая
	    будет выполнена в случае перевода системы на данный уровень
	    выполнения;</para></listitem>
	    <listitem><para>настройки виртуальных терминалов&nbsp;&mdash; сколько
	    необходимо инициализировать при старте системы, какую программу для этого
	    использовать;</para></listitem>
	    <listitem><para>настройка реакции на
		нажатие <keycombo><keycap>Ctrl</keycap> <keycap>Alt</keycap>
		  <keycap>Del</keycap></keycombo>&nbsp;&mdash; какую программу необходимо
		  запустить при этом;
	    </para></listitem>
	    <listitem><para>
		прочие настройки, специфичные для данной версии UNIX.
	    </para></listitem>
	  </itemizedlist>
	</para>
      </sect3>
      <sect3 id="base-admin-lect-sysinit-unixes">
	<title>Различия в загрузке UNIX-подобных систем</title>
	<para>
	  Исторически различные версии UNIX восходят к двум системам: оригинальной
	  UNIX компании AT&amp;T (вплоть до версии System V) и BSD UNIX, созданной в
	  университете Беркли. В них применялись различные принципы загрузки системы, так
	  что современные версии UNIX по этому критерию можно разделить на:
	  <itemizedlist>
	    <listitem>наследники System V&nbsp;&mdash; так называемая UNIX System Group
	    (USG-системы): AIX, Solaris, UnixWare, Linux (дистрибутивы
	    &REDHATSHORT;, Mandriva, ALT Linux);</listitem>
	    <listitem>наследники BSD: семейство BSD, Linux (Slackware);</listitem>
	    <listitem>смешанные схемы: Linux (Debian, Gentoo).</listitem>
	  </itemizedlist>
	</para>
	<sect4 id="base-admin-lect-sysinit-unixes-sysv">
	  <title>Системы, наследующие System V</title>
	  <question id="quest-7-4">Что такое уровень выполнения системы? Какие уровни
	  выполнения выделяют в UNIX-системах, наследующих System V?</question>
	  <presentation number="7-03" name="уровни выполнения системы"/>
	  <para>
	    Основным признаком этих систем является использование понятия <definition id="def-runlevel"
	    orig="уровень выполнения">уровня выполнения</definition> (run
	    level)&nbsp;&mdash; одного из возможных режимов работы системы. Каждый уровень
	    выполнения обозначается номером (от 0 до 6), часть номеров
	    зарезервирована за стандартными уровнями выполнения.
	    В любой момент времени система может находиться на одном
	    из уровней выполнения&nbsp;&mdash;
	    изменение режима работы производится с помощью вызова <command>init</command>
	    с параметром, указывающим номер уровня выполнения, на
	    который следует перейти. 
	  </para>
	  <variablelist>
	    <varlistentry>
	      <term><emphasis>Уровень 0</emphasis></term>
	      <listitem>
		<para>
		  <emphasis>останов системы</emphasis> (halt)&nbsp;&mdash; работа
		  системы должна быть прекращена;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>Уровень 1</emphasis></term>
	      <listitem>
		<para>
		  <definition id="def-single-mode">однопользовательский режим</definition>
		  работы&nbsp;&mdash; система инициализирует минимум служб и даёт
		  единственному пользователю (как правило, суперпользователю) без
		  проведения аутентификации командную строку. Как правило, этот режим
		  используется для восстановления системы;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>Уровень 2</emphasis></term>
	      <listitem>
		<para>
		  <emphasis>многопользовательский режим</emphasis>&nbsp;&mdash;
		  пользователи могут работать на разных терминалах, вход в систему с
		  процессом аутентификации;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>Уровень 3</emphasis></term>
	      <listitem>
		<para>
		  <emphasis>многопользовательский сетевой режим</emphasis>&nbsp;&mdash;
		  многопользовательский режим, в котором осуществляется настройка сети и
		  запускаются различные сетевые службы;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>Уровень 4</emphasis></term>
	      <listitem>
		<para>
		  не имеет стандартного толкования и практически не используется;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>Уровень 5</emphasis></term>
	      <listitem>
		<para>
		  <emphasis>запуск графической подсистемы</emphasis>&nbsp;&mdash; в
		  дополнение к уровню 3 производится также старт графической подсистемы
		  X11 (см. <xref linkend="chapter-x-windows"/>).
		  Регистрация в системе осуществляется также в графическом режиме;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>Уровень 6</emphasis></term>
	      <listitem>
		<para>
		  <emphasis>перезагрузка системы</emphasis>&nbsp;&mdash; при включении
		  этого режима останавливаются все запущенные программы и производится
		  перезагрузка.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	  <para>
	    Таким образом, каждый переход на каждый уровень выполнения
	    подразумевает выполнение определённого набора процедур
	    инициализации и определённый набор системных служб,
	    которые должны выполняться на данном уровне. Конкретный
	    список таких процедур и служб может быть задан администратором системы. Стартовые
	    сценарии для каждого из уровней выполнения располагаются в
	    каталоге <filename>/etc/rc.d</filename>. 
	  </para>
	  <para>
	    На практике в серверных системах при старте обычно используется 3-й
	    уровень выполнения, в домашних&nbsp;&mdash; 5-й.
	  </para>
	  <para>
	  </para>
	</sect4>
	<sect4 id="base-admin-lect-sysinit-unixes-bsd">
	  <title>Системы, наследующие BSD</title>
	  <para>
	    В этих системах традиционно используется <emphasis>линейная схема</emphasis>
	    загрузки. Эта схема устроена намного проще (загрузка таких систем проходит
	    намного быстрее, особенно на медленных
	    машинах), но в силу той же простоты она оказывается
	    сложнее в администрировании.
	  </para>
	  <para>
	    Инициализация системы осуществляется единым
	    сценарием <filename>/etc/rc</filename>. В этом сценарии
	    последовательно выполняются процедуры инициализации
	    системы, запуска системных служб и т.&nbsp;п. Следом
	    за ним выполняется сценарий <filename>/etc/rc.local</filename>, который
	    служит для запуска всех <emphasis>локальных</emphasis> программ и настроек,
	    установленных системым администратором сверх стандартного дистрибутива операционной системы.
	  </para>
	  <para>
	    При обновлении отдельных программ или изменении их настроек администратору
	    приходится вручную править стартовые сценарии. Эти сложности привели к тому,
	    что в современных BSD-системах внедряются более простые в администрировании
	    схемы загрузки.
	  </para>
	</sect4>
	<sect4 id="base-admin-lect-sysinit-unixes-combined">
	  <title>Системы со смешанной схемой загрузки</title>
	  <para>
	    Некоторые современные UNIX-подобные системы (в частности, многие дистрибутивы
	    Linux) предоставляют собственные схемы загрузки системы, сочетающие в себе
	    достоинства обеих обозначенных выше схем.
	  </para>
	  <para>
	    Для примера можно рассмотреть схему, используемую в дистрибутивах Linux Debian
	    и Gentoo. Вводится понятие <emphasis>программных уровней выполнения</emphasis>
	    (software run levels), которые могут создаваться и изменяться
	    администратором системы.
	  </para>
	  <para>
	    Каждому уровню выполнения соответствует набор системных служб, которые будут
	    запущены при переключении системы на этот уровень выполнения. По умолчанию
	    используется один уровень исполнения&nbsp;&mdash; <emphasis>default</emphasis>.
	  </para>
	  <para>
	    Службы связаны между собой посредством <emphasis>зависимостей</emphasis>:
	    к примеру, служба, монтирующая сетевые файловые системы, требует наличия настроенной
	    сети, а значит зависит от службы конфигурации сети. Службы настройки сети, в
	    свою очередь, зависят от службы, загружающей дополнительные модули ядра (например,
	    драйвер сетевой карты). Следовательно, при загрузке
	    системы сначала должна быть запущена служба, загружающая
	    дополнительные модули ядра, затем настраивающая сеть и
	    только затем&nbsp;&mdash; монтирующая сетевые файловые
	    системы; при останове системы данные службы должны быть
	    остановлены <emphasis>в обратном порядке</emphasis>.
	  </para>
	  <para>
	    Таким образом, можно построить <emphasis>дерево
	    зависимостей</emphasis> служб друг от друга. При
	    использовании такого дерева перезапуск системной службы
	    будет приводить к перезапуску всех зависящих от нее служб.
	  </para>
	  <para>
	    Управление уровнями загрузки&nbsp;&mdash; какие программы необходимо запускать
	    на кажом из них&nbsp;&mdash; производится аналогично System V-системам.
	  </para>
	</sect4>
      </sect3>
    </sect2>
    <sect2 id="base-admin-lect-services">
      <title>Системные службы</title>
      <presentation number="7-04" name="системные службы"/>
      <question id="quest-7-5">Что такое системные службы? Как организованы системые
      службы в UNIX-системах, наследующих схему загрузки UNIX System V?</question>
      <para>
	<definition id="def-system-service" orig="системная служба">Системные
	службы</definition> (system services)&nbsp;&mdash; это
	программы, предоставляющие некоторую <quote>услугу</quote>
	(сервис) пользователям системы. Примером может быть служба,
	динамически создающая необходимые файлы устройств при
	обращении к ним (<command>udevd</command>), или служба системного журнала, которая
	рассортировывает по файлам журналов полученные от процессов
	системы сообщения о происходящих с ними событиях. Как правило, системные службы
	запускаются при загрузке системы. Каждой системной службе 
	соответствует <emphasis>стартовый сценарий</emphasis> (init script)&nbsp;&mdash; специальная
	программа, осуществляющая запуск и останов демона или программы, которая и обеспечивает
	функциональность службы.
      </para>
      <sect4 id="base-admin-lect-services-startstop">
	<title>Запуск и остановка служб</title>
	<para>
	  В System V-системах стартовые сценарии находятся в
	  каталоге <filename>/etc/init.d</filename> и принимают один из стадартных
	  параметров: <command>start</command>, <command>stop</command>
	  или <command>restart</command>. Таким
	  образом, каждая служба может быть запущена, остановлена, или перезапущена.
	</para>
	<para>
	  Например, для перезапуска службы системного журнала необходимо выполнить команду
	  <command>/etc/init.d/syslogd restart</command>.
	  <example>
	    <title>Пример перезапуска службы</title>
	    <screen>desktop ~ # /etc/init.d/syslogd restart
 * Stopping syslog-ng ...                                    [ ok ]
 * Starting syslog-ng ...                                    [ ok ]  
desktop ~ #</screen>
	  </example>
	</para>
	<para>
	  Как правило, для управления службами необходимы права суперпользователя.
	</para>
      </sect4>
      <sect4 id="base-admin-lect-services-autorun">
	<title>Автоматическая загрузка служб</title>
	<question id="quest-7-6">Каким образом производится автоматический старт служб в
	UNIX-системах, наследующих UNIX System V?</question>
	<para>
	  Службы используются в UNIX-системах с System V-подобной схемой
	  загрузки системы. При этом каждому уровню выполнения соответствует набор служб,
	  запускаемых при переключении на этот уровень.
	</para>
	<para>
	  В каталоге <filename>/etc/rc.d/</filename> можно увидеть
	  подкаталоги <filename>rc0.d</filename>,
	  <filename>rc1.d</filename> и т.д.&nbsp;&mdash; по одному на
	  каждый уровень выполенения. В этих каталогах
	  содержатся ссылки на стартовые сценарии тех служб, которые
	  будут запущены или остановлены при переходе на
	  соответствующий уровень выполнения.
	</para>
	<para>
	  Особый интерес представляют имена ссылок на стартовые сценарии служб: например, 
	  <filename>/etc/rc.d/rc0.d/K60crond</filename>
	  и <filename>/etc/rc.d/rc3.d/S40crond</filename>, указывающие на один
	  сценарий <filename>/etc/init.d/crond</filename> службы
	  системного журнала. Имя ссылки,
	  начинающееся с <literal>K</literal>, указывает на необходимость
	  остановить службу при переходе на данный уровень выполнения,
	  а <literal>S</literal>&nbsp;&mdash; запустить службу. Числа, следующие перед именем службы,
	  задают <emphasis>порядок</emphasis> выполнения сценариев в каталоге. Например,
	  сценарий <filename>/etc/rc.d/rc3.d/S34syslogd</filename> будет запущен до
	  сценария <filename>/etc/rc.d/rc3.d/S40crond</filename>, тогда
	  как <filename>/etc/rc.d/rc3.d/K60crond</filename>
	  до <filename>/etc/rc.d/rc3.d/K66syslogd</filename>. Можно заметить, что сумма
	  чисел в именах <quote>запускающей</quote> и
	  <quote>останавливающей</quote> ссылок для одной службы равна
	  <literal>100</literal>&nbsp;&mdash; это позволяет сохранять
	  порядок завершения служб всегда строго обратным порядку их запуска.
	</para>
	<para>
	  Для управления списком служб, которые должны запускаться
	  на том или ином уровне выполненения, администратору систем
	  типа System V доступна специальная утилита <command>chkconfig</command>.
	</para>
      </sect4>
      <sect3 id="base-admin-lect-services-about">
	<title>Какие бывают службы</title>
	<presentation number="7-05" name="системные службы: примеры"/>
	<question id="quest-7-7">Приведите примеры служб? Какие функции выполняет каждая
	из них?</question>	
	<para>
	  В современных UNIX-системах существует множество служб, выполняющих самые
	  разнообразные функции. Системная служба&nbsp;&mdash;
	  достаточно высокоуровневое понятие, которое объединяет по
	  меньшей мере явления двух разных типов. Часть служб предполагает
	  запуск демона, который затем постоянно выполняется вплоть до
	  момента остановки службы. Другая часть служб представляет собой
	  набор процедур (описанных в стартовом сценарии данной
	  службы), которые необходимо выполнить при запуске и/или
	  остановке службы. Службы второго типа часто предназначены для
	  настройки каких-то функций самой операционной системы
	  (например, загрука модулей или настройка сети).
	</para>
	<para>
	  Далее мы рассмотрим примеры служб,
	  существующих в том или ином виде практически во всех UNIX-системах:
	  <variablelist>
	    <varlistentry>
	      <term><command>cron</command></term>
	      <listitem>
		<para>
		  системный планировщик заданий&nbsp;&mdash; демон, запускающий
		  определённые программы с заданными интервалами времени
		  (подробнее см. <xref linkend="base-admin-lect-services-cron"/>);
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>syslog</command></term>
	      <listitem>
		<para>
		  служба системного журнала&nbsp;&mdash; демон, организующий единый интерфейс для
		  журналирования событий в системе
		  (подробнее см. <xref linkend="base-admin-lect-logging"/>);
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>network</command></term>
	      <listitem>
		<para>
		  служба инициализации сети&nbsp;&mdash; производит автоматическую
		  настройку сетевых интерфейсов, таблицы маршрутизации и т.&nbsp;п. (см. <xref linkend="network-lect-ip-sysinit"/>);
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>iptables</command></term>
	      <listitem>
		<para>
		  служба инициализации межсетевого экрана в Linux;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>sshd</command>, <command>xinetd</command>,
		<command>ftpd</command></term>
	      <listitem>
		<para>
		  набор сетевых служб, запускающих разичные сетевые серверы (подробнее
		  см. <xref linkend="base-admin-lect-services-network"/>);
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>sendmail</command></term>
	      <listitem>
		<para>
		  почтовый сервер&nbsp;&mdash; демон, обеспечивающий отправление и
		  доставку почты по протоколу SMTP;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>modules</command></term>
	      <listitem>
		<para>
		  служба, загружающая и инициализирующая дополнительные модули ядра;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>local</command></term>
	      <listitem>
		<para>
		  служба, которая обычно запускается в последнюю очередь и позволяет
		  администратору выполнять дополнительные процедуры при загрузке системы;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>checkroot</command></term>
	      <listitem>
		<para>
		  служба, инициирующая проверку корневой файловой системы (с
		  использованием утилиты, специализированной для каждой файловой системы).
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
	<para>
	  Рассмотрим более подробно некоторые из этих служб.
	</para>
      </sect3>
      <sect3 id="base-admin-lect-services-cron">
	<title>Служба планирования заданий</title>
	<presentation number="7-06" name="служба планирования заданий"/>
	<para>
	  Одной из распространённых задач администрирования является запуск каких-то задач
	  в определённое время с заданной периодичностью. В UNIX этой цели служит
	  <definition id="def-cron">планировщик
	  заданий</definition> <application>cron</application>.
	</para>
	<para>
	  За выполнением задач по расписанию следит демон, который
	  обычно называется crond. Само расписание описывается 
	  в специальных конфигурационных файлах&nbsp;&mdash; есть
	  расписание общесистемных задач
	  (<filename>/etc/crontab</filename>), а также персональное
	  расписание задач (файл <filename>crontab</filename>) для каждого
	  пользователя. Всем ли пользователям дозволяется пользоваться
	  выполнением задач по расписанию определяет
	  администратор системы; зачастую для этого пользователей
	  включают в спецаильную группу (например, cron).
	</para>	
	<sect4 id="base-admin-lect-services-cron-config">
	  <title>Конфигурация планировщика заданий</title>
	  <question id="quest-7-8">Какой самый маленький и самый большой период запуска
	    задачи с помощью стандартной службы планировщика cron?</question>
	  <para>
	    Каждое задание характеризуется следующими параметрами:
	    <itemizedlist>
	      <listitem>
		минуты, часы, дни, месяцы и дни недели, в которые производится запуск;
	      </listitem>
	      <listitem>	
		собственно задача &mdash; команда для исполнения.
	      </listitem>      
	    </itemizedlist>
	    В файле <filename>/etc/crontab</filename> эти параметры записываются следующим
	    образом:
	    <example>
	      <title>Пример файла <filename>/etc/crontab</filename></title>
      	      <programlisting>0    * * * *      rm -f /var/spool/cron/lastrun/cron.hourly
1    3 * * *      rm -f /var/spool/cron/lastrun/cron.daily
15   4 * * 6      rm -f /var/spool/cron/lastrun/cron.weekly
30   5 1 * *      rm -f /var/spool/cron/lastrun/cron.monthly
*/10 * * * *      /usr/bin/test -x /usr/sbin/run-crons &amp;&amp; /usr/sbin/run-crons
*/5  * * * *      /usr/bin/vnstat -u
58   * * * *      rdate -ncav ptbtime1.ptb.de</programlisting>
	    </example>
	    Каждая строка&nbsp;&mdash; отдельная планируемая задача.  Первые пять столбцов
	    задают момент (или промежуток, через косую) времени
	    выполнения задачи, а последний столбец содержит исполняемую команду.
	  </para>
	  <para>
	    Для изменения конфигурации планировщика можно просто отредактировать этот
	    файл и запустить команду <command>crontab</command>, но лучше пользоваться
	    этой командой с
	    параметром <command>-e</command>: <command>crontab
	    -e</command>&nbsp;&mdash; в этом случае при записи файла
	    будет проверена корректность синтаксиса файла crontab.
	  </para>
	  <para>
	    В приведённом примере файл <filename>/etc/crontab</filename> отражает механизм,
	    встречающийся в современных UNIX-системах&nbsp;&mdash;
	    каталоги <filename>/etc/cron.*</filename>. В каждом из них
	    размещаются сценарии для каждой задачи, которые должны
	    выполняться раз в день, раз в неделю, раз в месяц и т.д. соответственно.
	    Такая схема облегчает администратору управление
	    периодическими задачами: не нужно для каждой задачи
	    вписывать отдельную строку и указывать особое время выполнения в файле
	    <filename>crontab</filename>, достаточно определить
	    периодичность выполнения задачи и добавить сценарий в
	    соответствующий каталог. Редактировать
	    <filename>crontab</filename> в такой ситуации нужно только,
	    если требуется изменить <emphasis>время выполнения</emphasis> периодической задачи.
	  </para>
	</sect4>
	<sect4 id="base-admin-lect-services-cron-run">
	  <title>Запуск программ</title>
	  <para>
	    Демон <command>crond</command> в заданное время производит выполнение
	    команд. Задачи из <filename>/etc/crontab</filename>
	    запускаются от имени суперпользователя, задачи,
	    определённые пользователем в своём конфигурационном
	    файлe <filename>crontab</filename>, выполняются от имени
	    соответствующего пользователя. 
	  </para>
	  <para>
	    Демон планировщика контролирует результат выполнения запущенной программы и в
	    случае ошибки может отправлять письмо пользователю или администратору системы.
	  </para>
	</sect4>
	<para>
	  В разных UNIX-системах существует несколько реализаций службы планирования
	  заданий (например, <command>dcron</command>,
	  <command>fcron</command>, <command>anacron</command> и т.&nbsp;п.), но
	  все они реализуют описанную выше базовую функциональность.
	</para>
      </sect3>
      <sect3 id="base-admin-lect-services-network">
	<title>Сетевые службы</title>
	<presentation number="7-07" name="сетевые службы"/>
	<question id="quest-7-9">Приведите примеры сетевых служб в UNIX.</question>
	<para>
	  В современных UNIX-системах существует множество сетевых служб, решающих самые
	  разные задачи. Можно выделить несколько служб, которые чаще всего
	  используются администраторами.
	</para>
	<para>
	  <variablelist>
	    <varlistentry>
	      <term>Служба sshd</term>
	      <listitem>
		<para>
		  Эта служба отвечает за запуск и останов
		  демона <application>sshd</application>, который
		  обеспечивает доступ к системе посредством защищённого удалённого
		  терминала. Такой сервер обычно запускается на всех узлах, для которых
		  предполагается удалённый вход пользователей или администрирование.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Служба sendmail или postfix</term>
	      <listitem>
		<para>
		  <application>sendmail</application>&nbsp;&mdash; один из самых
		  распространённых почтовых серверов. Он реализует Internet-протоколы,
		  связанные с отправлением почты (в первую
		  очередь SMTP) как в рамках локальной машины, так и
		  через Internet. Даже если узел не является почтовым сервером,
		  служба <application>sendmail</application> служит для передачи писем
		  между пользователями системы. Альтернативной широко распространённой
		  почтовой службой является программа <application>postfix</application>.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Служба inetd</term>
	      <listitem>
		<para>
		  <application>inetd</application> (и его более развитая
		  версия <application>xinetd</application>)&nbsp;&mdash; это супер-сервер,
		  объединяющий множество сетевых служб. По сути этот сервер выполняет роль
		  транспорта для сетевых служб: слушает на заданом порту, при входящем
		  соединении запускает указанный для этого порта процесс и перенаправляет стандартный ввод и
		  вывод программы в tcp-соединение. При этом правила доступа, ограничение
		  по числу параллельных соединений, журналирование и т.п. организуются
		  демоном <application>inetd</application> и настраиваются в его
		  конфигурационных файлах.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Службы nfs и portmap</term>
	      <listitem>
		<para>
		  Демон сетевой файловой системы NFS (Network File
		  System), которая поддерживается в большинстве UNIX-систем. Служба
		  portmap, необходимая для работы NFS, позволяет использовать протокол
		  удалённого вызова процедур (RPC).
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Служба ntpd</term>
	      <listitem>
		<para>
		  Эта служба отвечает за запуск и останов демона, реализующего протокол
		  синхронизации времени с удалёнными серверами
		  точного времени в сети.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Служба samba</term>
	      <listitem>
		<para>
		  <application>samba</application>&nbsp;&mdash; это набор служб по
		  организации сетевого файлового хранилища на основе
		  протокола CIFS, используемого в сетевых файловых
		  системах MS Windows. Широко применяется при взаимодействии UNIX-серверов
		  и клиентских машин под Windows.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Служба cups</term>
	      <listitem>
		<para>
		  CUPS&nbsp;&mdash; сервер печати для UNIX-систем. Служба осуществляет
		  запуск и останов соответствующего демона.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Служба bind</term>
	      <listitem>
		<para>
		  <application>bind</application>
		  (или <application>named</application>)&nbsp;&mdash; самый
		  распространённый сервер доменных имён для UNIX.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
      </sect3>
    </sect2>
    <sect2 id="base-admin-lect-logging">
      <title>Мониторинг и журналирование</title>
      <para>
	Журналирование системных событий и их мониторинг&nbsp;&mdash; важнейшая задача
	администратора&nbsp;&mdash; не только в связи с поддержанием уровня безопасности
	сиситемы, но и для анализа неисправностей. Журналирование является нормой для всех
	служб в системе и присутствует во всех версиях UNIX. Мониторинг
	пользователей&nbsp;&mdash; отдельная задача администрирования, реализованная в
	UNIX также на схожих с журналированием механизмах.
      </para>
      <sect3 id="base-admin-lect-logging-syslog">
	<title>Служба системного журнала</title>
	<presentation number="7-08" name="служба системного журнала"/>
	<para>
	  Служба <definition id="def-syslog" orig="системный журнал">системного
	    журнала</definition> состоит из следующих компонентов:
	</para>
	<question id="quest-7-10">Из каких компонентов состоит системный журнал в UNIX?
	Чем обусловлено такое разделение?</question>
	<para>
	  <variablelist>
	    <varlistentry>
	      <term>Системный вызов <command>syslog()</command></term>
	      <listitem>
		<para>
		  Главной чертой журналирования в UNIX является то,
		  что в стандартном случае приложение не делает запись
		  в файл журнала напрямую, а использует системный
		  вызов (<command>syslog()</command>), в качестве параметров
		  которого передаёт как само сообщение для записи в
		  журнал, так и сопроводительные сведения:
		  программа-источник сообщения, время события,
		  приоритет и характер сообщения. Все необходимые
		  параметры <command>syslog()</command> и их допустимые значения
		  являются частью стандартов
		  POSIX. Это делает программу независимой от конкретной
		  реализации демона ведения журнала в системе, что
		  повышает уровень ее переносимости между
		  разными UNIX-системами.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Демон syslogd</term>
	      <listitem>
		<para>
		  Со стороны операционной системы основным
		  компонентом, реализующим функциональность
		  журналирования, является демон (syslogd), который осуществляет
		  получение сообщений от приложений, фильтрацию их и
		  запись в файлы журналов. 
		  Правила фильтрации и адреса доставки
		  сообщений (имена файлов журналов) описываются в конфигурационном файле
		  syslogd <filename>/etc/syslog.conf</filename>.
		</para>
		<para>
		  То, что все сообщения проходят централизованную обработку, позволяет
		  администратору системы гибко управлять отбором и
		  группировкой сообщений в конкретные файлы
		  журналов. Например, для всех сообщений, связанных с электронной
		  почтой (вне зависимости от сообщившей программы),
		  может использоваться единый файл
		  <filename>maillog</filename>. Другим интересным решением является
		  сохранение сообщений на другом узле в сети или даже автоматический
		  вывод их на принтер.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Конфигурационный файл <filename>/etc/syslog.conf</filename></term>
	      <listitem>
		<para>
		  Синтаксис конфигурационного файла может несколько
		  изменяться в зависимости от конкретной реализации
		  демона журналирования, присутствующего в
		  UNIX-системе. Однако во всех реализациях
		  конфигурационный файл представляет собой список
		  правил вида <quote>условие&ndash;имя файла</quote>,
		  где условие &mdash; это параметры сообщения
		  (приоритет, тип, и т.п.). В случае соответствия
		  сообщения правилу, оно будет записано в файл,
		  указанный в этом правиле.
		</para>
	<para>
	  Каждая запись в системном журанале содержит следующие стандартные параметры:
	  <itemizedlist>
	    <listitem>
	      время события;
	    </listitem>
	    <listitem>
	      имя программы, идентификатор процесса;
	    </listitem>
	    <listitem>
	      тип программы или сообщения (например: AUTH, DAEMON, FTP и т.п.);
	    </listitem>
	    <listitem>
	      приоритет сообщения (ALERT, ERR, WARNING, INFO и т.п.);
	    </listitem>
	    <listitem>
	      текст сообщения.
	    </listitem>
	  </itemizedlist>
	</para>

		<para>
		  Рассмотрим пример простого файла конфигурации системного журнала:

		  <example>
		    <title>Пример файла <filename>/etc/syslog.conf</filename></title>
		    <programlisting>
# Log all kernel messages to the console.
# Logging much else clutters up the screen.
kern.*                                                  /dev/console

# Log anything (except mail) of level info or higher.
# Don't log private authentication messages!
*.info;mail.none;authpriv.none;		                /var/log/messages

# The authpriv file has restricted access.
authpriv.*                                              /var/log/secure

# Log all the mail messages in one place.
mail.*                                                  /var/log/maillog


# Log cron stuff
cron.*                                                  /var/log/cron

# Everybody gets emergency messages
*.emerg                                                 *</programlisting>
		  </example>
		 
		  Данная конфгурация подразумевает вывод всех сообщений ядра в терминал
		пользователей, сообщения, связанные с почтой, сохранять в файле
		<filename>/var/log/maillog</filename>, связанные с
		аутентификацией&nbsp;&mdash; в файле
		<filename>/var/log/secure</filename>, сообщения планировщика
		заданий&nbsp;&mdash; в файле <filename>/var/log/cron</filename>, тогда как
		все остальные сообщения отравлять в файл
		<filename>/var/log/messages</filename>.
		</para>		
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
	<para>
	  В файлах журналов собощение записывается вместе со всеми параметрами в простом текстовом
	  виде, что позволяет применять стандартные для UNIX механизмы поиска по
	  текстовым файлам (например, <command>grep</command>) и упрощает процесс анализа
	  событий.
	</para>
      </sect3>      
      <sect3 id="base-admin-lect-logging-logs">
	<title>Основные системные журналы</title>
	<presentation number="7-09" name="основные системные службы"/>
	<para>
	  В UNIX-системах принято располагать все файлы журналов в
	  каталоге <filename>/var/log</filename> и его
	  подкаталогах. Во многих UNIX-системах можно обнаружить
	  системные журналы со следующими названиями:
	  <variablelist>
	    <varlistentry>
	      <term><filename>authlog</filename> / <filename>security</filename></term>
	      <listitem>
		этот файл хранит сообщения, связанные с аутентификацией пользователей,
		ошибками входа в систему, изменением уровня доступа и т.д. (хранит в том
		числе сообщения с типом AUTH);
	      </listitem>
	    </varlistentry>	  
	    <varlistentry>
	      <term><filename>daemon</filename></term>
	      <listitem>
		файл с сообщениями от системных служб (хранит сообщения с типом DAEMON);
	      </listitem>
	    </varlistentry>	  
	    <varlistentry>
	      <term><filename>dmesg</filename></term>
	      <listitem>
		в Linux-системах в файле с таким именем обычно хранятся сообщения от ядра.
	      </listitem>
	    </varlistentry>	  
	    <varlistentry>
	      <term><filename>maillog</filename> / <filename>mail</filename></term>
	      <listitem>
		сообщения о получении и доставке писем, этот журнал обычно ведётся
		почтовым сервером (хранит в том числе сообщения с типом MAIL);
	      </listitem>
	    </varlistentry>	  
	    <varlistentry>
	      <term><filename>messages</filename></term>
	      <listitem>
		в этом файле обычно хранятся все сообщения, не попавшие в другие файлы
		журналов; 
	      </listitem>
	    </varlistentry>	  
	    <varlistentry>
	      <term><filename>xferlog</filename></term>
	      <listitem>
		здесь содержатся записи обо всех файлах, загруженных с данной машины
		(обычно актуально для FTP-серверов).
	      </listitem>
	    </varlistentry>	  
	  </variablelist>
	</para>
	<para>
	  Некоторые системные службы (такие как
	  веб-сервер <application>Apache</application>) имеют свои собственные файлы
	  журналов. Располагаются они обычно в подкаталогах <filename>/var/log</filename>
	  (например, <filename>/var/log/apache/</filename>).
	</para>
      </sect3>      
      <sect3 id="base-admin-lect-logging-logrotate">
	<title>Ротация системных журналов</title>
	<presentation number="7-10" name="ротация системных журналов"/>
	<question id="quest-7-11">Что такое ротация системных журналов и почему она
	  необходима?</question>
	<para>
	  Файлы журналов преставляют собой простые текстовые файлы, в
	  конец которых добавляются новые поступающие сообщения. Как правило, администратора интересует информация о
	  событиях, произошедших не так давно относительно текущего момента&nbsp;&mdash;
	  искать информацию в многомегабайтном журнале за последний год не так
	  просто. Кроме того, при увеличении размеров файлов журналов они могут
	  теоретически занять все свободное место на диске, так что администратору
	  придётся очищать их время от времени.
	</para>
	<para>
	  Для решения этих проблем используется так
	  называемая <definition id="def-logrotation">ротация журналов</definition>&nbsp;&mdash;
	  процесс автоматического обновления файлов журналов&nbsp;&mdash; удаления и
	  архивация старых файлов и создание новых.
	</para>
	<para>
	  Для каждого из файлов журнала можно задать следующее:
	  <itemizedlist>
	    <listitem>как часто производить ротацию (обновлять файл журнала);</listitem>
	    <listitem>как долго хранить старые файлы журналов;</listitem>
	    <listitem>производить ли сжатие старых файлов;</listitem>
	    <listitem>выполнять ли дополнительные действия при обновлении
	    журнала.</listitem>
	  </itemizedlist>
	</para>
	<para>
	  Журнал может обновляться по времени (например, раз в неделю или раз в месяц) или
	  по объёму (например, при достижении размера в 1&nbsp;Мб). При этом старый файл
	  журнала сохраняется с именем <filename>имя_журнала.0</filename>, а все
	  предыдущие версии журналов (за позапрошлую неделю и т.п.) переименовываются с
	  увеличением числа на единицу. Например:
	  <informalexample>
	    <screen>desktop ~ # ls -l /var/log/authlog*
-rw-r-----  1 root  wheel   47986 Feb  6 15:56 /var/log/authlog
-rw-r-----  1 root  wheel   77783 Feb  6 03:00 /var/log/authlog.0.gz
-rw-r-----  1 root  wheel   25395 Jan 30 03:00 /var/log/authlog.1.gz
-rw-r-----  1 root  wheel   46940 Jan 23 03:00 /var/log/authlog.2.gz
-rw-r-----  1 root  wheel  166844 Jan 16 03:00 /var/log/authlog.3.gz
-rw-r-----  1 root  wheel   68078 Jan  9 03:00 /var/log/authlog.4.gz
-rw-r-----  1 root  wheel   45941 Jan  2 03:00 /var/log/authlog.5.gz
-rw-r-----  1 root  wheel   95279 Dec 26 03:00 /var/log/authlog.6.gz
-rw-r-----  1 root  wheel   34083 Dec 19 03:00 /var/log/authlog.7.gz</screen>
	  </informalexample>	
	  В данном примере журналы аутентификации хранятся в течение восьми недель, при
	  этом все старые файлы сжимаются. Сжатие может быть очень полезно для
	  экономии места на диске.
	</para>
	<para>
	  Некоторые приложения требуют явного оповещения при обновлении файла
	  журнала. Поэтому программы ротации обычно предоставляют возможность запуска
	  утилиты до или после проведения обновления.
	</para>
	<para>
	  В операционной системе Linux для ротации журналов используется программа
	  <command>logrotate</command>. В других UNIX-системах используются
	  аналогичные, часто встроенные средства.
	</para>
      </sect3>      
      <sect3 id="base-admin-lect-logging-users">
	<title>Мониторинг пользователей</title>
	<presentation number="7-11" name="мониторинг пользователей"/>
	<question id="quest-7-12">Какие средства мониторинга действий пользователей есть
	в UNIX? Приведите примеры утилит и связанных с ними системных журналов.</question>
	<para>
	  Учет сеансов работы пользователей в системе ведётся вне службы системного
	  журнала, однако по аналогии с общими системными журналами
	  информация о сеансах работы пользователей записывается в
	  несколько файлов в каталоге <filename>/var/log</filename>. В
	  отличие от стандартных системных журналов, в этих файлах
	  информация хранится в двоичном, а не в текстовом виде.
	  <variablelist>
	    <varlistentry>
	      <term><filename>wtmp</filename></term>
	      <listitem>
		Хранит информацию обо всех сеансах работы пользователя. Для просмотра
		информации из этого файла можно воспользоваться
		утилитой <command>last</command>.
	      </listitem>
	    </varlistentry>	  
	    <varlistentry>
	      <term><filename>lastlog</filename></term>
	      <listitem>
		Для каждого из пользователей хранится время последнего входа в систему
		вместе с именем соответствующего терминала (и IP-адреса в случае сетевого
		входа в систему). Содержимое этого файла можно посмотреть с помощью
		утилиты <command>lastlog</command>. Обычно после входа пользователя в
		систему на его терминал выводится информация о
		предыдущем входе в систему, сохранённая в этом файле.
	      </listitem>
	    </varlistentry>	  
	    <varlistentry>
	      <term><filename>faillog</filename></term>
	      <listitem>
		Для каждого пользователя хранит информацию о последней неудачной попытке
		входа в систему. Содержимое этого файла можно посмотреть с помощью
		утилиты <command>faillog</command>.
	      </listitem>
	    </varlistentry>	  
	  </variablelist>
	</para>
	<para>
	  Все эти файлы подвергаются ротации по той же схеме, что и
	  обычные файлы журналов.
	</para>
      </sect3>      
    </sect2>
    <sect2 id="base-admin-lect-summary">
      <title>Резюме</title>
      <presentation number="7-12" name="резюме"/>
      <para>
	Загрузка компьютера проходит в несколько этапов, часть из которых не зависит от
	установленной на машине операционной системы. Основным отличием операционной
	системы UNIX является запуск особого процесса (init), который
	управляет режимом работы системы (инициализация, останов и т.д.).
      </para>
      <para>
	Конкретика работы процесса init зависит от версии UNIX. Среди разновидностей init
	UNIX-систем выделяют два крупных класса, производных соответственно от AT&amp;T
	System V и BSD UNIX. Основное различие &mdash; понятие
	<emphasis>уровня выполнения</emphasis>, которое присутствует
	только в классе System V.
      </para>
      <para>
	Процедуры, постоянно выполняемые в том или ином режиме работы
	системы или однократно выполняемые при смене режима удобно
	представлять как <emphasis>системные службы</emphasis>. 
	Это понятие используется в System V
	системах, где для каждого уровня выполнения определяется
	список служб, которые должны выполняться на этом уровне.
      </para>
      <para>
	Среди основных служб можно выделить: планировщик заданий (cron), различные сетевые
	службы, службу системного журнала.
      </para>
      <para>
	В UNIX работа с системными журналами стандартизована: заданы типы и уровни
	ошибок, расположение файлов журналов и т.п. Большое значение при
	администрировании имеет ротация системных журналов.
      </para>
      <list-of-definitions/>
    </sect2>    
    <sect2 id="base-admin-lect-additional">
      <title>Дополнительные материалы</title>
      <para>
	<orderedlist>
	  <listitem>
	    Курячий Г.В. <emphasis>Операционная система UNIX</emphasis>.&nbsp;&mdash;
	    М.: Интуит.Ру, 2004.&nbsp;&mdash; 292 с.: ил.
	  </listitem>
	</orderedlist>
      </para>
    </sect2>    
    <list-of-questions id="base-admin-lect-questions"/>
    <small-presentation id="base-admin-lect-presentaion"/>
  </sect1>

  <!-- занятие № 11 (лекция) -->
  <sect1 id="base-admin-software-lect">
    <title>Управление программным обеспечением</title>

    <para>
      Исторически сложилось так, что разные компоненты современных UNIX-подобных ОС, 
      разрабатывались и продолжают разрабатываться независимо и в
      разных местах. Наиболее ярко это проявляется в ОС на основе ядра
      Linux, где независимо разрабатываются все компоненты системы, начиная с ядра и системообразующих
      библиотек и заканчивая прикладными программами. Такой подход к созданию ОС стал возможен
      благодаря стандартизации ОС UNIX на всех уровнях (о чём говорилось в разделе
      <xref linkend="intro-os-internet"/>). Именно благодаря компонентной
      архитектуре UNIX стало возможным появление в 1990-х годах полнофункциональных
      серверных и настольных систем, состоящих исключительно из свободных
      программ, таких как Linux и FreeBSD; ни одному свободному
      проекту было не под силу создать полноценную систему, но
      оказалось возможным объединить усилия
      многих проектов, создав интегрированную систему на основе стандартов.
    </para>
    <para>
      Однако компонентная модель системы приносит с собой и новые
      задачи. Прежде всего, в рамках такого подхода неизбежно
      возникает и развивается стремление не реализовывать одни и те же
      операции в каждой новой программе, а пользоваться реализациями,
      доступными в уже существующих компонентах. Повторяющийся функционал выносился в
      отдельные библиотеки, разрабатываемые и поддерживаемые другими людьми. Так между разными
      программами в системе возникают <definition id="def-dependency"
	  orig="зависимость">зависимости</definition>, причем даже
      небольшое изменение версии программы или библиотеки может
      потребовать обновления всех зависящих от неё компонентов.
    </para>

    <para>
      Таким образом, в задачи управления программным обеспечением в
      компонентой системе входит в первую очередь поддержание
      <definition id="system-integrity" orig="целостность системы">целостности
      системы</definition>, т. е. синхронизация версий разного ПО (которое постоянно и
      независимо друг от друга развивается) в рамках системы. Кроме того, необходимо по
      возможности упростить и унифицировать задачи установки, удаления и обновления ПО для
      администратора системы, все компоненты которой происходят из разных
      источников. Данная лекция посвящена различным методам решения этих задач,
      сложившимся в мире UNIX-систем.
    </para>
    
    <sect2 id="base-admin-software-lect-intro">
      <title>Управление программным обеспечением: роли и задачи</title>      

      <sect3 id="base-admin-software-roles">
	<title>Основные роли в создании и использовании ПО</title>
      <presentation number="8-01" name="основные роли при работе с ПО"/>

      <para>
	Создание и использование любого программного обеспечения
	предполагает существование следующих ролей:
      </para>
      <para>
        <itemizedlist>
	  <listitem><emphasis>разработчик</emphasis>;</listitem>
	  <listitem><emphasis>системный администратор</emphasis>;</listitem>
	  <listitem><emphasis>пользователь</emphasis>.</listitem>
	</itemizedlist>
      </para>      
      <para>
	Если речь идёт о свободных и открытых программах, то эти три роли очень часто
	трудно разделимы, поскольку пользователи и системные
	администраторы также имеют доступ к исходным
	текстам программ и заинтересованы в их улучшении. Поэтому
	вокруг свободных программных продуктов образуются так
	называемые <emphasis>сообщества</emphasis>, роли участников 
	  в которых не закреплены формально и определяются
	только мерой их участия.
      </para>
      <para>
	В сложившейся современной модели распространения свободного ПО
	выделилась ещё одна группа ролей&nbsp;&mdash;
	<emphasis>разработчики дистрибутивов</emphasis>, которые берут
	на себя функции интеграторов, объединяющих различные
	независимые компоненты в целостные и готовые к использованию
	<quote>решения</quote>. Наибольшее значение роль разработчиков
	дистрибутивов получила в операционной системе Linux.
      </para>
      <para>
	Основные роли и взаимосвязи участников в процессе создания, установки и использования программы показаны на рисунке
      <xref linkend="img-software-circle"/>. В этой упрощённой схеме опущены такие
      участники процесса, как <emphasis>служба поддержки</emphasis> или
      <emphasis>дистрибьюторы</emphasis>, важные в первую очередь для коммерческих
      систем, тогда как отношения, специфичные для открытых разработок, помечены пунктиром.
      </para>
      <para>
	<figure id="img-software-circle">
	  <title>Основные роли в процессе создания и использования ПО</title>
	  <graphic fileref="&BASEIMAGES;software.png"/>
	</figure>
      </para>
	</sect3>
      <sect3>
	<title>Задачи системы управления программным обеспечением</title>
      <question id="quest-8-1">Для чего существуют системы управления
	программным обеспечением?</question>
      <para>
	Если вопрос использования и конфигурирования программного обеспечения сильно
	зависит от конкретной программы (как правило, доступна документация для
	пользователей системы), то общие задачи администрирования (установка программы,
	её обновление, удаление)&nbsp;&mdash; наоборот, стремятся к унификации для
	облегчения работы системного администратора.
      </para>
      <para>
	Вспомним хотя бы стандартную иерархию каталогов UNIX. Исполняемые файлы программ
	обычно располагаются в одних каталогах,
	библиотеки&nbsp;&mdash; в других, файлы с
	данными&nbsp;&mdash; в третьих. Это удобно при использовании и конфигурировании,
	но устанавливать или удалять программы вручную очень сложно. Т.&nbsp;е. необходимы специальные автоматизирующие средства,
	позволяющие администратору легко (желательно полуавтоматически) производить
	установки, обновление и удаление программ.
      </para>
      <para>
	Другой важной функцией систем управления программным обеспечением является
	организация связи между разработчиками программы (или дистрибутива) и
	администратором: уведомление о выходе новых версий программ или
	критических обновлений, загрузка программ через Интернет, средства обратной связи.
      </para>
      </sect3>
    </sect2>

    <sect2 id="base-admin-software-lect-systems">
      <title>Формы распространения программного обеспечения</title>

      <sect3>
	<title>В двоичной форме или в исходных текстах?</title>
	<presentation number="8-02" name="распространение ПО в двоичной форме и в исходных
	текстах"/>
	
	<para>
	  Самым простым способом распространения программы является простой файловый архив,
	  который содержит исполняемый файл, набор библиотек и других файлов, необходимых
	  для запуска программы. Но распространение программ в двоичном виде связано с рядом
	  проблем: исполняемые файлы различаются для разных архитектур и операционных систем
	  (UNIX-подобные операционные системы имеют общие стандартные интерфейсы, а не
	  реализации). В результате двоичная программа <quote>для
	    UNIX</quote> обычно оказывается реально применимой на очень
	  узком круге платформ. Применимость такой программы также
	  стремительно падает с течением времени: быстро устаревают
	  аппаратные архитектуры, меняются реализации системообразующих
	  компонентов, меняются даже стандарты.
	</para>
	<para>
	  <figure id="img-apps_bin">
	    <title>Распространение ПО в двоичной форме</title>
	    <graphic fileref="&BASEIMAGES;apps_bin.png"/>
	  </figure>
	</para>

	<para>В настоящий момент распространение программ только в двочном виде характерно
	для <emphasis>проприетарных</emphasis> версий UNIX: AIX, HP-UX, MacOS X,
	Solaris и др. Эти версии UNIX чаще всего поставляются для небольшого
	регламентированного списка аппаратных платформ.</para>
	
	<para>
	  Поскольку ОС UNIX изначально создавалась как
	  <emphasis>переносимая</emphasis> система, не привязанная к
	  конкретной аппаратной платформе, в UNIX-сообществе
	  было принято распространять программы в виде исходных текстов
	  с тем, чтобы каждый пользователь имел возможность
	  самостоятельно скомпилировать программу для своей архитектуры,
	  в случае необходимости внеся изменения в исходный текст.
	  Таким образом с разработчика программы фактически снимается
	  забота о существующем в мире многообразии аппаратных архитектур и
	  реализаций UNIX.
	</para>

	<para>
	  Очевидно, что преимущества по переносимости программы в этом
	  случае компенсируются увеличением затрат на стороне
	  пользователей: от них требуется владение средствами
	  разработки (компиляторы и т.&nbsp;п.), машинные ресурсы на
	  компиляцию (для больших программ они весьма значительны даже
	  по современным меркам), а при необходимости
	  <quote>приспосабливать</quote> программу к своему
	  окружению&nbsp;&mdash; ещё и высокий уровень компетенции в
	  разработке ПО и операционных системах.  
	</para>
      </sect3>

      <sect3 id="base-admin-software-lect-systems-prepackage">
	<title>Сборочные процедуры как средство управления ПО</title>
	<para>
	  В тот период, когда UNIX-сообщество было, в первую очередь,
	  сообществом разработчиков, предполагалось, что средства
	  разработки установлены в любой UNIX-системе, где может быть
	  востребована программа, распространяемая в
	  виде исходных текстов. Поэтому вполне естественно сложилось,
	  что средства, используемые для компиляции и сборки
	  программ (например, утилита <command>make</command>), были
	  приспособлены и для решения задач из области уже системного
	  администрирования: установки и удаления полученных программ.
	</para>
	<para>
	  <figure id="img-apps_src">
	    <title>Распространение ПО в форме исходных текстов</title>
	    <graphic fileref="&BASEIMAGES;apps_src.png"/>
	  </figure>
	</para>
	<para>
	  <definition id="def-makefile" orig="makefile">Make-файл</definition>
	  определённого вида к настоящему времени является стандартом де-факто для большинства открытых
	  проектов. С его помощью можно получить готовую к использованию программу из
	  исходных текстов на компилируемом языке (как правило это C или C++). Обычно в
	  make-файле определяются специальные цели для задач
	  системного администрирования: <command>install</command> и
	  <command>uninstall</command>, которые выполняют стандартные действия&nbsp;&mdash; соответственно,
	  установку и удаление скомпилированной программы из системы. При этом всё, что требуется от
	  администратора для компиляции из исходных текстов и
	  установки программы&nbsp;&mdash; это выполнить следующую последовательность команд:
	  <example>
	    <title>Сборка и установка программы с помощью make</title>
	    <screen>desktop src # tar -xzf a-program-1.00.tar.gz
desktop src # cd a-program-1.00
desktop a-program-1.00 # make
... происходит компиляция и сборка программы ...
desktop a-program-1.00 # make install
... программа устанавливается в систему ...</screen>
	  </example>
	  Естественно, процесс компиляции программы может занять достаточно длительное время,
	  что делает этот способ установки ПО довольно долгим и не самым удобным. Кроме того, в
	  системе должны присутствовать компилятор и все библиотеки, необходимые для
	  сборки программы, не говоря уже о том, что в случае любых
	  неожиданностей для компиляции программы может потребоваться высокая квалификация администратора.
	</para>
	<para>
	  С увеличением числа программ в системе (любая современная
	  система&nbsp;&mdash; это тысячи компонентов) такой подход к
	  управлению ПО стал малоприменимым как
	  исключительно затратный для системного администратора.
	</para>
	<para>
	  Дополнительный источник осложнений представляют собой
	  зависимости программ. Так, крупные современные проекты могут
	  использовать десятки других программ и библиотек (например,
	  веб-сервер <application>apache</application> зависит от десятка других проектов,
	  начиная от базовой системной библиотеки
	  <application>libc</application> и заканчивая библиотекой <application>expat</application> для
	  синтаксического анализа XML). Так как большинство проектов развивается
	  независимо друг от друга, и новые версии выпускаются довольно
	  часто, отслеживание зависимостей и корректное обновление
	  программ могут превратиться в сущий ад для администратора.
	</para>
	<para>
	  Дальнейшую автоматизацию работы администратора в отношении отслеживания зависимостей
	  и различий в реализации разных UNIX-систем в рамках той же модели&nbsp;&mdash;
	  посредством сборочных процедур&nbsp;&mdash; предоставляют программы пакета
	  <command>autotools</command>: <command>automake</command> и
	  <command>autoconf</command>.  Эти средства по существу
	  реализуют <emphasis>адаптивные сборочные процедуры</emphasis>, которые способны
	  настраиваться в зависимости от особенностей сборочной среды. Они позволяют на
	  основе анализа присутствующих в системе программ и библиотек, особенностей
	  операционной системы и аппаратной архитектуры автоматически получить make-файл,
	  по которому будет произведена компиляция и установка программы.
	</para>
      </sect3>

      <sect3>
	<title>Дистрибутивы</title>
	<presentation number="8-03" name="виды дистрибутивов"/>
	<question id="quest-8-2">Какова роль разработчиков дистрибутивов в
	  создании и использовании свободных программ?</question>

	<para>
	  С выходом свободных UNIX-систем за пределы профессионального
	  сообщества разработчиков, появлением и развитием
	  дистрибутивов, между разработчиками программ и их
	  пользователями возникла ещё одна ступень&nbsp;&mdash; <emphasis>разработчики
	  дистрибутивов</emphasis>. Постепенно именно они стали
	  выполнять большую часть требующей высокой квалификации 
	  работы по сборке программ из исходных текстов и адаптации их
	  к конкретной системе. Одновременно они стали заниматься
	  унификацией всего программного обеспечения, составляющего
	  дистрибутив.
	</para>
	<para>
	  Таким образом, благодаря разработчикам дистрибутивов администраторы и конечные
	  пользователи дистрибутивов освобождаются от высоких требований к компетенции в
	  разработке ПО. В этом случае администратор работает уже не в
	  терминах отдельной программы или файловых архивов, а в
	  терминах более высокого уровня: функциональных компонентов системы,
	  подготовленных разработчиками дистрибутива. В разных
	  системах такие компоненты могут называться по-разному, мы
	  для единообразия будем всегда называть их <emphasis>пакетами</emphasis>. 
	</para> 
	<para><definition id="def-package" orig="пакет">Пакет</definition>&nbsp;&mdash; это
	  специальный файловый архив, который содержит программу/
	  набор программ или указание на способ получения программы
	  (например, адрес в Интернете) вместе с формализованной
	  информацией, необходимой для интеграции данной программы в систему. Разница между пакетом и
	  программой аналогична разнице между службой и демоном
	  (см. <xref linkend="base-admin-lect-services"/>)&nbsp;&mdash; администратор
	  работает с пакетом в терминах его функциональности.
        </para>
	<para>
	  Введение понятия <emphasis>пакет</emphasis>, помимо прочего, позволяет 
	  формализовать понятие зависимости, указывая в метаинформации
	  пакета имена и версии других пакетов, от которых зависит
	  данный. Таким образом, при установке пакета можно 
	  автоматически отслеживать наличие в системе всех необходимых
	  для него компонентов (других пакетов нужных версий), о чём ещё будет сказано
	  далее (см. раздел <xref linkend="base-admin-software-lect-package-deps"/>).
        </para>
      </sect3>

      <sect3 id="base-admin-software-lect-systems-sources">
	<title>Дистрибутивы, основанные на сборке программ из исходных текстов</title>

	<para>
	  Изначально идея систематизации сборки программ, составляющих
	  UNIX-систему, из исходных текстов развилась в BSD-системах (см. также <xref
	  linkend="base-admin-lect-sysinit-unixes-bsd"/>). В них
	  (изначально во FreeBSD) было введено понятие <definition
	  id="def-port" orig="порт">порта</definition>&nbsp;&mdash;
	  пакета специального вида, который сам не содержит исходных
	  текстов, а только адрес их местонахождения (как правило,
	  сайт разработчика), но содержит главную <quote>точку
	  приложения</quote> знаний: дополнительные изменения,
	  внесённые разработчиками дистрибутива, и формализованные инструкции по
	  сборке. 
	</para>
	<para>
	  Таким образом, в этой схеме процесс компиляции программ
	  выполняется, как и в более традиционной модели,
	  непосредственно администратором системы, однако из этого
	  процесса устранены наиболее неприятные неожиданности за
	  счёт изменений, внесённых разработчиками дистрибутива в
	  порт. В норме процесс компиляции предоставляемой портом программы
	  должен успешно выполняться без вмешательства человека.
	</para>
	<para>
	  Пример развития данной схемы до логического предела
	  демонстрирует проект Linux From Scratch,&nbsp;&mdash;
	  дистрибутив, который по существу не содержит вообще никаких
	  текстов программ, а представляет собой обстоятельнейшую инструкцию
	  для администратора, как самостоятельно скомпилировать все
	  компоненты системы, начиная с средств разработки и ядра.
	</para>
	<para>
	  Среди широко используемых дистрибутивов GNU/Linux на сборке из исходных текстов
	  основан Gentoo. Собственная, усовершенствованная версия портов, названная
	  <emphasis>портежи</emphasis> (portages), позволяет
	  сконфигурировать систему под конкретную задачу и даже
	  специфическую архитектуру.
	</para>
	<para>
	  <figure id="img-apps_ports">
	    <title>Распространение ПО в форме портов/портежей</title>
	    <graphic fileref="&BASEIMAGES;apps_ports.png"/>
	  </figure>
	</para>
	<para>
	  Однако при таком распределении задач (компиляция на стороне
	  администратора системы) сохраняется длительность процесса установки и зависимость от используемых
	  средств разработки&nbsp;&mdash; даже на сервере приходится устанавливать
	  компилятор <application>gcc</application>.
	</para>
      </sect3>      
      <sect3 id="base-admin-software-lect-systems-package-bin">

	<title>Дистрибутивы, основанные на двоичных пакетах</title>

	<para>
	  Другим путём пошли разработчики многих дистрибутивов,
	  основанных на распространении двоичных пакетов. 
	  Первые примеры использования двоичных пакетов в дистрибутивах Linux относятся к
	  ранним версиям дистрибутивов Debian, &REDHATSHORT; и Slackware. Основное
	  отличие подхода заключается в том, что системному
	  администратору компоненты системы предлагаются не в виде
	  пакетов с исходными текстами, а в виде пакетов, содержащих
	  двоичные, скомпилированные версии программ. Таким образом с
	  администратора системы снимается необходимость иметь
	  средства разработки (сборочную среду) и тратить время на
	  сборку программ. Более того, поскольку пакет содержит также
	  и процедуры установки/удаления программы, основные задачи управления
	  ПО становятся вполне доступными и пользователю, не имеющему
	  специальной подготовки.
	</para>
	<para>
	  Описанные выше (см. раздел <xref linkend="base-admin-software-lect-systems"/>)
	  проблемы, связанные с распространением
	  двоичных программ, в логике таких дистрибутивов решены так:
	  разработчики предоставляют дистрибутив, представляющий собой
	  полноценную систему для решения определённого класса задач и
	  поддерживающий определённый круг оборудования. Пользователю
	  остаётся только выбрать подходящий дистрибутив и
	  устанавливать и обновлять необходимые ему компоненты&nbsp;&mdash;
	  пакеты. Работоспособность пакетов на данной аппаратной
	  платформе, их интеграцию в системе, отслеживание
	  зависимостей обеспечивают разработчики дистрибутива. Точнее, в рамках дистрибутива у
	  каждого пакета традиционно имеется
	  <definition id="maintainer">сопровождающий</definition> (package
	  maintainer) или группа сопровождающих. Это
	  ограничивает пользователя теми программами, что представлены
	  в дистрибутиве. Установка любого ПО из других источников
	  влечёт все описанные выше проблемы и требования для системного
	  администратора или пользователя.
	</para>

	<para>
	  <figure id="img-apps_bin_packages">
	    <title>Распространение ПО в форме двоичных пакетов</title>
	    <graphic fileref="&BASEIMAGES;apps_packages.png"/>
	  </figure>
	</para>
	<para>
	  Очевидно, что в данном случае большая часть работы перекладывается на
	  создателей дистрибутива.  Это сказывается, в частности, на том, что
	  добавление новых версий программ в таких системах происходит
	  медленнее, чем в системах, основанных на сборке из исходных текстов.
	</para>

	<para>
	  На начальном этапе развития пакетных систем существовало обязательное
	  и достаточно строгое понятие <emphasis>релиза</emphasis>
	  системы&nbsp;&mdash; набора пакетов, соответствующего определённой
	  версии дистрибутивов. Такой набор пакетов распространяется на
	  компакт-дисках и, возможно, публикуется в Internet. Таким образом,
	  обновление пакетов практически проходило поэтапно&nbsp;&mdash; вместе
	  с обновлением версии дистрибутива. Этот подход до сих пор активно
	  практикуется в коммерческих дистрибутивах.
	</para>
	<para>
	  С развитием Internet пакетные системы стали выносить на публику
	  <definition id="def-repository" orig="репозиторий">репозитории
	  пакетов</definition>&nbsp;&mdash; хранилища пакетов системы,
	  содержащие <quote>текущее состояние</quote> системы, множетство всех пакетов и
	  зависимостей между ними. Репозитории удобны тем, что они находятся
	  в <quote>живом</quote> состоянии&nbsp;&mdash; пакеты постоянно обновляются
	  разработчиками дистрибутива и могут быть загружены и установлены
	  пользователем. Как правило, для автоматизации и удобства работы с репозиторием
	  (а именно, установки пакетов с удовлетворением всех зависимостей) используется
	  специальная программа (например, <application>APT</application>). Имея
	  постоянный доступ в Internet, можно развернуть всю систему из небольшого
	  начального набора пакетов, включающего базовую систему и программу по работе с
	  репозиторием.
	</para>
	<para>
	  Надо отметить, что акцент на двоичные пакеты в таких системах не
	  мешает им также распространять пакеты с исходными текстами
	  программ. Как структура таких пакетов, так и принципы работы
	  с ними в основных чертах совпадают с портами и портежами в
	  дистрибутивах, основанных на сборке из исходных текстов.
	</para>
	
	<presentation number="8-04" name="из чего состоит пакет"/>
	<question id="quest-8-3">Что такое пакет и из чего он
	состоит?</question>

	<para>
          Существует несколько широко распространённых форматов
   	  пакетов, обычно связанных с различными дистрибутивами. Но в
   	  каждом из форматов будут присутствовать следующие логические составляющие
   	  (см. <xref linkend="img-package"/>).
        </para>

      <para>
	<figure id="img-package">
	  <title>Основные составляющие пакета</title>
	  <graphic fileref="&BASEIMAGES;package.png"/>
	</figure>
      </para>

      <para>
  	<variablelist>
	  <varlistentry>
	    <term><emphasis>название</emphasis></term>
	    <listitem>
	      <para>
		Имя программы (например, <quote>apache</quote>) или функции,
		закреплённой за пакетом
		(например, <quote>basesystem</quote>&nbsp;&mdash; файлы и
		программы, составляющие основу системы).
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis>версия</emphasis></term>
	    <listitem>
	      <para>
		Версия программы, присвоенная разработчиками, обычно дополняется версией
		пакета в рамках дистрибутива (например, <quote>pciutils-2.1.11-alt10</quote>).
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis>зависимости</emphasis></term>
	    <listitem>
	      <para>
		Список пакетов с версиями, необходимых для установки и работы данного
		пакета. Как правило, пакеты в системе образуют решетку зависимостей.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis>автор(ы)</emphasis></term>
	    <listitem>
	      <para>
		Имя и контактная информация автора или коллектива авторов программы, адрес домашней
		страницы проекта.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis>описание</emphasis></term>
	    <listitem>
	      <para>
		Информация о пакете, соответствующей программе или функции.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis>содержимое</emphasis></term>
	    <listitem>
	      <para>
		Пакеты бывают двоичные или с исходными текстами. В первом случае это
		скомпилированные исполняемые и прочие файлы программы, во
		втором&nbsp;&mdash; исходные тексты и инструкции по сборке.
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </para>

	<para>
	  Самые распространённые на данный момент дистрибутивы Linux&nbsp;&mdash; Debian и &REDHATSHORT;&nbsp;&mdash;
	  являются типичными примерами систем с двоичными пакетами
	  (<command>rpm</command> для &REDHATSHORT; и
	  <command>deb</command> для Debian). Эти два формата
	  пакетов используются также и в других дистрибутивах&nbsp;&mdash; Mandriva, ALT Linux, Ubuntu и т.&nbsp;д. 
	</para>

	<presentation number="8-05" name="зависимость и конфликт"/>

	<sect4 id="base-admin-software-lect-package-deps">
	  <title>Зависимости пакетов</title>
	<para>Пакеты в системе выстраиваются в сеть зависимостей и блокировок. Например,
	  веб-сервер <application>apache</application> может зависеть от множества
	  пакетов, т.е. администратору придётся установить все из них перед установкой
	  самого пакета
	  <application>apache</application>. На рисунке <xref linkend="img-pkgdeps"/> показан пример
	  реальных зависимостей пакетов в одном из дистрибутивов
	  &GNULINUX;. Аналогичная ситуация возникает и при удалении
	  пакета: удаление одной из зависимостей, вообще говоря, некорректно и может привести
	  к отказу работы программ из основного пакета.</para>
	
	<figure id="img-pkgdeps">
	  <title>Пример зависимостей пакетов в системе</title>
	  <graphic fileref="&BASEIMAGES;pkg_deps.png"/>
	</figure>

	<para>
	  Зависимость между пакетами системы может основываться на:
	  <itemizedlist>
	    <listitem>функциональной зависимости, например, программы от библиотеки
	      (например, библиотеки <command>libreadline</command>, предоставляющей функцию
	      гибкого ввода текста в командной строке);</listitem>
	    
	    <listitem>зависимости от набора данных или конфигураций (так,
	      пакет <command>terminfo</command> предоставляет набор конфигураций терминалов);</listitem>
	
	    <listitem>зависимости при установке&nbsp;&mdash; при
	      отсутствии данного пакета в системе не удастся
	      развернуть и проинициализировать зависящий от него пакет;</listitem>
	
	    <listitem>виртуальные зависимости&nbsp;&mdash; используются для объединения
	      пакетов в группы, удобные для установки и обновления (например, пакет
	      <command>glibc</command> зависит от множества
	      пакетов вида <command>glibc-*</command>, включающих отдельные компоненты базовой
	      системной библиотеки).</listitem>
	  </itemizedlist>
	</para>

	<question id="quest-8-4">Что такое конфликты в системах с пакетами и
	  как они могут разрешаться?</question>

	<para>
	  Часто в рамках одной системы доступно для установки несколько версий программы (а,
	  следовательно, и пакета). Как правило, разные версии пакета не могут
	  одновременно присутствовать в системе. Такая ситуация называется <definition
	  id="def-blocking" orig="конфликт">конфликтом</definition> между пакетами в
	  системе. Другой причиной конфликта может быть аналогичная функциональность
	  пакетов (например, в системе может быть установлен только один демон планирования
	  заданий, хотя существует несколько его реализаций, представленных различными
	  пакетами). На рисунке <xref linkend="img-pkgprov"/> показан конфликт пакетов,
	  обеспечивающих функциональность системного журнала.
	</para>

	<figure id="img-pkgprov">
	  <title>Пример конфликта пакетов в системе</title>
	  <graphic fileref="&BASEIMAGES;pkg_prov.png"/>
	</figure>

	</sect4>
      </sect3>
    </sect2>      
    
    <sect2 id="base-admin-software-lect-packets">
      <title>Управление пакетами</title>

      <para>
	Для работы с каждым из форматов пакетов предназначены специальные
	программы&nbsp;&mdash; <emphasis>менеджеры пакетов</emphasis>:
	в случае rpm-пакетов это <application>rpm</application>, а в случае
	deb-пакетов&nbsp;&mdash; <application>dpkg</application>. Как правило, основные
	административные операции можно выполнять с помощью этих
	программ, однако в каждом дистрибутиве обычно предлагаются
	собственные более высокоуровневые системы для управления
	пакетами и работы с репозиториями пакетов.
      </para>

      <para>
	В рамках данного курса будет рассматриваться управление пакетами на основе
	<application>rpm</application> (как низкоуровневого средства работы с пакетам)
	и <application>APT</application> (как высокоуровневого интерфейса к нему), которое
	можно применить к ряду дистрибутивов Linux. Нужно отметить, что реализация
	управления пакетами с помощью <application>rpm</application> может отличаться в
	различных дистрибутивах Linux, здесь же рассматривается дистрибутив ALT Linux.
      </para>

      <para>
	Как уже было сказано выше, администратору системы приходится выполнять следующие
	операции при работе с пакетами:
	
	  <itemizedlist>
	    <listitem>установка программ;</listitem>
	    <listitem>обновление программ (например, в связи с выходом их новых
	      версий);</listitem>
	    <listitem>удаление программ;</listitem>
	    <listitem>получение информации о пакетах&nbsp;&mdash; как
	      установленных, так и не установленных.</listitem>
	  </itemizedlist>
      </para>
      
      <para>
	Исходя из названных выше задач администратора в системе с бинарными пакетами
	легко определяется круг задач <application>rpm</application>: управление файловым архивом,
	выявление зависимостей и конфликтов, непосредственная установка и удаление файлов.
      </para>
      
      <sect3 id="base-admin-software-lect-packets-rpm">
	<title>RPM-пакеты</title>
	<presentation number="8-06" name="название RPM-пакета"/>
	<para>
	  Обычно файлы RPM-пакетов имеют специальным образом
	  построенные имена:
	
	  <command>имя_пакета-версия_программы-версия_пакета.архитектура.rpm</command>

  	  <variablelist>
	    <varlistentry>
	      <term><emphasis>имя пакета</emphasis></term>
	      <listitem>
		<para>
		  Может соответствовать программе или библиотеке, заключённой в этом
		  пакете, либо же задавать его назначение (например, <command>setup</command>
		  или <command>initscripts)</command>.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>версия программы</emphasis></term>
	      <listitem>
		<para>
		  Версия программы или библиотеки, которая составляет основу пакета
		  (например, в случае пакета <command>automake-1.9.2-3</command> это
		  <literal>1.9.2</literal>).
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>версия пакета</emphasis></term>
	      <listitem>
		<para>
		  Для каждой версии программы может существовать несколько версий пакетов.
		  Это связано с тем, что создатели дистрибутива &GNULINUX; могут изменять
		  программу, внося свои патчи, или же изменять сам пакет&nbsp;&mdash;
		  установочные скрипты, описание и т.&nbsp;п.. Например, пакет
		  <command>xmms-1.2.10-9</command> имеет уже девятую версию. В некоторых
		  дистрибутивах &GNULINUX; к версии пакета прибавляют специальную
		  приставку, например: <command>pciutils-2.1.11-alt10</command> в ALT Linux.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>архитектура</emphasis></term>
	      <listitem>
		<para>
		  Программы могут быть скомпилированны под разные аппаратные архитектуры,
		  например <command>i386</command> для Intel x86-совместимых процессоров или
		  <command>ppc</command> для POWER от IBM. Пакеты, которые не содержат
		  скомпилированных программ или библиотек (например, сценарии или
		  конфигурационные файлы) обычно обозначаются как <command>noarch</command>.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
	<para>
	  Практические вопросы работы с программой <application>rpm</application>
	  рассматриваются в разделе: <xref linkend="base-admin-software-cmd"/>.
	</para>
      </sect3>
      
      <sect3 id="base-admin-software-lect-packets-apt">
	<title>Работа с репозиториями пакетов: APT</title>
	<presentation number="8-07" name="работа с репозиторием"/>
	<question id="quest-8-5">Какова роль репозитория пакетов?</question>

	<!-- дистры: публикация своих пакетных баз в Интернет; работа
	с репозиторием и обновление системы оттуда; в ситуации с
	изменяющейся пакетной базой (в противоположность стабильным
	релизам) менеджеры пакетов перестали справляться с
	отслеживанием зависимостей да и вообще потребовалось более
	удобное средство -->

	<para>
	  Среди дистрибутивов &GNULINUX; стало распространённым явлением размещение
	  пакетов в Интернет, в так называемом <emphasis>репозитории
	  пакетов</emphasis>. Администратор может загрузить оттуда самую последнюю версию
	  пакета и установить его в системе. Для облегчения работы с репозиторием
	  существуют специальные программы, такие как <application>APT</application> в
	  Debian или <application>yum</application> в &REDHATSHORT;.
	</para>

	<para>Менеджеры пакетов оказались неспособны предотвратить
	  все возможные коллизии при установке или удалении программ и,
	  тем более, эффективно устранить нарушения целостности системы.
	  Особенно сильно этот недостаток сказывается при обновлении
	  систем из централизованного репозитория пакетов, в котором
	  последние могут непрерывно обновляться, дробиться на более
	  мелкие и т.&nbsp;п. Этот недостаток и стимулировал создание систем
	  управления программными пакетами и поддержания целостности
	  системы. 
	</para>
	
	<para>
	  Для автоматизации этого процесса и применяется
	  Усовершенствованная система управления программными пакетами
	  APT (от англ. Advanced Packaging Tool). Такая
	  автоматизация достигается созданием одного или нескольких
	  внешних <emphasis>репозиториев</emphasis>, в которых хранятся
	  пакеты программ и относительно которых производится сверка
	  пакетов, установленных в системе. Репозитории могут содержать
	  как официальную версию дистрибутива, обновляемую его
	  разработчиками по мере выхода новых версий программ, так и
	  локальные наработки (например, пакеты, разработанные внутри
	  компании). 
	</para>
	
	<para>
	  Таким образом, в распоряжении APT находятся
	  две базы данных: одна описывает установленные в системе пакеты,
	  вторая &mdash; внешний репозиторий. APT
	  отслеживает целостность установленной системы и, в случае
	  обнаружения противоречий в зависимостях пакетов, руководствуется
	  сведениями о внешнем репозитории для разрешения конфликтов и
	  поиска корректного пути их устранения.
	</para>
	
	<para>
	  Первоначально APT был разработан для
	  управления  установкой и удалением программ в дистрибутиве
	  &DEBIANLONG;. При разработке ставилась задача заменить
	  используемую в &DEBIANSHORT; систему выбора программных пакетов
	  <application>dselect</application> на новую, обладающую большими
	  возможностями и простым пользовательским интерфейсом, а также
	  позволяющую производить установку, обновление и повседневные
	  <quote>хозяйственные</quote> работы с установленными на машине
	  программами без необходимости изучения тонкостей используемого в
	  дистрибутиве менеджера программных пакетов. 
	</para>

	<para>
	  Эти привлекательные возможности долгое время были доступны
	  только пользователям &DEBIANSHORT;, поскольку в
	  APT поддерживался только один менеджер
	  пакетов, а именно применяемый в &DEBIANSHORT; менеджер пакетов
	  <command>dpkg</command>. APT, однако, изначально проектировался как не
	  зависящий от конкретного метода работы с установленными в
	  системе пакетами, и эта особенность позволила разработчикам из
	  бразильской компании Conectiva реализовать в нём
	  поддержку менеджера пакетов RPM. Таким
	  образом, пользователи основанных на RPM
	  дистрибутивов получили возможность использовать этот мощный инструмент.
	</para>

	<para>
	  Система APT состоит из нескольких утилит.
	  Чаще всего используется утилита управления пакетами
	  <command>apt-get</command>: она автоматически определяет
	  зависимости между пакетами и строго следит за их соблюдением при
	  выполнении любой из следующих операций: установка, удаление или
	  обновление пакетов.
	</para>

	<sect4>
	  <title>Источники программ (репозитории)</title>
	  
	  <para><emphasis>Репозитории</emphasis>, с которыми работает APT,
	    отличаются от обычного набора пакетов наличием метаинформации
	    &mdash; индексов содержащихся в репозитории пакетов и сведений о
	    них. Поэтому, чтобы получить всю информацию о репозитории, APT
	    достаточно получить его индексы.</para>
	  
	  <para>
	    APT может работать с любым количеством репозиториев
	    одновременно, формируя единую информационную базу обо всех
	    содержащихся в них пакетах. При установке пакетов APT обращает
	    внимание только на название пакета, его версию и зависимости, а
	    расположение в том или ином репозитории не имеет значения. Если
	    потребуется, APT в рамках одной операции установки группы
	    пакетов может пользоваться несколькими репозиториями.
	  </para>
	  
	  <para>
	    APT позволяет взаимодействовать с
	    репозиторием с помощью различных протоколов доступа. Наиболее
	    популярные &mdash; HTTP и FTP,
	    однако существуют и некоторые дополнительные методы.
	  </para>
	  
	  <para>
	    Для того, чтобы APT мог использовать тот или иной репозиторий,
	    информацию о нем необходимо поместить в файл
	    <filename>/etc/apt/sources.list</filename><footnote>
	      <para>Если быть точным, этот файл может называться и иначе,
		другое имя файла со списком источников программ можно
		указать в конфигурационном файле
		<filename>/etc/apt/apt.conf</filename>. Подробнее о формате
		файла <filename>apt.conf</filename> можно узнать из
		руководства <command>apt.conf(5)</command>.
	      </para>
	    </footnote>. Описания репозиториев заносятся в этот файл в
	    следующем виде:
	  </para>

	  <informalexample>	  
	    <screen>rpm [подпись] метод:путь база название
rpm-src [подпись] метод:путь база название</screen>
	  </informalexample>
	  
	  <variablelist>
	    <varlistentry>
	      <term>rpm или rpm-src</term>
	      <listitem>
		<para>Тип репозитория (скомпилированные программы или
		  исходные тексты);</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>подпись</term>
	      <listitem>
		<para>Необязательная строка-указатель на электронную подпись
	  разработчиков. Наличие этого поля подразумевает, что каждый
	  пакет из данного репозитория должен быть подписан
		  соответствующей электронной подписью. Подписи описываются в
	  файле <filename>/etc/apt/vendor.list</filename>;</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>метод</term>
	<listitem>
	  <para>Способ доступа к репозиторию: ftp, http, file, rsh,
	  ssh, cdrom;</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>путь</term>
	<listitem>
	  <para>Путь к репозиторию в терминах выбранного
	    метода;</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>база</term>
	<listitem>
	  <para>Относительный путь к базе данных репозитория;</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>название</term>
	<listitem>
	  <para>Название репозитория;</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>После того, как отредактирован список репозиториев в
      <filename>sources.list</filename>, необходимо обновить локальную
      базу данных APT о доступных пакетах. Это делается командой
      <command>apt-get update</command>. 
    </para>

    <para>
      Если в <filename>sources.list</filename> присутствует
      репозиторий, содержимое которого может изменяться (как происходит с
      любым постоянно разрабатываемым репозиторием), то прежде, чем работать с APT, необходимо
      синхронизировать локальную базу данных с удалённым сервером
      командой <command>apt-get update</command>. Локальная база данных
      создаётся заново каждый раз, когда в репозитории происходит
      изменение: добавление, удаление или переименование пакета. 
    </para>

    <para>При выборе пакетов для установки APT руководствуется
      <emphasis>всеми</emphasis> доступными репозиториями, вне
      зависимости от способа доступа к ним. Так, если в репозитории,
      доступном по сети Интернет, обнаружена более новая версия
      программы, чем на компакт-диске, то APT начнёт загружать данный
      пакет из Интернет. Поэтому если подключение к Интернет
      отсутствует, или ограничено низкой пропускной способностью канала,
      или выской стоимостью, то следует закомментировать те строчки в
      <filename>/etc/apt/sources.list</filename>, в которых говорится
      о ресурсах, доступных по Интернет.</para>

  </sect4>

	<para>
	  Практические вопросы работы с командами <command>apt-get</command>
	  и <command>apt-cache</command> рассматриваются в разделе:
	  <xref linkend="base-admin-software-cmd"/>.
	</para>

      </sect3>
    </sect2>

    <sect2 id="base-admin-software-lect-summary">
      <title>Резюме</title>
      <presentation number="8-08" name="резюме"/>
      <para>
	В процесс разработки и использования программного обеспечения вовлечены несколько
	лиц: разработчик, системный администратор, пользователь и (в открытых системах)
	разработчик дистрибутива. Их роли различаются в зависимости от способа
	распространения программного обеспечения.
      </para>
      <para>
	При распространении программ в исходных текстах администратору приходится
	компилировать их на своей стороне. Распространение программ в
	двоичном (уже скомпилированном)	виде позволяет снизить требования к аппаратным ресурсам компьютера и
	квалификации администратора.
      </para>
      <para>
	Современные UNIX-подобные системы предлагают средства управления программами как
	на основе компиляции программ, так и на основе двоичных пакетов.
      </para>
      <para>
	Наиболее распространённым форматом (и менеджером) пакетов является
	<application>rpm</application>, впервые использованный в дистрибутиве Red&nbsp;Hat.
      </para>
      <para>
	Современные дистрибутивы используют репозитории&nbsp;&mdash;
	архивы текущих версий всех пакетов для упрощения
	установки и обновления программ через Интернет. Работа
	с репозиториями пакетов производится с помощью дополнительных
	программ (например, <application>APT</application>).
      </para>
      <list-of-definitions/>
    </sect2>
    
    <sect2 id="base-admin-software-lect-additional">
      <title>Дополнительные материалы</title>
      <para>
	<orderedlist>
	  <listitem>
	    Курячий Г.В., Маслинский К.А. <emphasis>Операционная система
	      Linux</emphasis>.&nbsp;&mdash; М.: Интуит.Ру, 2005.&nbsp;&mdash; 392 с.: ил.
	  </listitem>
	</orderedlist>
      </para>
    </sect2>    
    <list-of-questions/>
    <small-presentation/>
  </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
