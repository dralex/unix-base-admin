<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
	  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [

	  <!ENTITY % CommonEntities PUBLIC
		   "-//IU7 LUG//ENTITIES Common Documentation//RU"
		   "common.ent">
	  %CommonEntities;
	  
	  <!ENTITY BASEIMAGES "images/">

]>

<chapter id="chapter-intro">
  <title>Введение в операционную систему UNIX</title>
  <para>
    Современные открытые операционные системы, такие как &LINUXLNK; или &OPENBSDLNK;,
    предсталяют собой наследие операционной системы UNIX, появившейся в начале 1970-х годов
    и оказавшей огромное влияние на практические реализации операционных систем и развитие
    всей области информационных технологий. Поэтому изучение любой из современных
    UNIX-подобных операционных систем невозможно без рассмотрения основных идей,
    заложенных в оригинальный UNIX.
  </para>
  <para>
    В этой главе изложены основы теории операционных систем и то, как эти
    концепции реализованы в операционной системе UNIX. Также в ней рассматриваются
    основные этапы развития операционных систем с момента их возникновения до настоящего
    времени.
  </para>
  <!-- занятие №1 (лекция) -->
  <sect1 id="intro-concepts">
    <title>Основные концепции операционных систем</title>
    <sect2 id="intro-concepts-cs">
      <title>Обзор компьютерных систем</title>
      <presentation number="1-01" name="обзор компьютерных систем"/>
      <para>
	Все современные компьютерные системы построены по
	<definition id="def-von-Neumann" orig="три принципа фон Неймана">трём
	  принципам</definition> Джона фон Неймана: <emphasis>программного
	  управления</emphasis>, <emphasis>однородности памяти</emphasis>
	и <emphasis>адресности</emphasis>. Эти принципы можно раскрыть следующим
	образом: программа, состоящая из набора команд, и исходные данные хранятся в
	общей памяти, каждая ячейка которой имеет свой адрес (набор всех адресов, к
	  которым может обращаться программа, называется <definition id="address-space"
	  orig="адресное пространство">адресным пространством</definition>); каждая команда вместе с
	данными выбирается из памяти и исполняется процессором, выбор команды
	осуществляется с помощью специального <emphasis>счётчика команд</emphasis>,
	который содержит в себе адрес исполняемой в данный момент команды; команды
	расположены в памяти друг за другом, за счёт чего организуется последовательная
	выборка из памяти цепочки команд.
      </para>
      <para>
	На основании этого можно выделить три основных структурных элемента компьютера
	(см. <xref linkend="img-computer-structure"/>):
	<variablelist>
	  <varlistentry>
	    <term>Процессор</term>
	    <listitem><para>
		Осуществляет контроль за действиями компьютера, а также выполняет функцию
		обработки данных согласно программе. В современных системах может быть один
		и больше центральных процессоров.
	    </para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Основная память</term>
	    <listitem><para>
		В ней хранятся программы и данные. Как правило является временной
		(информация сохраняется, пока подаётся питание).
	    </para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Устройства ввода-вывода</term>
	    <listitem><para> Служат для передачи данных между компьютером и внешним
		окружением, состоящим из периферийных устройств, в число которых входят
		внешняя память, коммуникационное оборудование, терминалы.
	    </para></listitem>
	  </varlistentry>
	</variablelist>
      </para>
      <para>
	Перечисленные компоненты вычислительной системы объединяются с
	помощью <definition id="def-system-bus" orig="системная шина">системной
	  шины</definition>. Термином <emphasis>шина</emphasis> принято обозначать
	структуры и механизмы, обеспечивающие взаимодействие между
	разными компонентами системы, в данном случае 
	процессором, основной памятью и устройствами ввода-вывода.
      </para>
      <para>
	<figure id="img-computer-structure">
	  <title>Компоненты компьютерных систем</title>
	  <graphic fileref="&BASEIMAGES;computer_structure.png"/>
	</figure>
      </para>
      <presentation number="1-02" name="центральный процессор"/>
      <para>
	<definition id="def-cpu" orig="центральный процессор">Центральный
	  процессор</definition> извлекает программу из памяти, декодирует и исполняет
	машинные команды. Обычно команды исполняются последовательно, но иногда возможны
	переходы к другим участкам программы, например, по заданному условию.
      </para>
      <para>
	В каждый момент времени процессор может испонять только одну программу. Многие
	современные операционные системы относятся к <definition id="def-mp-os"
	orig="многозадачные ОС">многозадачным</definition>, т.&nbsp;е.
	в системе одновременно может
	исполняться несколько задач, число которых заранее неизвестно. Так как число
	процессоров конечно, необходимы алгоритмы, позволяющие чередовать исполнения
	процессов так, чтобы каждый из них получал процессорное время. Этот подход
	называется <definition id="def-pseudo-parallel"
	orig="псевдопараллелизм">псевдопараллелизмом</definition>
	(см. <xref linkend="img-parallelism"/>): каждому процессу
	выделяется <definition id="def-cpu-quant">квант процессорного
	времени</definition>, по истечении которого управление передается другому процессу
	(это действие называют <definition id="def-context-switch" orig="переключение
	контекста">переключением контекста</definition>). Также управление может быть
	передано другому процессу, если исполняемый процесс ожидает
	появления некоего системного ресурса, например, завершения
	операции ввода-вывода.
      </para>
      <para> В случае многопроцессорных компьютеров принцип остаётся
	прежним&nbsp;&mdash; на каждом процессоре исполняется только
	один процесс в каждый момент времени, повышение эффективности
	достигается экстенсивным путём за счёт
	нескольких одновременно работающих процессоров. Логика
	алгоритмов псевдопараллелизма несколько усложняется на
	многопроцессорных архитектурах за счёт необходимости
	балансировать нагрузку между несколькими процессорами,
	минимизируя время простоя каждого. Это означает, что каждый
	следующий квант	процессорного времени может быть выдан
	процессу на любом из доступных процессоров.
      </para>
      <para>
	<figure id="img-parallelism">
	  <title>Пример пcевдопараллелизма</title>
	  <graphic fileref="&BASEIMAGES;parallelism.png"/>
	</figure>
      </para>
      <presentation number="1-03" name="память"/>
      <para>
	Конфигурация памяти компьютера определяется в основном тремя
	параметрами: <emphasis>объём</emphasis>, <emphasis>быстродействие</emphasis>,
	<emphasis>стоимость</emphasis>. Очевидно, между этими противоречивыми
	характеристиками существует компромисс, который представляет
	собой <definition id="def-memory-hierarchy" orig="иерархия памяти">иерархию
	  памяти</definition> (см. <xref linkend="img-memory-hierarchy"/>). Таким образом, к
	дорогим устройствам с высокой производительностью и малым объёмом добавляются
	дешёвые устройства с меньшей скоростью доступа и большим объёмом. При этом ярко
	выражена функция каждого из уровней: регистровая память хранит операнды команд,
	кэш используется для хранения самых используемых участков памяти, основная память
	хранит исполняющиеся программы, внешняя&nbsp;&mdash; сохраняет данные и программы
	между запусками.
      </para>
      <para>
	<figure id="img-memory-hierarchy">
	  <title>Иерархия видов памяти</title>
	  <graphic fileref="&BASEIMAGES;memory_hierarchy.png"/>
	</figure>
      </para>
      <para>
	Особое значение имеет <emphasis>основная память</emphasis>&nbsp;&mdash; в ней
	хранятся все исполняющиеся программы и данные к ним. Программа может обращаться к
	любой ячейке памяти из доступного множества (которое
	называется <definition id="def-address-space" orig="адресное
	пространство">адресным пространством</definition>). Существует несколько видов
	адресных пространств: <emphasis>реальные</emphasis> (соответствуют ячейкам
	физической памяти или портам ввода-вывода) и <emphasis>виртуальные</emphasis> (определённым образом
	проецируемые на реальные адресные пространства). В современных операционных
	системах каждый процесс обладает своим собственным адресным пространством, так что
	не может нанести вред памяти других процессов. Подробнее виртуальная память
	рассматривается в разделе <xref linkend="intro-unixproc-virtmem"/>.
      </para>
      <presentation number="1-04" name="управление вводом-выводом"/>
      <para>
	Современные компьютеры состоят из большого числа узлов. С аппаратной точки зрения,
	внешние устройства&nbsp;&mdash; это все компоненты компьютера за исключением
	процессора и оперативной памяти. Взаимодействие с внешними устройствами (или
	устройствами ввода-вывода) осуществляется через специальные устройства, которые
	называются <emphasis>шинами</emphasis> и представляют собой по сути набор проводов
	с заданными характеристиками и правилами использования. В современных компьютерах,
	как правило, одновременно представлено несколько шин (например, PCI, PCI-Express, USB).
      </para>
      <para>
	Взаимодействие с устройствами ввода-вывода может происходить тремя способами:
	<emphasis>программируемый ввод-вывод</emphasis>, ввод-вывод с
	помощью <definition id="def-interrupt"
	orig="прерывание">прерываний</definition>, <definition id="def-dma">прямой доступ
	к памяти</definition> (Direct Memory Access, DMA).
      </para>
      <para>
	В первом случае процессор явно обращается к контроллеру внешнего устройства,
	вызывая управляющие команды и обмениваясь данными. Так как скорость работы
	процессора значительно превышает скорость работы внешних устройств, при таком
	способе обмена простои в работе процессора будут очень велики. Для избежания этой
	ситуации используется механизм <emphasis>прерываний</emphasis>: выполнение
	программы в процессоре может быть прервано, когда данные на внешнем устройстве
	готовы для чтения или записи; при этом запускается специальная
	функция-обработчик прерывания, затем выполнение исходной программы
	возобновляется. При использовании <emphasis>прямого доступа к памяти</emphasis>
	процессор не участвует в процессе ввода-вывода&nbsp;&mdash; за копированием данных
	из устройства в основную память следит специальный контроллер прямого доступа к
	памяти.
      </para>
    </sect2>
    <sect2 id="intro-concepts-os">
      <title>Назначение операционной системы</title>
      <presentation number="1-05" name="Операционная система"/>
      <question id="quest-1-1">Каково назначение операционной системы? Почему говорят
	об операционной системе как виртуальной машине? Какими ресурсами и
	как управляет операционная система?</question>
      <para>
	<definition id="def-os" orig="операционная система">Операционная
	  система</definition>&nbsp;&mdash; это комплекс взаимосвязанных программ, который
	действует как интерфейс между приложениями и пользователями с одной стороны и
	аппаратурой компьютера с другой стороны. В соответствии с этим определением
	операционная система выполняет две основные функции:
	<itemizedlist>
	  <listitem>
	    предоставление пользователю или программисту вместо реальной аппаратуры
	    расширенной <emphasis>виртуальной машины</emphasis> (которую иногда
	    называют <emphasis>операционная среда</emphasis>), с которой удобно работать и
	    которую легче программировать;
	  </listitem>
	  <listitem>
	    повышение эффективности использования компьютера путём рационального
	    управления его ресурсами в соответствии с некоторыми критериями.
	  </listitem>
	</itemizedlist>
      </para>
      <sect3 id="intro-concepts-os-vm">
	<title>Операционная система как виртуальная машина</title>
	<presentation number="1-06" name="виртуальная машина"/>
	<para>
	  Для того, чтобы успешно решать свои задачи, в настоящее время пользователь или
	  программист может обойтись без досконального знания аппаратного устройства
	  компьютера и может даже не знать системы команд процессора (для программистов
	  существует множество библиотек и высокоуровневых функций). 
	</para>
	<para>
	  Программное и аппаратное обеспечение можно выстроить в виде иерархии, каждый
	  уровень которой представляет собой <definition id="def-vm" orig="виртуальная
	  машина">виртуальную машину</definition> со своим интерфейсом (например,
	  <xref linkend="img-virtual-machine"/>), за которым скрываются детали
	  нижележащего уровня.
	</para>
	<para>
	  <figure id="img-virtual-machine">
	    <title>Уровни вычислительной системы</title>
	    <graphic fileref="&BASEIMAGES;virtual_machine.png"/>
	  </figure>
	</para>
	<para>
	  Операционная система избавляет программистов от необходимости напрямую работать
	  с аппаратурой, предоставляя им простой интерефейс (файловый, сетевой и т.&nbsp;п.), а
	  также берёт на себя все рутинные операции по управлению аппаратными устройствами
	  компьютера: физической памятью, таймерами, устройствами ввода и т.&nbsp;п.
	</para>
	<para>
	  В результате реальная машина, способная выполнять элементарные действия,
	  определённые её набором команд, превращается в виртуальную машину, выполняющую
	  набор более высокоуровневых функций. Виртуальная машина также управляется командами, но
	  более высокого уровня: создание и удаление файлов, установка сетевых соединений
	  и т.&nbsp;п. В свою очередь, эти команды также могут быть объединены в виртуальную
	  машину с более высоким уровнем абстракции (например: графический пользовательский
	  интерфейс, который оперирует объектами).
	</para>
      </sect3>
      <sect3 id="intro-concepts-os-rm">
	<title>Операционная система как менеджер ресурсов</title>
	<presentation number="1-07" name="управлнение ресурсами"/>
	<para>
	  Операционная система не только позволяет запускать прикладные программы,
	  но и является механизмом, распределяющим ресурсы
	  компьютера в ходе работы этих программ.
	</para>
	<para>
	  В разделе <xref linkend="intro-concepts-cs"/> уже рассматривались основные
	  <definition id="def-resources" orig="ресурс">ресурсы</definition> компьютера:
	  процессорное время, основная память, всевозможные внешние устройства; также к
	  ресурсам можно отнести таймеры и некоторые процедуры операционной
	  системы. Ресурсы распределяются между
	  процессами. <definition id="def-process" orig="процесс">Процесс</definition>
	  предсталяет собой базовое понятие большинства операционных систем, и чаще всего
	  определяется как программа, находящаяся в стадии выполнения.
	</para>
	<para>
	  Управление ресурсами вычислительной системы с целью наиболее эффективного их
	  использования&nbsp;&mdash; назначение операционной системы. Многозадачная
	  операционная система занимается переключением процессора с одного процесса на
	  другой, максимизируя его загрузку, а также отслеживает конфликты при обращении к
	  общим ресурсам.
	</para>
	<para>
	  Критерий эффективности, в соответствии с которым операционная система организует
	  управление ресурсами компьютера, может быть различным и зависит от назначения
	  информационно-вычислительной системы, частью которой она является. Например, в
	  одних системах важен такой критерий,
	  как <definition id="def-production">пропускная
	  способность</definition>&nbsp;&mdash; число задач, выполненных за единицу
	  времени, а в других&nbsp;&mdash; <definition id="def-reaction">время
	  реакции</definition> (время, прошедшее с момента ввода команды до получения
	  отклика системы).
	</para>
      </sect3>
    </sect2>
    <sect2 id="intro-concepts-arch">
      <title>Архитектура операционной системы</title>
      <presentation number="1-08" name="архитектура операционной системы"/>
      <question id="quest-1-2">Архитектура операционной системы: что такое ядро и
      прикладные программы? Чем отличаются монолитные и микроядерные системы?</question>
      <para>
	Операционная система выполняет множество функций, которые обычно группируются в
	соответствии с видом ресурса, которым управляет операционная система, либо со
	специфической задачей, применимой ко всем видам ресурсов. Можно выделить следующие
	функции современной многозадачной многопользовательской операционнной системы:
	управление процессами, управление памятью, управление файлами и внешними
	устройствами, защита данных и администрирование, интерфейс прикладного
	программирования, пользовательский интерфейс. 
      </para>
      <para>
	Наиболее общим подходом к структуризации операционной системы является
	разделение всех её модулей на две группы:
	<itemizedlist>
	  <listitem>
	    <definition id="def-kernel">ядро</definition>&nbsp;&mdash; модули, выполняющие
	    основные функции операционной системы, решающие внутрисистемные задачи
	    организации вычислительного процесса, такие как переключение контекста,
	    управление памятью, обработка прерываний, работа с внешними устройствами и
	    т.&nbsp;п.
	  </listitem>
	  <listitem>
	    компоненты, реализующие дополнительные функции операционной
	    системы&nbsp;&mdash; всевозможные служебные программы,
	    или <definition id="def-utilites">утилиты</definition>.
	  </listitem>
	</itemizedlist>
      </para>
      <para> Для надежного управления ходом выполнения программ операционная система
	должна иметь по отношению к пользовательским процессам определённые
	привилегии&nbsp;&mdash; иначе некорректно работающее приложение сможет вмешаться в
	работу операционной системы. Например, взаимодействие с аппаратурой возможно
	только на самом высоком уровне привилегий, который не дается обычным программам.
	Чаще всего именно ядро является той частью операционной системы, которая работает
	в <definition id="def-privilegies" orig="привилегированый режим">привилегированном
	режиме</definition>.
      </para>
      <para>
	Большинство современных операционных систем представляет собой хорошо
	структурированные модульные системы, способные к развитию, расширению и переносу
	на новые платформы. Существует ряд универсальных подходов к стуктурированию
	операционных систем, среди которых можно выделить <emphasis>монолитную</emphasis>
	и <emphasis>микроядерную</emphasis> архитектуры.
      </para>
      <sect3 id="intro-concepts-arch-monolith">
	<title>Монолитная операционная система</title>
	<presentation number="1-09" name="монолитное ядро"/>
	<para>
	  Большинство операционных систем
	  использует <definition id="def-monolith-kernel">монолитное ядро</definition>,
	  которое компонуется как одна программа, работающая в привилегированном режиме и
	  использующая быстрые переходы с одной процедуры на другую, не требующие
	  переключения из привилегированного режима в пользовательский и наоборот (хоть
	  этот процесс и происходит с аппаратной поддержкой, он занимает значительное
	  время). Такое ядро делится на основные компоненты и модули, реализующие
	  дополнительную функциональность,&nbsp;&mdash; например, работу со специфическими
	  внешними устройствами и файловыми системами
	  (см. <xref linkend="img-monolith-kernel"/>).  Переход из пользовательского
	  режима в режим ядра осуществляется через <definition id="def-system-call"
	  orig="системный вызов">системные
	  вызовы</definition>&nbsp;&mdash; интерфейс ядра операционной системы.
	</para>
	<para>
	  <figure id="img-monolith-kernel">
	    <title>Структура монолитного ядра операционной системы</title>
	    <graphic fileref="&BASEIMAGES;monolith_kernel.png"/>
	  </figure>
	</para>
      </sect3>
      <sect3 id="intro-concepts-arch-microkernel">
	<title>Микроядерная операционная система</title>
	<presentation number="1-10" name="микроядро"/>
	<para>
	  Альтернативой является построение операционной системы на
	  базе <definition id="def-microkernel" orig="микроядро">микроядра</definition>,
	  работающего также в привилегированном режиме и выполняющего только минимум
	  функций по управлению аппаратурой. В этом случае более
	  высокоуровневые функции операционной системы выполняются специализированными
	  компонентами&nbsp;&mdash; <emphasis>серверами</emphasis>, работающими в
	  пользовательском режиме. Управление и обмен данными при этом осуществляется
	  через передачу <definition id="def-message"
	  orig="сообщение">сообщений</definition>, доставка которых является одной из
	  основных функций микроядра (см. <xref linkend="img-micro-kernel"/>).
	</para>
	<para>
	  При таком построении операционная система работает значительно более медленно,
	  так как часто выполняются переходы между привилегированным и пользовательским
	  режимом, зато система получается более гибкой&nbsp;&mdash; её функции можно
	  наращивать или модифицировать, добавляя, изменяя или исключая серверы
	  пользовательского режима. Кроме того, серверы хорошо защищены друг от друга, как
	  и любые пользовательские процессы.
	</para>
	<para>
	  <figure id="img-micro-kernel">
	    <title>Структура операционной системы с микроядром</title>
	    <graphic fileref="&BASEIMAGES;micro_kernel.png"/>
	  </figure>
	</para>
      </sect3>
    </sect2>
    <sect2 id="intro-os-history">
      <title>Место UNIX в истории вычислительных систем</title>
      <presentation number="1-11" name="история операционных систем"/>
      <para>
	За полвека существования операционные системы прошли сложный путь,
	огромное влияние на который оказало развитие вычислительной аппаратуры. Хотя
	большинство алгоритмов и подходов в операционных системах было разработано в
	1960&ndash;1970-х годах, в настоящее время операционные системы продолжают
	развиваться и видоизменяться согласно потребностям пользователей. Можно выделить
	три основные характеристики, ставшие уже обязательными для большинства
	операционных систем: переносимость между различными аппаратными архитектурами,
	многозадачность и многопользовательский режим работы.
      </para>
      <para>
         В этом разделе не будет излагаться подробная и полная история
         операционных систем вообще и даже долгая и запутанная история
         самой UNIX&nbsp;&mdash; за этим стоит обратиться к специальным
         изданиям (см. список литературы). Здесь будет только обозначена роль UNIX в развитии
         самого представления о том, что такое <quote>операционная
         система</quote> и основные этапы распространения UNIX в разных типах
         вычислительных систем.
      </para>

      <sect3 id="intro-before-os">
	<title>Что было до операционных систем</title>
	<para>
	  С середины 1950-х годов началось бурное развитие вычислительной техники, связанное
	  с появлением полупроводниковых элементов. Вместе с этим заметный прогресс
	  наблюдался в автоматизации программирования и организации вычислений, в эти годы
	  появились первые алгоритмические языки (Алгол, Фортран, Кобол). Для организации
	  эффективного совместного использования трансляторов, библиотечных программ и
	  загрузчиков в штат многих вычислительных комплексов были
	  введены специальные сотрудники&nbsp;&mdash;
	  <emphasis>операторы</emphasis>. Но как бы быстро они ни
	  работали, они не могли состязаться в производительности с работой
	  компьютера. Для решения этой проблемы были
	  разработаны <definition id="def-packet-systems">системы пакетной
	  обработки</definition>, которые автоматизировали последовательность действий
	  оператора. Оператор составлял <emphasis>пакет заданий</emphasis>, которые в
	  дальнейшем без его участия запускались на выполнение специальной
	  программой&nbsp;&mdash; <emphasis>монитором</emphasis>.
	</para>  
      </sect3>
      <sect3 id="intro-os-mainframes">
	<title>Операционные системы для мэйнфреймов</title>
	<para>
	  В 1965&ndash;1975 годах появилось следующее поколение компьютеров: стала
	  возможна реализация сложных компьютерных архитектур (например, IBM/360) и
	  практически всех основных механизмов, присущих современным операционным
	  системам: многозадачность, поддержка многотерминального многопользовательского
	  режима работы, виртуальная память, файловые системы, разграничение доступа и
	  сетевая работа. Но такие системы всё ещё были очень редки и чрезвычайно дороги.
	</para> 
	<para>
	  Одним из главных достижений стал переход к <definition id="def-multiprogramming"
	  orig="мультипрограммирование">мультипрограммированию</definition>&nbsp;&mdash;
	  способ организации вычислительного процесса, при котором в памяти компьютера
	  одновременно находится несколько программ, попеременно выполняющихся на одном
	  процессоре. Для того, чтобы у пользователя оставалось ощущение непосредственного
	  взаимодействия с компьютером, был разработан такой вариант
	  мультипрограммирования, как <definition id="def-shared-time-systems">системы
	  разделения времени</definition>. Каждый пользователь работает за своим
	  терминалом (подробнее терминалы рассматриваются в разделе
	  <xref linkend="shell-base-terminal"/>), тогда как все процессы работают
	  псевдопараллельно (как было показано выше, в разделе
	  <xref linkend="intro-concepts-cs"/>).
	</para>
      </sect3>
      <sect3 id="intro-os-unix">
	<title>Появление операционной системы UNIX</title>
	<para>
	  В середине 1970-х годов наряду с мэйнфреймами получили широкое распространение
	  мини-компьютеры (слово <quote>мини-</quote> сейчас может показаться смешным,
	  такие компьютеры занимали объём в несколько шкафов), такие как
	  PDP-11. Архитектура таких компьютеров была заметно упрощена по сравнению с
	  мэйнфреймами (что значительно снижало стоимость&nbsp;&mdash; с миллионов до сотен тысяч
	  долларов), что сказалось на операционных системах для этих
	  компьютеров&nbsp;&mdash; они были лишены части функций, например
	  многопользовательского режима работы.
	</para>
	<para>
	  Важным этапом в истории мини-компьютеров и операционных систем в целом явилось
	  появление операционной системы UNIX в лаборатории Bell Labs
	  компании AT&amp;T. Изначально она была разработана для мини-компьютера PDP-7 и
	  включала в себя множество архитектурных особенностей более сложных операционных
	  систем, такие как разделение времени и многопользовательская работа. В 1970-х
	  годах началось массовое использование операционной системы UNIX, к этому времени
	  она была переписана на языке программирования высокого уровня С, что заметно
	  облегчило её переносимость. Поскольку эта операционная система распространялась
	  вместе с исходными текстами, она стала первой операционной системой, в которою
          могли вносить изменения энтузиасты. Очень значительную роль
          открытые исходные тексты UNIX сыграли в распространении этой
          системы в образовательной и научной среде, прежде всего в
          университетах. Наиболее известен в этой области проект
          BSD (Berkley Software Distribution) &mdash;
          академическая версия UNIX, созданная в университете
          Беркли. Впоследствии BSD стал основой для очень многих
          коммерческих и некоммерческих проектов, в том числе широко
          распространённой сегодня свободной реализации UNIX&nbsp;&mdash; FreeBSD.
        </para>
        <para>
          Удачные архитектурные решения UNIX,
	  гибкость, элегантность, мощные функциональные возможности и открытость позволили
	  этой операционной системе завоевать рынок не только мини-компьютеров, но и
	  мэйнфреймов, серверов, рабочих станций на
	  базе RISC-процессоров.
	  Многие появившиеся впоследствии операционные системы позаимствовали некоторые
	  ключевые идеи UNIX: переносимость на основе языка C, иерархическую файловую
	  систему, интерфейс командной строки. 
	</para>
      </sect3>
      <sect3 id="intro-os-internet">
	<title>Развитие операционных систем в глобальных сетях</title>
	<para>
	  В начале 1980-х годов в рамках экспериментальной сети ARPANET
	  впервые появился рабочий вариант стека
	  протоколов TCP/IP. Переход на TCP/IP был
	  ускорен ещё и тем, что его первая реализация была создана в
	  рамках BSD UNIX . Новая глобальная
	  сеть, получившая название Интернет, стала средой для развития информационных
	  технологий, создания всевозможных сообществ разработчиков и развития открытых
	  систем. Кроме того, несколько позже BSD стала основой
          широко распространённой свободной реализации
          UNIX&nbsp;&mdash; FreeBSD.
	</para>  
	<para>
	  В этот период появляется множество коммерческих версий операционной системы
	  UNIX: SunOS (в дальнейшем Solaris), HP-UX, Irix, AIX и многие
	  другие.  Разнообразие версий породило проблему их несовместимости, которую
	  периодически пытались решать различные организации. В результате были приняты
	  стандарты POSIX (Portable Operation System Interface based on
	  uniX&nbsp;&mdash; интерфейс для переносимых операционных систем, основанных на
	  UNIX), включающие формальное описание программного интерфейса операционной
	  системы, описание командной оболочки, политики безопасности и т.&nbsp;п.
	</para>
      </sect3>
      <sect3 id="intro-os-pc">
	<title>Операционные системы для персональных компьютеров</title>
	<para>
	  Ещё одно знаменательное событие начала 1980-х годов&nbsp;&mdash;
	  появление <emphasis>персональных компьютеров</emphasis>. С точки зрения
	  архитектуры они мало отличались от мини-компьютеров и рабочих станций, но
	  стоимость их была значительно ниже. Это позволило персональным компьютерам
	  повсеместно распространиться, и это в значительной степени изменило современные
	  информационные технологии.
	</para>  
	<para>
	  Первые операционные системы для персональных компьютеров были очень просты
          хотя бы в силу весьма ограниченных ресурсов. Наглядным примером может
          служить DOS, получивший весьма широкое распространение в
          версии MS-DOS. По сравнению с
          операционными системами для <quote>настоящих</quote>
          компьютеров операционные системы для ПК не имели многих
          существенных свойств: в частности, многозадачности и
          многопользовательской работы. Однако основные области
          применения ПК требовали не этого, поэтому недостатки в
          функциональности ОС компенсировались активным развитием
          графического интерфейса пользователя. В частности,
          MacOS для компьютеров Macintosh (в ранних версиях
          называвшаяся попросту System Software) была одной из первых операционных
          систем, которая вообще не имела интерфейса командной строки,
          а управлялась исключительно средствами графического
          интерфейса. Со временем подобные
	  операционные системы (например, Microsoft Windows) получили сетевую подсистему и
	  возможность работать с несколькими программами одновременно.
	</para>
	<para>
	  В первую очередь благодаря низкой стоимости аппаратного и программного
	  обеспечения, персональные компьютеры начали вытеснять прежде распространённые
          рабочие станции и мэйнфреймы. На домашних и офисных
          компьютерах в 1980-е повсеместно
          распространились персональные компьютеры в основном от
          IBM/PС, а вместе с ними и операционные системы компании Microsoft.
          В этот период наследники UNIX занимали более <quote>промышленную</quote> нишу
          в вычислительных технологиях (крупные вычислительные центры, сети).
        </para>
        <para>
          К концу 1980-х персональные компьютеры были уже далеко не
          так ограничены в ресурсах, как десятью годами раньше,
          развивалась и архитектура процессоров, что в целом создало
          возможность реализации на ПК многозадачных и
          многопользовательских систем. К таким системам относятся OS/2
          (не получила широкого распространения) и Windows NT. Кроме
          того, появилась и была реализована возможность перенести на
          ПК и UNIX. Первый такой опыт был сделан Эндрю Танненбаумом в
          образовательных целях: он создал систему MINIX (MINimal
          unIX), которую можно было использовать на IBM/PC в
          образовательных целях для демонстрации некоторых основных
          принципов операционных систем. Однако MINIX никогда не был
          полноценной операционной системой для повседневной
          работы.
        </para>
        <para>
          Заслуга полноценного переноса UNIX на IBM/PC принадлежит Линусу
          Торвальдсу, который в 1991 году опубликовал первую версию
          написанной им реализации ядра UNIX-совместимой операционной
          системы для IBM/PC x386, известной сегодня как Linux. Благодаря открытой
          публикации и активному участию множества этузиастов, Linux
          динамично развивался и быстро стал полноценной и современной
          операционной системой и дал путь широкому распространению
          идей и технологий UNIX в том числе и на персональных
          компьютерах. Linux как реализация UNIX был в свою очередь
          перенесён и на другие вычислительные архитектуры.
        </para>
        <para>
          Технологии UNIX пришли и на современные персональные
          компьютеры Macintosh: начиная с версии 10 (Mac OS X)
          вся базовая часть операционной системы Mac OS, работающая с
          ресурсами и оборудованием, представляет собой один из
          вариантов FreeBSD&nbsp;&mdash; Darwin.
	</para>
      </sect3>
      <sect3 id="intro-os-embedded">
	<title>Операционные системы для встраиваемых систем</title>
	<para>
	  В начале 21-го века широкое распространение
	  получили <emphasis>встраиваемые</emphasis> и <emphasis>мобильные</emphasis>
	  устройства. Благодаря развитию вычислительных систем такие устройства, как
	  мобильные телефоны или домашние бытовые приборы обрели возможности, сравнимые с
	  персональными компьютерами. В настоящее время в этой области существует
	  множество операционных систем, среди которых всё большую роль начинают играть
	  открытые операционные системы, наследующие архитектуру и принципы работы UNIX.
	  Например, с 2005 года Linux устанавливается уже более чем на половине всех
	  встраиваемых устройств, а сфера бытовых роботов сейчас почти полностью занята
	  этой операционной системой.
	</para>  
      </sect3>
      <sect3 id="intro-os-different-unix">
	<title>Такой разный UNIX</title>
	<para>
	  Операционная система UNIX оказала значительное влияние на все операционные
	  системы последних десятилетий. Однако многие из них являются
	  прямыми <quote>наследниками</quote> той операционной системы, что была
	  создана в стенах Bell Labs. Само же слово <quote>unix</quote> (здесь слово
	  сознательно написано с маленькой буквы, так как термин <quote>UNIX</quote>
	  является зарегистрированной торговой маркой и, строго говоря, может ставиться в
	  соответствие только сертифицированным системам) стало обозначать целый класс
	  операционных систем со схожей архитектурой, интерфейсом и набором программного
	  обеспечения.
	</para>
	<para>
	  В следующих лекциях будет рассказано о различиях между современными реализациями
	  UNIX и обо всём том, что объединяет эти системы. В качестве основы для
	  практического изучения взята операционная система Linux&nbsp;&mdash; наиболее
	  доступная и распростронённая из некоммерческих версий UNIX.
	</para>
      </sect3>
    </sect2>
    <sect2 id="intro-os-classification">
      <title>Классификация операционных систем по назначению</title>
      <presentation number="1-12" name="классификация операционных систем"/>
      <question id="quest-1-3">Какие можно выделить классы операционных систем? В чём
      заключаются их отличия?</question>
      <para>
	Операционные системы являются неотъемлемой частью информационно-вычислительных
	комплексов. Такие комплексы могут выполнять весьма различные функции и могут быть по этому признаку
	разделены на некоторые классы.
      </para>
      <para>
	<variablelist>
	  <varlistentry>
	    <term><definition id="def-realtime-os" orig="ОС реального времени">Системы
	    реального времени</definition></term>
	    <listitem>
	      <para>
		Основной особенностью таких систем является сторого регламентированное
		время отклика на внешние события. Другим важным параметром является
		одновременная обработка&nbsp;&mdash; даже если одновременно происходит
		несколько событий, реакция системы на них не должна
		запаздывать. Компьютеры для управления самолетами, ядерными реакторами и
		подобными сложными системами обычно работают под управлением 
		специализированных операционных систем реального времени.
	      </para>
	      <para>
		Операционные системы реального времени принято делить на два
		класса: <emphasis>жесткого</emphasis> и <emphasis>мягкого</emphasis>
		реального времени. Можно выделить признаки
		<definition id="def-hard-realtime" orig="жёсткое реальное время">систем
		жёсткого реального времени</definition>:
	      </para>
	      <para>
		<itemizedlist>
		  <listitem>
		    недопустимость никаких задержек ни при каких условиях;
		  </listitem>
		  <listitem>
		    бесполезность результатов при опоздании;
		  </listitem>
		  <listitem>
		    катастрофа при задержке реакции;
		  </listitem>
		  <listitem>
		    цена опоздания бесконечно велика.
		  </listitem>
		</itemizedlist>
	      </para>
	      <para>
		Хороший пример системы жесткого реального времени&nbsp;&mdash; бортовая
		система управления самолетом. Среди систем с жестким реальным временем
		можно выделить распространённую коммерческую операционную систему QNX,
		которая основывается на UNIX и имеет схожий интерфейс.
	      </para>
	      <para>
		<definition id="def-soft-realtime" orig="мягкое реальное время">Система
		мягкого реального времени</definition> характеризуется следующими
		признаками:
	      </para>
	      <para>
		<itemizedlist>
		  <listitem>
		    за опоздание результатов приходится платить;
		  </listitem>
		  <listitem>
		    снижение производительности системы, вызванное запаздыванием реакций,
		    приемлемо.
		  </listitem>
		</itemizedlist>
	      </para>
	      <para>
		Операционные системы мягкого реального времени могут использоваться в мобильных
		и коммуникационных системах&nbsp;&mdash; там, где цена опаздания не так
		велика. В настоящее время многие многозадачные операционные системы
		разделения времени модифицируются для того, чтобы соответствовать
		требованием мягкого реального времени. Среди примеров можно выделить
		варианты Windows NT и специфические версии ядра &LINUXLNK;.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Встраиваемые системы</term>
	    <listitem><para>
		Такие системы работают на специфическом аппаратном обеспечении (автомобили,
		микроволновые печи, роботы) и также обладают некоторыми требованиями к
		времени отклика системы. Как правило, в таких операционных системах
		применяются специфичные алгоритмы, минимизирующие потребляемые ресурсы. В
		настоящее время широкое распространение имеют операционные системы Windows
		Embedded фирмы Microsoft и различные версии операционной системы &LINUXLNK;.
	    </para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Операционные системы для супер-компьютеров</term>
	    <listitem><para>
		Для решения очень сложных и объёмных вычислительных задач создаются
		специализированные компьютеры, содержащие сотни и тысячи процессоров. Для
		управления такими системами применяются специальные операционные системы, в
		которых особенно важны вопросы производительности и скорости обмена между
		элементами системы. В настоящее время самыми распространёнными среди
		сверхпроизводительных систем являются модификации операционной системы
		&LINUXLNK;.
	    </para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Операционные системы для серверов</term>
	    <listitem>
	      <para>
		С момента расцвета сети Интернет нишу <definition id="def-server"
		orig="сервер">серверов</definition> (специализированных систем,
		предоставляющих по сети какой-то сервис <emphasis>клиентским
		системам</emphasis>) занимают универсальные многопользовательские
		многозадачные операционные системы. Для таких систем имеют большое
		значение стабильность работы, безопасность и производительность,
		меньшее&nbsp;&mdash; интерфейс пользователя.
	      </para>
	      <para>
		Примерами таких систем могут служить: банковские системы, веб-серверы и
		серверы баз данных, файловые серверы масштаба предприятия,
		многопользовательские терминальные серверы и т.&nbsp;п.  Традиционно этот класс
		систем обслуживается коммерческими операционными системами&nbsp;&mdash;
		различными версиями UNIX, операционными системами от компаний IBM, Novell, Sun,
		а затем и Microsoft. Сейчас все большую популярность в этом классе систем
		завоёвывают открытые и свободные операционные системы, базирующиеся на
		UNIX.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Операционные системы для домашних и офисных компьютеров</term>
	    <listitem><para>
		Современные персональные компьютеры обладают высокой производительностью и
		богатыми мультимедийными возможностями. Для операционных систем этого класса
		важны удобный пользовательский интерфейс и поддержка широкого круга
		устройств для персональных компьютеров. Самыми распространёнными
		операционными системами в этом классе являются продукты компании Micrososft,
		также на персональных компьютерах Apple используется операционная система
		MacOS (начиная с версии 10 она также основывается на UNIX).
	    </para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Исследовательские операционные системы</term>
	    <listitem><para>
		Многие алгоритмы и подходы в построении операционных систем не пошли дальше
		исследовательских лабораторий. Например, операционные системы, основанные на
		микроядре, в чистом виде не используются до сих пор из-за огромных затрат на
		пересылку сообщений. Одной из самых известных микроядерных операционных
		систем является Mach, на которой основывается целый ряд операционных систем,
		в том числе &HURDLNK;, реализующая интерфейс UNIX.
	    </para></listitem>
	  </varlistentry>
	</variablelist>	
      </para>
    </sect2>
    <sect2 id="intro-concepts-summary">
      <title>Резюме</title>
      <presentation number="1-13" name="резюме"/>
      <para>
	В первой лекции было предложено общее введение в операционные системы.
      </para>
      <para>
	Операционные системы существуют в рамках информационно-вычислительных систем,
	которые сейчас, как и много лет назад, построены в
	соответствии с принципами фон Неймана и
	содержат три основных компонента: центральный процессор, основную память и
	устройства ввода-вывода.
      </para>
      <para>
	Операционная система является комплексом программ, объединяющих пользователей,
	программы и аппаратуру компьютера. Выделяют две основные функции операционной
	системы: предоставление виртуальной машины и управление ресурсами компьютера.
      </para>
      <para>
	Операционная система состоит из модулей, среди которых выделяют ядро, как основу
	всей операционной системы. Существует два типа ядер: монолитные и микроядра.
      </para>
      <para>
	За время существования операционные системы прошли длительную эволюцию, однако
	большинство идей, алгоритмов и архитектурных решений было реализовано в
	1960&ndash;70-е годы: тогда появились многозадачность, многопользовательская
	работа, файловые системы и т.&nbsp;п.
      </para>
      <para>
	Современные операционные системы можно классифицировать по назначению. При
	этом выделяют операционные системы реального времени, для встраиваемых систем,
	для супер-компьютеров, для серверов, для домашних и офисных компьютеров и
	исследовательские.
      </para>
      <list-of-definitions/>
    </sect2>    
    <sect2 id="intro-concepts-additional">
      <title>Дополнительные материалы</title>
      <para>
	<orderedlist>
	  <listitem>
	    Курячий Г. В. <emphasis>Операционная система UNIX</emphasis>.&nbsp;&mdash;
	    М.: Интуит.Ру, 2004.&nbsp;&mdash; 292 с.: ил.
	  </listitem>
	  <listitem>
	    МакКузик М. К., Невилл-Нил Дж. В. <emphasis>FreeBSD:
	    архитектура и реализация</emphasis>.&nbsp;&mdash; М.:
	    КУДИЦ-ОБРАЗ, 2006.&nbsp;&mdash; 800 с.
	  </listitem>
	  <listitem>
	    Олифер В. Г., Олифер Н. А. <emphasis>Сетевые операционные
	    системы</emphasis>.&nbsp;&mdash; СПб.: Питер, 2005.&nbsp;&mdash; 539 с.: ил.
	  </listitem>
	  <listitem>
	    Рэймонд Э. С. <emphasis>Искусство программирования для
	      UNIX</emphasis>.&nbsp;&mdash; М.: Издательский дом <quote>Вильямс</quote>,
	      2005.&nbsp;&mdash; 544 стр.: ил.
	  </listitem>
	  <listitem>
	    Вильям Столлингс <emphasis>Операционные системы, 4-е
	    издание</emphasis>.&nbsp;&mdash; М.: Издательский дом <quote>Вильямс</quote>,
	    2002.&nbsp;&mdash; 848 с.: ил.
	  </listitem>
	</orderedlist>
      </para>
    </sect2>
    <list-of-questions id="intro-concepts-presentaion"/>
    <small-presentation id="intro-concepts-presentaion"/>
  </sect1>
  <!-- занятие №2 (лекция) -->
  <sect1 id="intro-unix">
    <title>Архитектура UNIX. Файлы и устройства</title>
    <sect2 id="intro-unix-concepts">
      <title>Особенности архитектуры UNIX</title>
      <presentation number="2-01" name="основные концепции UNIX"/>
      <para>
	Знакомство с архитектурой UNIX начнем с рассмотрения таких неотъемлимых для неё
	характеристических понятий, как <emphasis>стандартизация</emphasis>
	и <emphasis>многозадачность</emphasis>:
      </para>
      <para>
	<variablelist>
	  <varlistentry>
	    <term>Стандартизация</term>
	    <listitem>
              <para>
		Несмотря на многообразие версий UNIX, основой всего семейства являются
		принципиально одинаковая архитектура и ряд стандартных интерфейсов (в UNIX
		стандартизовано почти всё&nbsp;&mdash; от расположения
		системных каталогов и 
		файлов до интерфейса системных вызовов и списка драйверов базовых
		устройств). Опытный администратор без особого труда сможет обслуживать
		другую версию, тогда как для пользователей переход на другую систему и вовсе
		может оказаться незаметным. Для системных же программистов такого рода
		стандарты позволяют полностью сосредоточиться на программировании, не тратя
		время на изучение архитектуры и особенностей конкретной реализации системы.
              </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Многозадачность</term>
	    <listitem>
              <para>
		В системе UNIX может одновременно выполняться множество процессов (задач),
		причем их число логически не ограничивается и может меняться в ходе работы
		системы. Благодаря специальному
		механизму управления памятью каждый процесс
		существует в собственном изолированном
		адресном пространстве, что гарантирует безопасность и независимость от
		других процессов. Различные системные операции позволяют процессам порождать
		новые процессы, завершают процессы, синхронизируют выполнение этапов
		процесса и управляют реакцией на наступление различных событий.
              </para>
	    </listitem>
	  </varlistentry>
	</variablelist>      
      </para>
      <sect3 id="intro-unix-concepts-fp">
	<title>Два кита UNIX: файлы и процессы</title>    
	<question id="quest-2-1">В чём заключается особенность архитектуры UNIX?</question>
	<para>
	  Существует два основных объекта операционной системы UNIX, с которыми приходится
	  работать пользователю&nbsp;&mdash; <emphasis>файлы</emphasis>
	  и <emphasis>процессы</emphasis>. Эти объекты тесно связаны друг с другом, и в
	  целом способ организации работы с ними как раз и определяет архитектуру операционной
	  системы.
	</para>
	<para>
	  Все данные пользователя хранятся в <definition id="def-unix-file"
	  orig="файл">файлах</definition>; доступ к периферийным устройствам
	  осуществляется посредством чтения и записи специальных файлов; во время
	  выполнения программы операционная система считывает исполняемый код из файла в
	  память и передает ему управление. Принципы хранения и доступа к файлам
	  объединяются понятием <emphasis>файловой системы</emphasis>, которое будет
	  рассмотрено подробнее чуть позже.
	</para>  
	<para>
	  С другой стороны, вся функциональность информационной системы определяется
	  выполнением соответствующих <definition id="def-unix-process"
	  orig="процесс">процессов</definition>. Процесс&nbsp;&mdash; это исполняющаяся
	  программа, относящаяся к операционной системе или запущенная
	  пользователем.
	</para>
      </sect3>
      <sect3 id="intro-unix-concepts-arch">
	<title>Беглый взгляд на архитектуру UNIX</title>    
	<presentation number="2-02" name="беглый взгляд на архитектуру UNIX"/>
	<para>
	  Самый общий взляд на архитектуру UNIX позволяет
	  увидеть <definition id="def-unix-two-levels" orig="двухуровневая модель
	  системы">двухуровневую модель системы</definition>, состоящую
	  из <emphasis>пользовательской</emphasis> и <emphasis>системной части
	  (ядра)</emphasis> (см. <xref linkend="img-unix-arch"/>). Ядро непосредственно
	  взаимодействует с аппаратной частью компьютера, изолируя прикладные программы
	  (процессы в пользовательской части операционной системы) от особенностей ее
	  архитектуры. Ядро имеет набор услуг, предоставляемых прикладным программам
	  посредством системных вызовов. Таким образом, в системе можно выделить два
	  уровня привилегий: <emphasis>уровень системы</emphasis> (привилегии специального
	  пользователя root) и <emphasis>уровень пользователя</emphasis> (привилегии всех
	  остальных пользователей). Подробнее об управлении доступом рассказывается в
	  следующих главах (<xref linkend="security-lect"/>).
	</para>
	<para>
	  <figure id="img-unix-arch">
	    <title>Архитектура операционной системы UNIX</title>
	    <graphic fileref="&BASEIMAGES;unix_arch.png"/>
	  </figure>
	</para>
	<question id="quest-2-2">Какие программы называют демонами? Приведите
	примеры.</question>
      	<para>
	  Важную часть системных программ составляют <definition id="def-daemon"
	  orig="демон">демоны</definition>. Демон&nbsp;&mdash; это процесс, выполняющий
	  опеределенную функцию в системе, который запускается при старте системы и не
	  связан ни с одним пользовательским терминалом. Демоны предоставляют
	  пользователям определённые сервисы, примерами которых могут служить системный
	  журнал, веб-сервер и т.&nbsp;п. Аналогом демонов в операционной системе Windows NT и
	  более поздних версиях являются <emphasis>системные службы</emphasis>.
	</para>
      </sect3>
      <sect3 id="intro-unix-concepts-kernel">
	<title>Ядро UNIX</title>
	<presentation number="2-03" name="ядро UNIX"/>
	<question id="quest-2-3">Из каких частей состоит ядро UNIX?</question>
	<para>
	  Операционная система UNIX обладает классическим монолитным ядром
	  (см. <xref linkend="intro-concepts-arch"/>), в котором можно выделить следующие
	  основные части:
	  <variablelist>
	    <varlistentry>
	      <term>Файловая подсистема</term>
	      <listitem>
		<para>
		  Доступ к структурам ядра осуществляется через файловый
		  интерфейс.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Управление процессами</term>
	      <listitem>
		<para>
		  Сюда входит управление параллельным выполнением процессов (планирование
		  и диспетчеризация), виртуальной памятью процесса и взаимодействием
		  между процессами (сигналы, очереди сообщений и т.&nbsp;п.). 
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Драйверы устройств</term>
	      <listitem>
		<para>
		  Драйверы устройств делятся на символьные и блочные по типу внешнего
		  устройства. Для каждого из устройств определён набор возможных операций
		  (открытие, чтение и т.&nbsp;д.). Блочные устройства кэшируются с помощью
		  специального внутреннего механизма управления буферами. Подробнее об
		  этом сказано в разделе <xref linkend="intro-unix-devices"/>.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
	<para>
	  <figure id="img-unix-kernel">
	    <title>Ядро операционной системы UNIX</title>
	    <graphic fileref="&BASEIMAGES;unix_kernel.png"/>
	  </figure>
	</para>
	<para>
	  Благодаря тому, что в UNIX аппаратно-независимая
	  часть отделена явно, операционные системы этого семейства могут быть с минимальными
	  затратами перенесены на новые аппаратные платформы.
	</para>
	<para>
	  Видно, что ядро операционной системы UNIX является классическим для
	  многозадачной многопользовательской операционной системы, поэтому оно широко
	  используется не только в промышленной эксплуатации, но и в обучении
	  системному программированию и теории операционных систем.
	</para>
      </sect3>
    </sect2>
    <sect2 id = "intro-unix-files">
      <title>Файловая система UNIX</title>
      <para>
        Термин <definition id="def-fs">файловая система</definition> по историческим
        причинам обозначает одновременно и иерархию каталогов и файлов, и часть ядра,
        управляющую доступом к каталогам и файлам.
      </para>
      <sect3 id = "intro-unix-files-fs">
	<title>Особенности файловой системы</title>    
	<presentation number="2-04" name="файловая система UNIX"/>
	<question id="quest-2-4">Какими отличительными особенностями обладает файловая
	система UNIX?</question>
	<para> 
          Организация файловой системы в <emphasis>первом</emphasis>
	значении этого термина предполагает рассмотрение структур, в
          которые могут быть организованы файлы на носителях данных. Существует несколько
          видов таких структур: линейные, древовидные, объектные и другие, но в
          настоящее время широко распространены только древовидные структуры.
	</para>
	<para> Каждый файл в древовидной структуре расположен в определенном хранилище
	  файлов&nbsp;&mdash; <definition id="def-directory"
	  orig="каталог">каталоге</definition>, каждый каталог, в свою очередь, также
	  расположен в некотором каталоге. Таким образом, по принципу вложения элементов
	  файловой системы (файлов и каталогов) друг в друга строится дерево, вершинами
	  которого являются непустые каталоги, а листьями&nbsp;&mdash; файлы или пустые
	  каталоги. Корень такого дерева имеет
	  название <definition id="def-root-dir">корневой каталог</definition> и
	  обозначается каким-либо специальным символом или группой символов
	  (например, <literal>/</literal> в UNIX или <literal>C:</literal> в операционной системе
	  Windows). Каждому файлу соответствует некоторое <definition id="def-file-name"
	  orig="имя файла">имя</definition>, определяющее его расположение в дереве
	  файловой системы. Полное имя файла состоит из имен всех вершин дерева файловой
	  системы, через которые можно пройти от корня до данного файла (каталога),
	  записывая их слева направо и разделяя специальными символами-разделителями.
	</para> 
	<para>
	  <figure id="img-file-system">
	    <title>Индексная файловая система UNIX</title>
	    <graphic fileref="&BASEIMAGES;fs.png"/>
	  </figure>
	</para>
	<para>В настоящее время существует огромное количество файловых систем, каждая из
          которых используется для определенной цели: для быстрого доступа к данным, для
          обеспечения целостности данных при сбоях системы, для простоты реализации, для
          компактного хранения данных, и т.&nbsp;д. Однако среди всего множества файловых систем
          можно выделить такие, которые обладают рядом схожих признаков, а именно:
	</para>
	<para>
	  <itemizedlist>
            <listitem>
	      <presentation number="2-05" name="индексный узел"/>
	      <para>
		Файлы и каталоги имеют несколько идентификаторов: помимо имён,
		с которыми обычно работают пользователи,
		каждому файлу соответствует уникальный в рамках файловой системы
		номер. Этот номер, называемый <emphasis>индексом файла</emphasis>,
		соответствует <definition id="def-index-node" orig="индексный
		узел">индексному узлу</definition> (i-node)&nbsp;&mdash; структуре на
		диске, в которой хранится служебная информация (так
		называемые <quote>метаданные</quote>) о файле: расположение данных файла
		на диске, длина файла, владелец файла, права доступа и т.&nbsp;п.
		Таблица же связок типа <quote>имя
		файла&mdash;i-node</quote>&nbsp;&mdash; есть не что иное как содержимое
		каталогов.
	      </para>
	      <para>
		Таким образом, каждый файл характеризуется одним
		i-node, но может быть связан с несколькими именами&nbsp;&mdash; в UNIX это
		называют <definition id="def-hard-link" orig="жёсткая ссылка">жёсткими
		ссылками</definition> (см. <xref linkend="img-hard-link"/>).
		При такой схеме физическое удаление данных файла с
		носителя происходит только тогда, когда удаляется последняя
		из существующих жёстких ссылок на этот файл.
	      </para>
	      <para>
		<figure id="img-hard-link">
		  <title>Пример жесткой ссылки</title>
		  <graphic fileref="&BASEIMAGES;hard_link.png"/>
		</figure>
	      </para>
	      <para>
		Важной особенностью таких файловых систем является то, что имена файлов
		зависят от регистра, другими словами файлы <filename>test.txt</filename>
		и <filename>TEST.txt</filename> отличаются
		(т.&nbsp;е. могут находиться в одном каталоге и быть
		при этом разными файлами).
	      </para>
	    </listitem>
            <listitem>
	      <para> В определенных блоках физического носителя данных находится
		т.&nbsp;н. <definition id="def-superblock">суперблок</definition>
		(см. рисунок <xref linkend="img-file-system"/>). Местоположение суперблока
		на носителе определяется при создании файловой
		системы. Суперблок&nbsp;&mdash; это наиболее ответственная область
		файловой системы, содержащая информацию, необходимую для работы файловой
		системы в целом, а также&nbsp;&mdash; для её идентификации. В суперблоке
		находится <quote>магическое число</quote>&nbsp;&mdash; идентификатор
		файловой системы, отличающий её от других файловых систем, список
		свободных блоков, список свободных индексных узлов (i-node) и некоторая
		другая служебная информация.
              </para>
	    </listitem>
	    <question id="quest-2-5">Назовите типы файлов в UNIX. В чём все они схожи,
	    каковы отличия между ними?</question>
            <listitem>
	      <para>
		Помимо <emphasis>каталогов</emphasis> и <emphasis>обычных файлов</emphasis>
		для хранения информации ФС может содержать следующие виды файлов:
		<variablelist>
		  <varlistentry>
		    <term>Специальный <definition id="def-device-file">файл
		    устройства</definition></term>
		    <listitem>  
		      <para>
			Обеспечивает доступ к физическому устройству. При создании такого
			устройства указывается тип устройства (блочное или
			символьное), <emphasis>старший номер</emphasis>&nbsp;&mdash; индекс
			драйвера в таблице драйверов операционной системы и <emphasis>младший
			  номер</emphasis>&nbsp;&mdash; параметр, передаваемый драйверу,
			поддерживающему несколько устройств, для уточнения о каком
			<quote>подустройстве</quote> идет речь (например, о каком из
			нескольких IDE-устройств или COM-портов). Устройства
			рассматриваются в разделе <xref linkend="intro-unix-devices"/>.
		      </para>
		    </listitem> 
		  </varlistentry>
		  <varlistentry>
		    <term><definition id="def-named-pipe" orig="именованный
		    канал">Именованный канал</definition></term>
		    <listitem>  
		      <para>
			Используется для передачи данных между процессами, работает по
			принципу двунаправленной очереди
			(FIFO). Является одним из
			способов обмена данными между
			изолированными процессами (подробнее
			см. <xref linkend="intro-unixproc-interproc"/>).
		      </para>         
		    </listitem>             
		  </varlistentry>
		  <varlistentry>
		    <term><definition id="def-sym-link" orig="символьная
		    ссылка">Символьная ссылка</definition></term>
		    <question id="quest-2-6">Чем жёсткие ссылки отличаются от
		    символьных? Какими преимуществами обладают символьные
		    ссылки?</question>
		    <listitem>
		      <para>
			Особый тип файла, содержимое которого не данные, а
			имя какого-либо другого файла
			(см. <xref linkend="img-sym-link"/>). Для пользователя такой файл
			в большинстве ситуаций неотличим от того, на который он ссылается:
			операции чтения, записи и пр. над символьной
			ссылкой работают так, как если бы они
			производились непосредственно над тем файлом,
			на который указывает ссылка. Символьные ссылки
			могут указывать также и на каталог: в этом
			случае они <quote>работают</quote> как каталоги.
		      </para>
		      <para>
			Символьная ссылка имеет ряд преимуществ по сравнению с жёсткой
			ссылкой: она может использоваться для связи файлов в разных
			файловых системах (ведь номера индексных узлов уникальны только в
			рамках одной файловой системы). Кроме того,
			существование файла-ссылки совершенно
			независимо от существования того файла, на
			который он ссылается, поскольку в ссылке
			хранится только имя целевого файла, и нет никакой привязки к
			индексному узлу. Поэтому возможно удалять файл
			и ссылку независимо: причём в случае удаления
			целевого файла символьная ссылка продолжит
			существовать, но останется
			<quote>битой</quote>, т.&nbsp;е. не
			позволяющей перейти ни к какому файлу.
		      </para>
		      <para>
			<figure id="img-sym-link">
			  <title>Пример символьной ссылки</title>
			  <graphic fileref="&BASEIMAGES;symbolic_link.png"/>
			</figure>
		      </para>
		    </listitem>     
		  </varlistentry>
		  <varlistentry>
		    <term><definition id="def-fs-socket"
		    orig="сокет">Сокет</definition></term>
		    <listitem><para>
			Предназначен для взаимодействия между процессами через специальное
			API, схожее с TCP/IP-сокетеми (подробнее
			см. <xref linkend="intro-unixproc-interproc"/>).
		      </para>                
		    </listitem>
		  </varlistentry>
		</variablelist>
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>	  
	<para>
	  Устроенные подобным образом файловые системы наследуют особенности оригинальной UNIX. К ним можно
	  отнести, например: s5 (используемая в версиях UNIX System V), ufs (BSD UNIX),
	  ext2, ext3, reiserfs (Linux), qnxfs (QNX). Все эти файловые системы различаются
	  форматами внутренних структур, но совместимы с точки зрения основных концепций.
	</para>
      </sect3>
      <sect3 id ="intro-unix-files-vfs">
	<title>Виртуальная файловая система</title>
	<presentation number="2-06" name="виртуальная файловая система"/>
	<question id="quest-2-7">Что такое виртуальная файловая система? Как она связана
	с понятием монтирования?</question>
	<para>
	  Рассмотрение <emphasis>второго</emphasis> значения термина <emphasis>файловая
	  система</emphasis> приводит нас к уже обозначенной ранее совокупности процедур,
	  осуществляющих доступ к файлам на различных носителях.
	</para>
	<para>
	  Файловая подсистема операционной системы UNIX имеет
	  специальный уровень абстракции для обработки запросов к файлам&nbsp;&mdash; <emphasis>переключатель файловых
	  систем</emphasis> или <definition id="def-vfs">виртуальная файловая
	  система</definition> (VFS). VFS
	  предоставляет пользователю стандартный набор функций (интерфейс) для работы с
	  файлами, вне зависимости от места их расположения и принадлежности к разным
	  файловым системам.
	</para>
	<para>
	  <figure id="img-vfs">
	    <title>Виртуальная файловая система</title>
	    <graphic fileref="&BASEIMAGES;vfs.png"/>
	  </figure>
	</para>
	<para>
	  Пользовательская программа имеет стандартный набор системных вызовов (например,
	  <quote>открыть файл</quote>, <quote>прочитать данные</quote>,
	  <quote>удалить файл</quote>), которые операционная система транслирует
	  соответствующей фаловой системе. Таким образом, приложения становятся
	  независимыми от реализации конкретных файловых систем, тогда
	  как модуль, предоставляющий доступ к файловой системе,
	  должен быть написан согласно строго определённому внешнему 
	  интерфейсу виртуальной файловой системы.
	</para>
	<para>
          В мире стандартов UNIX определено, что корневой каталог единого дерева файловой
          системы должен иметь имя <filename>/</filename>, как и символ-разделитель при
          формировании полного имени файла. Тогда полное имя файла может быть, например, таким: 
          <filename>/usr/share/doc/bzip2/README</filename>. Задача VFS&nbsp;&mdash; по
          полному имени файла найти его местоположение в дереве файловой системы,
          определить её тип в этом месте дерева и <quote>переключить</quote>,
          т.&nbsp;е. передать файл на дальнейшую обработку драйверу конктретной файловой
          системы. Такой подход позволяет использовать практически неограниченое
          количество различных файловых систем на одном компьютере под управлением одной
          операционной системы, а пользователь даже не будет знать, что файлы физически
          находятся на разных носителях информации.
	</para>	  
      </sect3>
      <sect3 id ="intro-unix-files-processors">
	<title>Дерево каталогов</title>
	<presentation number="2-07" name="монтирование файловых систем"/>
	<para>
	  Особенностью операционных систем семейства UNIX является
	  объединение файловой системы в единое дерево
	  для любого количества носителей данных с одинаковыми или
	  разными типами файловых систем на них. Это достигается
	  путем операции <definition id="def-mount"
	  orig="монтирование">монтирования</definition>&nbsp;&mdash; временной
	  подстановкой вместо каталога одной файловой системы дерева другой файловой
	  системы. В результате вместо нескольких, изначально никак не связанных
	  друг с другом деревьев образуется большое разветвленное
	  дерево с единым корневым каталогом. 
	</para>
	<presentation number="2-08" name="стандарт на файловую систему"/>
	<question id="quest-2-8">Какие каталоги стандартизованы в UNIX? Что обычно 
	  хранится в каждом из них?</question>

	<para>Использование общепринятых имен основных файлов и структуры каталогов
          существенно облегчает работу в операционной системе, её администрирование и
          переносимость. Приведем краткое описание основных каталогов системы, формально описываемых
          специальным стандартом на <definition id="def-fs-hierarchy" orig="иерархия
          файловой системы">иерархию файловой системы</definition> (Filesystem Hierarchy
          Standard). Стандарт регулирует не только и не столько имена
          основных каталогов системы, сколько типы размещаемых в них
          данных (исполняемые программы, библиотеки, файлы
          пользователя, временные системные данные и
          т.&nbsp;д.). Главный принцип, который соблюдается довольно
          последовательно&nbsp;&mdash; группировка однотипных данных в
          одной области файловой системы (каталоге верхнего уровня и
          его подкаталогах). 
	</para>
	<para>
	  Например, все каталоги можно разделить на две группы: для статических (редко
          меняющихся)
          данных&nbsp;&mdash; <filename>/bin</filename>, <filename>/usr</filename> и
          для динамических (часто меняющихся)
          данных&nbsp;&mdash; <filename>/var</filename>, <filename>/tmp</filename>.
	  Исходя из этого администраторы могут разместить каждый из этих каталогов на
          собственном носителе, обладающем соответствующими
          характеристиками: скоростью доступа, объёмом, надёжностью и т.&nbsp;п.
	</para>

          <figure id="img-stdfs">
            <title>Стандартные каталоги в файловой системе UNIX</title>
            <graphic fileref="&BASEIMAGES;unix_filesystem.png"/>
          </figure>

	  <variablelist>
	    <varlistentry>
	      <term>Корневой каталог</term>
	      <listitem> 
                <para>
		  Корневой каталог <filename>/</filename> является основой любой ФС
		  UNIX. Все остальные каталоги и файлы располагаются в рамках струтуры
		  (дерева), порождённой корневым каталогом, независимо от их физического
		  местонахождения.
		</para>                
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename>/bin</filename></term>
	      <listitem>
		<para>
		  В этом каталоге находятся часто употребляемые команды и утилиты
		  системы общего пользования. Сюда входят все базовые команды, доступные
		  даже в том случае, если была примонтирована только корневая файловая система. Примерами
		  таких утилит являются: <command>ls</command>, <command>cp</command>,
		  <command>sh</command> и т.&nbsp;п.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename>/boot</filename></term>
	      <listitem>
		<para>
		  Каталог содержит всё необходимое для процесса загрузки операционной
		  системы: программу-загрузчик, образ ядра операционной системы и т.&nbsp;п.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename>/dev</filename></term>
	      <listitem> 
		<para>
		  Каталог содержит специальные файлы устройств, при
		  помощи которых осуществляется доступ к периферийным устройствам. Наличие такого каталога не означает,
		  что специальные файлы устройств нельзя создавать в другом месте, просто
		  достаточно удобно иметь один каталог для всех файлов такого типа.
		</para>                
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename>/etc</filename></term>
	      <listitem> 
		<para>
		  В этом каталоге находятся системные конфигурационные файлы. В качестве
		  примеров можно привести файлы <filename>/etc/fstab</filename>,
		  содержащий список монтируемых файловых систем,
		  и <filename>/etc/resolv.conf</filename>, который задаёт правила
		  составления локальных DNS-запросов. Среди наиболее
		  важных файлов&nbsp;&mdash; сценарии инициализации и останова
		  системы. В системах, наследующих особенности UNIX System V, для них
		  отведены каталоги с <filename>/etc/rc0.d</filename> по
		  <filename>/etc/rc6.d</filename> и общий для всех файл описания&nbsp;&mdash;
		  <filename>/etc/inittab</filename>.
		</para>                
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename>/home</filename> (необязательно)</term>
	      <listitem> 
		<para>
		  Каталог содержит домашние каталоги пользователей. Его наличие
		  в корневом каталоге не обязательно, а содержимое зависит от
		  особенностей конкретной UNIX-подобной операционной системы.
		</para>                
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename>/lib</filename></term>
	      <listitem> 
		<para>
		  Каталог для статических и динамических библиотек, необходимых для
		  запуска программ, находящихся в каталогах <filename>/bin</filename>
		  и <filename>/sbin</filename>. 
		</para>                
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename>/media</filename></term>
	      <listitem> 
		<para>
		  Стандартный каталог для временного монтирования файловых
		  систем (например, гибких и флэш-дисков, компакт-дисков и т.&nbsp;п.).
		</para>                
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename>/opt</filename></term>
	      <listitem> 
		<para>
		  Каталог для дополнительного программного обеспечения, устанавливаемого в
		  системе. Обычно в этот каталог устанавливаются программы, не входящие в
		  основной дистрибутив.
		</para>                
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename>/root</filename> (необязательно)</term>
	      <listitem> 
		<para>
		  Домашний каталог суперпользователя. Его наличие в корневом каталоге не обязательно.
		</para>                
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename>/sbin</filename></term>
	      <listitem>
		<para>
		  В этом каталоге находятся команды и утилиты для системного
		  администратора. Примерами таких команд
		  являются: <command>route</command>, <command>halt</command>,
		  <command>init</command> и т.&nbsp;п. Для аналогичных целей применяются
		  каталоги <filename>/usr/sbin</filename>
		  и <filename>/usr/local/sbin</filename>. 
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename>/usr</filename></term>
	      <listitem>
		<para>
		  Этот каталог повторяет структуру корневого каталога&nbsp;&mdash;
		  содержит
		  каталоги <filename>/usr/bin</filename>, <filename>/usr/lib</filename>,
		  <filename>/usr/sbin</filename>, служащие для аналогичных целей.
		</para>
		<para>
		  Каталог <filename>/usr/include</filename> содержит заголовочные файлы
		  языка C для всевозможных библиотек, расположенных в системе.
		</para>
		<para>
		  Каталог <filename>/usr/local</filename> &mdash; ещё
		  один уровень, в котором можно полностью
		  воспроизвести структуру данных, содержащуюся в
		  корневом каталоге. Обычно этот каталог служит для размещения программ,
		  установленных администратором в дополнение к стандартной поставке
		  операционной системы.
		</para>
		<para>
		  Каталог <filename>/usr/share</filename> хранит неизменяющиеся данные для
		  установленных программ. Особый интерес представляет
		  каталог <filename>/usr/share/doc</filename>, в который добавляется
		  документация ко всем установленным программам.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename>/var</filename>, <filename>/tmp</filename></term>
	      <listitem> 
		<para>Используются для хранения временных данных
	      системных (<filename>/var</filename>) и пользовательских
	      (<filename>/tmp</filename>) процессов. Каталог <filename>/var</filename> обычно содержит
		  часто изменяемые системные файлы, например в
		  каталоге <filename>/var/log</filename> размещаются системные журналы.
		</para>                
	      </listitem>
	    </varlistentry>
	  </variablelist>	    
      </sect3>            
    </sect2>      
    <sect2 id="intro-unix-devices">
      <title>Устройства и драйверы</title>
      <presentation number="2-09" name="устройства в UNIX"/>
      <para>
	Как говорилось в прошлой лекции, процессор взаимодействует с внешними устройствами
	через <emphasis>шины</emphasis>. Любое устройство, подключенное к системной шине
	(или к шине PCI, или USB), обладает
	определённым интерфейсом (заранее известными
	<emphasis>идентификаторами</emphasis>, номерами портов ввода и вывода и т.&nbsp;п.),
	через который производится обмен данными и сообщениями с устройством. Таким
	образом, в первую очередь операционная система должна иметь модули, осуществляющие
	управление шинами, прерываниями, DMA и т.&nbsp;п. Эти модули обычно
	загружаются при старте системы.
      </para>
      <question id="quest-2-9">Как можно классифицировать различные внешние устройства?
	Какие объекты соответствуют им в UNIX?</question>
      <para>
	Сами внешние устройства по типу доступа к ним могут быть
	классифицированы несолькими способами:

	<itemizedlist>
	  <listitem><emphasis>символьные</emphasis>&nbsp;&mdash; чтение и запись данных
	  производится побайтно (например, COM-порт);</listitem>
	  <listitem><emphasis>блочные</emphasis>&nbsp;&mdash; чтение и запись данных
	  производится блоками (например, секторами в жёстком диске);</listitem>
	</itemizedlist>	  

	<itemizedlist>
	  <listitem><emphasis>последовательного доступа</emphasis>&nbsp;&mdash; читать и
	  записывать данные можно только последовательно (например, коммуникационные
	  каналы);</listitem>
	  <listitem><emphasis>произвольного доступа</emphasis>&nbsp;&mdash; возможно
	  обращение к данным по индексу (диски);</listitem>
	</itemizedlist>	  

	<itemizedlist>  
	  <listitem><emphasis>синхронные</emphasis>&nbsp;&mdash; передают данные только по
	  команде (например, принтер);</listitem>
	  <listitem><emphasis>асинхронные</emphasis>&nbsp;&mdash; могут передавать данные
	  без предварительного указания (например, сетевая карта).</listitem>
	</itemizedlist>
      </para>
      <para>
	Для работы с каждым из обозначенных видов устройств нужна сответствующая
	подпрограмма в ядре&nbsp;&mdash; только она знает, каким образом пользовательские
	данные конвертируются в сигналы шины и наоборот. Такая подпрограмма ядра
	(оформляемая обычно в виде модуля) называется <definition id="def-driver"
	orig="драйвер">драйвером</definition>. В UNIX можно выделить несколько групп
	устройств (и соответствующих драйверов), основные из них: <emphasis>блочные
	устройства</emphasis> (блочные, произвольного доступа), <emphasis>символьные
	устройства</emphasis> (символьные, последовательного доступа), <emphasis>сетевые
	устройства</emphasis> (блочные, последовательного доступа,
	асинхронные). Интересная особенность блочных утройств состоит в том, что при
	обращении к ним может использоваться <emphasis>буфер</emphasis>, в котором
	кэшируются данные последних запросов. Сетевые устройства представлены в системе в
	виде <emphasis>сетевых интерфейсов</emphasis>, которые будут рассмотрены в разделе
	<xref linkend="network-lect-iface"/>.
      </para>
      <para>
	В операционной системе UNIX большинство внешних устройств доступно
	пользовательским программам в виде специальных файлов. Эти файлы могут быть,
	соответственно, двух типов&nbsp;&mdash; символьными и блочными. Традиционно, все
	файлы устройств располагаются в каталоге <filename>/dev</filename> и имеют
	имена, соответствующие назначению устройства. Например, в операционной системе
	Linux устройства терминала обозначаются как <filename>/dev/tty0</filename>, 
	<filename>/dev/tty2</filename> и т.&nbsp;д. с увеличением порядкового номера,
	жёсткий диск&nbsp;&mdash; <filename>/dev/sda</filename>, а порт
	PS/2&nbsp;&mdash; <filename>/dev/psaux</filename>. Названия однотипных устройств
	обычно отличаются целым числом. Программы могут открывать, читать и записывать данные в
	файлы устройств как в обычные файлы, при этом операционная система транслирует
	пользовательские запросы драйверу соответствующего устройства.
      </para>
      <para>
	<figure id="img-device">
	  <title>Взаимодействие с устройством через файл</title>
	  <graphic fileref="&BASEIMAGES;device.png"/>
	</figure>
      </para>
      <para>
	Таким образом, файл устройства является одним из интерфейсов взаимодействия
	процессов с устройствами. Каждый файл устройства имеет два номера&nbsp;&mdash;
	старший и младший. По этим номерам операционная система определяет, какой драйвер
	должен использоваться при обращении к этому файлу.
      </para>
      <para>
	В операционной системе UNIX большая часть драйверов устройств выполнена в виде
	модулей ядра. Однако, некоторые драйверы частично выполняются в пользовательском
	режиме (например, видеокарты в рамках графической подсистемы X Windows). 
      </para>
      <question id="quest-2-10">Какие существуют виртуальные устройства в UNIX? Чем они
      отличаются от обычных устройств?</question>
      <para>
	Помимо файлов, соответствующих внешним устройствам, в UNIX есть несколько
	стандартных файлов виртуальных устройств. Эти файлы могут передавать и принимать от
	пользовательских процессов специальные данные, например, из символьного
	устройства <filename>/dev/zero</filename> можно прочитать только нули, сколько бы
	процесс не читал данные из этого файла. Вот список наиболее распространённых
	виртуальных устройств:
      </para>
      <para>
	<variablelist>
	  <varlistentry>
	    <term><filename>/dev/console</filename></term> 
	    <listitem>
	      <para>
		устройство соответствует активной в данный момент
		терминальной линии (виртуальной консоли);
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><filename>/dev/null</filename></term> 
	    <listitem> 
	      <para>
		<quote>чёрная дыра</quote>&nbsp;&mdash; любая информация, записанная в этот
		файл, пропадает безвозвратно, обычно используется для поглощения ненужного
		вывода программ;
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><filename>/dev/random</filename> и <filename>/dev/urandom</filename></term> 
	    <listitem> 
	      <para>
		устройства, генерирующие соответственно случайные и псевдослучайные данные;
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><filename>/dev/stdin</filename>, <filename>/dev/stdout</filename>
	    и <filename>/dev/stderr</filename></term>
	    <listitem> 
	      <para>
		устройства, соответствующие трём стандартным потокам ввода-вывода для
		каждого из процессов системы;
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><filename>/dev/zero</filename></term> 
	    <listitem> 
	      <para>
		устройство генерирует нули&nbsp;&mdash; из этого устройства можно
		прочитать сколько угодно нулевых байт.
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>	    		
      </para>
    </sect2>      
    <sect2 id="intro-unix-summary">
      <title>Резюме</title>
      <presentation number="2-10" name="резюме"/>
      <para>
	Во второй лекции была рассмотрена архитектура операционной системы UNIX.
      </para>
      <para>
	Основными принципами операционной системы UNIX являются многозадачность и
	стандартизация. Пользователю приходится работать с двумя основными объектами
	операционной системы: файлами и процессами.
      </para>
      <para>
	Операционную систему UNIX можно представить в виде трёх уровней: монолитное ядро,
	системные утилиты и демоны, пользовательские программы. Первые два работают на
	уровне привилегий системы, третий&nbsp;&mdash; на уровне пользователя.
      </para>
      <para>
	Все файловые системы семейства UNIX обладают схожей структурой. Основным элементом
	файловой системы является индексный узел, каталог связывает файл с именем. Помимо
	файлов и каталогов существуют специальные виды файлов: устройства, каналы,
	символьные ссылки и сокеты. 
      </para>
      <para>
	Для объединения файловых систем нескольких устройств используются виртуальная
	файловая система и механизм монтирования. Стандарт на файловую систему описывает
	основные каталоги иерархической файловой системы UNIX.
      </para>
      <para>
	Работа с внешними устройствами в UNIX производится через специальные модули
	ядра&nbsp;&mdash; драйверы устройств. Пользовательские
	программы обращаются к большинству устройств через специальные
	файлы, расположенные в файловой ситсеме. 
      </para>
      <list-of-definitions/>
    </sect2>    
    <sect2 id="intro-unix-additional">
      <title>Дополнительные материалы</title>
      <para>
	<orderedlist>
	  <listitem>
	    Бах Дж. М. <emphasis>Архитектура операционной системы
	      UNIX</emphasis>.&nbsp;&mdash; <ulink
					       url="http://www.opennet.ru/docs/RUS/unix/">
	      http://www.opennet.ru/docs/RUS/unix/</ulink>
	  </listitem>
	  <listitem>
	    Курячий Г. В. <emphasis>Операционная система UNIX</emphasis>.&nbsp;&mdash;
	    М.: Интуит.Ру, 2004.&nbsp;&mdash; 292 с.: ил.
	  </listitem>
	  <listitem>
	    Робачевский А. М. <emphasis>Операционная система UNIX</emphasis>.&nbsp;&mdash;
	    СПб.: БХВ-Петербург, 2002.&nbsp;&mdash; 528 с.: ил.
	  </listitem>
	  <listitem>
	    <emphasis>Стандарт на файловую систему</emphasis>.&nbsp;&mdash;
	    <ulink url="http://www.pathname.com/fhs/">http://www.pathname.com/fhs/</ulink>
	  </listitem>
	  <listitem>
	    Максвелл С. <emphasis>Ядро Linux в комментариях</emphasis>.&nbsp;&mdash;
	    К.: Издательство <quote>Диа-Софт</quote>, 2000.&nbsp;&mdash; 488 с.: ил.
	  </listitem>
	</orderedlist>
      </para>
    </sect2>    
    <list-of-questions id="intro-unix-question"/>
    <small-presentation id="intro-unix-presentaion"/>
  </sect1>
  <sect1 id="intro-unixproc">
    <title>Архитектура UNIX. Процессы</title>
    <presentation number="3-01" name="ядро UNIX"/>
    <para>
      В прошлой лекции была рассмотрена архитектура операционной системы UNIX и её
      ядра. Было сказано о том, что эта операционная система базируется на
      двух <quote>китах</quote>: файлах и процессах. В этой лекции речь пойдет о
      процессах: что это такое и как они взаимодействуют в рамках UNIX-системы.
    </para>
    <para>
      С процессами связано несколько важных компонент ядра UNIX: управление
      памятью, планировщик процессов, обеспечение межпроцессного взаимодействия.
    </para>

    <sect2 id="intro-unixproc-virtmem">
      <title>Управление памятью</title>
      <presentation number="3-02" name="управление памятью"/>
      <para>
	Как уже было сказано выше, в  UNIX реализована <emphasis>виртуальная
	память</emphasis> процессов. Каждый процесс исполняется в собственном адресном
	пространстве и не может непосредственно обращаться к памяти других
	процессов. Такая изоляция процессов друг от друга обеспечивается механизмами операционной системы и
	поддерживается на аппаратном уровне в современных процессорах.
      </para>
      <para>
	Разделение виртуальной памяти отдельных процессов необходимо в целях
	безопасности&nbsp;&mdash; процессы не должны иметь возможность по собственной
	инициативе менять данные других процессов&nbsp;&mdash; не только из-за
	потенциальных возможностей злоумышленников, но и потому, что программы могут
	совершать ошибки, и аварийное завершение одного процесса не должно отражаться на
	ходе работы других процессов и операционной системы в целом.
      </para>
      <para>
	В современных реализациях UNIX для большинства аппаратных архитектур
	используется <emphasis>страничная организация</emphasis> виртуальной памяти. В
	этом случае всё адресное пространство процесса разбивается на участки одинакового
	размера (<definition id="def-page" orig="страница">страницы</definition>),
	аналогичным образом разбивается вся физическая
	память. Типичный размер страницы на 32-разрядной
	архитектуре равен 4&nbsp;килобайтам, а общий объём
	адресного пространства процесса&nbsp;&mdash; 4&nbsp;гигабайтам. Каждая станица адресного
	пространства процесса может отображаться на какую-то страницу физической
	памяти. Это обеспечивается специальной таблицей <emphasis>преобразования
	адресов</emphasis>, которую операционная система поддерживает в адекватном
	состоянии. Таким образом, физическая память разделяется между множеством
	процессов, причём каждый из процессов имеет доступ только к <quote>своим</quote>
	страницам, что гарантируется операционной системой и аппаратными
	возможностями процессора.
      </para>
      <para>
	Так как число процессов в системе потенциально не ограничено,
	очевидно, что суммарный размер адресного пространства, необходимого всем
	процессам, вполне может превысить размеры физической памяти. Конечно, большая
	часть программ оперирует довольно небольшим объёмом памяти. Однако страничное
	преобразование позволяет решить проблему недостатка физической памяти:
	неиспользуемые страницы могут копироваться из физической памяти на диск в
	специальную <definition id="def-swap-space">область подкачки</definition> и
	храниться там до момента, когда они вновь потребуются для исполнения процесса.
      </para>
      <para>
	Ещё один мощный механизм, возможный благодаря страничному
	преобразованию,&nbsp;&mdash; это <definition id="def-mmap">файлы, проецируемые в
	память</definition>. Процесс может <quote>присоединить</quote> файл к своему
	виртуальному адресному пространству. Это означает, что при
	обращении к файлу или изменении данных в нем операционная система будет
	автоматически выполнять отображение содержимого файла в
	страницы памяти процесса и
	обратно. Фактически операционная система здесь использует тот
	же механизм, что и при работе с областью подкачки, когда
	данные перемещаются с внешнего носителя в память при обращении
	к соответствующему адресу виртуальной памяти. Отображаемые в
	память файлы используются в тех случаях, когда необходимо с
	минимальными временными затратами многократно модифицировать содержимое файла,
	например, в базах данных или редакторах.
      </para>
      <para>
	На рисунке <xref linkend="img-virtual-memory"/> показаны
	возможные случаи размещения
	страниц виртуальной памяти&nbsp;&mdash; в физической памяти, в области подкачки,
	в файле.
      </para>
      <para>
	<figure id="img-virtual-memory">
	  <title>Размещение страниц виртуальной памяти</title>
	  <graphic fileref="&BASEIMAGES;pages_placement.png"/>
	</figure>
      </para>
    </sect2>

    <sect2 id="intro-unixproc-proc">
      <title>Управление процессами</title>
      <presentation number="3-03" name="контекст процесса"/>
      <para>
	В операционной системе UNIX традиционно поддерживается классическая схема
	мультипрограммирования. Система предоставляет возможность параллельного (или
	псевдопараллельного в случае наличия только одного аппаратного процессора)
	выполнения нескольких пользовательских программ. Каждому такому выполнению
	соответствует <emphasis>процесс</emphasis> операционной системы.
      </para>
      <sect3 id="intro-unixproc-proc-context">
	<title>Контекст процесса</title>
	<question id="quest-3-1">Что такое контекст процесса? Из чего состоит контекст
	  процесса в UNIX?</question>
	<para>
	  Каждому процессу соответствует <definition id="def-process-context"
	  orig="контекст процесса">контекст</definition>, в котором он выполняется. Этот
	  контекст включает пользовательский контекст (т.&nbsp;е. содержимое
	  виртуального адресного пространства, сегментов программного кода, данных, стека,
	  разделяемых сегментов и сегментов файлов, отображаемых в виртуальную память),
	  содержимое аппаратных регистров&nbsp;&mdash; регистровый контекст (регистр
	  счетчика команд, регистр состояния процессора, регистр указателя стека и
	  регистры общего назначения), а также структуры данных ядра (контекст системного
	  уровня), связанные с этим процессом. Контекст процесса системного уровня в ОС
	  UNIX состоит из <emphasis>статической</emphasis> и <emphasis>динамических</emphasis>
	  частей. Для каждого процесса имеется одна статическая часть контекста системного
	  уровня и переменное число динамических частей.
	</para>
	<para>
	  Статическая часть контекста процесса системного уровня включает следующее:
	</para>
	<para>
	  <variablelist>
	    <varlistentry>
	      <term><definition id="def-pid" orig="идентификатор процесса">Идентификатор
		  процесса (PID)</definition></term>
	      <listitem>
		<para>
		  Уникальный номер, идентифицирующий процесс. По сути, это номер строки в
		  таблице процессов&nbsp;&mdash; специальной внутренней структуре ядра
		  операционной системы, хранящей информацию о процессах.
		</para>
		<para>
		  В любой момент времени ни у каких двух процессов
		  номера не могут совпадать,
		  однако после завершения процесса его номер
		  освобождается и может быть в дальнейшем
		  использован для идентификации любого вновь запущенного процесса.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><definition id="def-parent-process" orig="родительский
	      процесс">Идентификатор родительского процесса
	      (PPID)</definition></term>
	      <listitem>
		<para>
		  В операционнной системе UNIX процессы выстраиваются
		  в <emphasis>иерархию</emphasis>&nbsp;&mdash; новый процесс может быть
		  создан только одним из уже существующих процессов,
		  который выступает для него родительским.
		</para>
		<para>
		  Очевидно, что в такой схеме должен присутствовать один процесс
		  с особым статусом: он должен быть порожден ядром
		  операционной системы и будет являться родительским
		  для всех остальных процессов в системе. В UNIX такой
		  процесс имеет собственное имя&nbsp;&mdash;
		  <definition
		  id="def-init-process">init</definition>. Подробнее об этом процессе сказано в разделе
		  <xref linkend="base-admin-lect-sysinit-init"/>. 
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><definition id="def-process-state" orig="состояние процесса">Состояние
		  процесса</definition></term>
	      <listitem>
		<para>
		  Каждый процесс в любой момент времени находится в
		  одном из нескольких определенных состояний:
		  инициализация, исполнение, приостановка, ожидание ввода-вывода, завершение
		  и т.&nbsp;п. (см. <xref linkend="img-process-states"/>).
		</para>
		<para>
		  <figure id="img-process-states">
		    <title>Состояния процесса в UNIX</title>
		    <graphic fileref="&BASEIMAGES;process_states.png"/>
		  </figure>
		</para>
		<para>
		  Большинство этих состояний совпадает с классическим набором состояний
		  процессов в многозадачных операционных системах. Для операционной
		  системы UNIX характерно особое состояние процесса&nbsp;&mdash;
		  <definition id="def-zombie">зомби</definition>. Процесс получает
		  это состояние, если он завершился раньше, чем этого
		  ожидал его родительский процесс. В UNIX перевод
		  процессов в состояние зомби служит для корректного
		  завершения группы процессов, 
		  освобождения ресурсов и т.&nbsp;п.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Идентификаторы пользователя</term>
	      <listitem>
		<para>
		  Идентификатор пользователя и группы, от имени которых исполняется
		  процесс, используются операционной системой для
		  определения границ доступа для процесса. Подробнее о
		  правах доступа будет сказано в лекции
		  <xref linkend="security-lect"/>.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><definition id="def-process-prio" orig="приоритет процесса">Приоритет
		  процесса</definition></term>
	      <listitem>
		<para>
		  Число, используемое при <emphasis>планировании</emphasis>
		  (см. <xref linkend="intro-unixproc-proc-schedule"/>) исполнения процесса в
		  операционной системе. Традиционное решение операционной системы UNIX
		  состоит в использовании динамически изменяющихся
		  приоритетов. При образовании каждого процесса ему приписывается
		  некоторый устанавливаемый
		  системой статический приоритет, который в дальнейшем может быть изменен
		  с помощью системного вызова
		  <command>nice</command>. Реальным критерием
		  планирования выступает динамический приоритет, статический
		  приоритет составляет основу начального значения динамического приоритета
		  процесса. Все процессы с
		  динамическим приоритетом не ниже порогового участвуют в конкуренции за
		  процессор.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Таблица дескрипторов открытых файлов</term>
	      <listitem>
		<para>
		  Список структур ядра, описывающий все файлы, открытые этим процессом для
		  ввода-вывода.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Другая информация, связанная с процессом</term>
	      <listitem><para></para></listitem>
	    </varlistentry>
	  </variablelist>
	</para>
	<para>
	  Динамическая часть контекста процесса&nbsp;&mdash; это один или несколько
	  стеков, которые используются процессом при выполнении в режиме пользователя и в
	  режиме ядра (в процессе прерываний и системных вызовов).
	</para>
      </sect3>
      <sect3 id="intro-unixproc-proc-schedule">
	<title>Планирование процессов</title>
	<presentation number="3-04" name="планирование процессов"/>
	<question id="quest-3-2">Что такое планирование и диспетчеризация процессов?
	Какие алгоритмы планирования применяются в UNIX?</question>
	<para>
	  Основной проблемой организации многопользовательского (правильнее сказать,
	  мультипрограммного) режима в любой операционной системе является организация
	  <definition id="def-scheduling"
	  orig="планирование">планирования</definition> <quote>параллельного</quote>
	  выполнения нескольких процессов. Операционная система должна обладать четкими
	  критериями для определения того, какому готовому к выполнению процессу и когда
	  предоставить ресурс процессора.
	</para>
	<para>
	  Наиболее распространённым алгоритмом планирования в системах разделения времени
	  является <definition id="def-round-robin" orig="Round Robin">кольцевой
	  режим</definition> (Round Robin). Основной смысл алгоритма состоит в том, что
	  время процессора делится на кванты фиксированного размера, а процессы, готовые к
	  выполнению, выстраиваются в кольцевую очередь
	  (см. <xref linkend="img-round-robin"/>). У этой очереди имеются два
	  указателя&nbsp;&mdash; начала и конца. Когда процесс, выполняющийся на
	  процессоре, исчерпывает свой квант процессорного времени, он снимается с
	  процессора, ставится в конец очереди, а ресурсы процессора отдаются процессу,
	  находящемуся в начале очереди. Если выполняющийся на процессоре процесс
	  откладывается (например, по причине обмена с некоторым внешним устройством) до
	  того, как он исчерпает свой квант, то после повторной активизации он становится
	  в конец очереди (не смог доработать&nbsp;&mdash; не вина системы). Это прекрасная схема
	  разделения времени в случае, когда все процессы одновременно помещаются в
	  оперативной памяти.
	</para>
	<para>
	  <figure id="img-round-robin">
	    <title>Схема планирования с кольцевой очередью</title>
	    <graphic fileref="&BASEIMAGES;scheduling.png"/>
	  </figure>
	</para>
	<para>
	  Однако операционная система UNIX всегда была рассчитана на то, чтобы обслуживать
	  больше процессов, чем можно одновременно разместить в основной памяти. Другими
	  словами, часть процессов, потенциально готовых выполняться, размещалась во
	  внешней памяти (куда образ памяти процесса попадал в результате
	  откачки). Для оптимизации работы в этом случае требуется
	  несколько более гибкая схема планирования при
	  разделении ресурсов процессора. В результате было введено понятие <emphasis>приоритета</emphasis>
	  (см. <xref linkend="img-round-robin-prio"/>). В операционной
	  системе UNIX на основании значения
	  приоритета процесса определяется, во-первых, возможность процесса пребывать в основной
	  памяти и на равных конкурировать за процессор. Во-вторых, от значения приоритета
	  процесса зависит размер временного кванта, который
	  предоставляется процессу для работы на процессоре при достижении своей
	  очереди. В-третьих, значение приоритета влияет на место процесса в общей
	  очереди процессов.
	</para>
	<para>
	  <figure id="img-round-robin-prio">
	    <title>Схема планирования с кольцевой очередью и приоритетами</title>
	    <graphic fileref="&BASEIMAGES;scheduling_prio.png"/>
	  </figure>
	</para>
      </sect3>
      <sect3 id="intro-unixproc-proc-fork">
	<title>Создание новых процессов</title>
	<presentation number="3-05" name="создание новых процессов"/>
	<question id="quest-3-3">Каков механизм создания новых процессов в UNIX?</question>
	<para> 
	  Механизм порождения новых процессов довольно существенно
	различается в разных операционных системах. Во всех операционных
	системах семейства UNIX новые процессы в системе не появляются
	<quote>из ниоткуда</quote>, а ответвляются от уже существующих в системе процессов.
	</para>
	<para>
	  Когда возникает необходимость создания нового процесса (C), текущий процесс (P)
	  выполняет системный вызов <command>fork()</command>
	  (см. рисунок <xref linkend="img-fork"/>). При этом создаётся новый процесс,
	  представляющий собой копию исходного процесса и его
	  контекста. Новый процесс отличается тем, что у него другой
	  PID, а родителем для него является запустивший процесс (P). Далее
	  дочерний процесс (C) с помощью системного вызова <command>exec</command>
	  запускает вместо себя другую программу, заново проинициализировав свои код и данные.
	</para>
	<para>
	  <figure id="img-fork">
	    <title>Создание нового процесса</title>
	    <graphic fileref="&BASEIMAGES;fork.png"/>
	  </figure>
	</para>
	<para> 
	  Существует также и обратная связь между дочерним процессом и
	  родительским. Родительский процесс (P)
	  может синхронизовать своё исполнение с завершением процесса
	  (C) (ожидать завершения дочернего процесса) с помощью
	  специального системного вызова <command>wait()</command>.
	</para>
      </sect3>
      <sect3 id="intro-unixproc-proc-threads">
	<title>Процессы и потоки</title>
	<para>
	  В современных версиях операционной системы UNIX помимо процессов существует
	  понятие <definition id="def-thread" orig="поток">потока</definition> (или
	  <emphasis>нити</emphasis>) исполнения. В рамках процесса может существовать
	  несколько потоков, каждый из которых исполняется независимо, но все они
	  объединены общим виртуальным адресным пространством. Можно сказать, что все
	  процессы исполняются с единственным потоком по умолчанию, но при необходимости
	  могут быть созданы новые потоки. 
	</para>
	<para>
	  Потоки отсутствовали в оригинальной архитектуре UNIX и были добавлены под
	  влиянием современных архитектур персональных компьютеров, в которых переключение
	  контекста исполнения между процессами занимает значительно большее время, чем
	  переключение контекста исполнения между потоками. Однако
	  ценой эффективного переключения между потоками
	  является сильное влияние потоков в рамках одного процесса друг на
	  друга (критическая ошибка в одном потоке приводит к завершению всего процесса),
	  поэтому в UNIX-системах потоки традиционно используются редко.
	</para>
      </sect3>
    </sect2>

    <sect2 id="intro-unixproc-interproc">
      <title>Межпроцессное взаимодействие</title>
      <presentation number="3-06" name="межпроцессное взаимодействие"/>
      <question id="quest-3-4">Какие средства межпроцессного обмена предоставляются в
	UNIX?</question>
      <para>
	Полная изоляция процессов в операционной системе бессмысленна, так как им часто
	необходимо обмениваться данными в процессе работы. Поэтому
	одна из важнейших задач операционной системы&nbsp;&mdash;
	обеспечивать контролируемые взаимодействия процессов, в том числе за счет
	возможности разделения одного сегмента памяти между виртуальной памятью нескольких
	процессов. Для решения задачи <definition id="def-interprocess-communication"
	orig="межпроцессное взаимодействие">межпроцессного взаимодействия</definition> в
	операционной системе UNIX существует набор специальных средств: потоки ввода-вывода,
	переменные окружения, каналы и сокеты, разделяемая память и сигналы. Рассмотрим
	подробнее все эти механизмы межпроцессного взаимодействия.
      </para>

      <sect3 id="intro-unixproc-interproc-shmem">
	<title>Разделяемая память</title>
	<presentation number="3-07" name="разделяемая память"/>
	<para>
	  Самый простой способ <quote>обойти</quote> разделение виртуальных пространств
 	  процессов&nbsp;&mdash; использование <definition id="def-shared-memory"
 	  orig="разделяемая память">разделяемой памяти</definition>. Это специальный
 	  механизм, с помощью которого средствами операционной системы два процесса могут
 	  обращаться к общему участку физической памяти&nbsp;&mdash; каждый через свое
 	  адресное пространство.
	</para>

	<para>
	  <figure id="img-shared-memory">
	    <title>Разделяемая память</title>
	    <graphic fileref="&BASEIMAGES;shmem.png"/>
	  </figure>
	</para>

	<para>
	  Для операционной системы этот способ является наиболее простым&nbsp;&mdash; ведь
	  все страницы виртуальной памяти процессов в любом случае проецируются на какую-то
	  область физической памяти&nbsp;&mdash; так почему бы на ту же область не
	  проецировать часть адресного пространства другого процесса? Самое важное, что
	  такое взаимодействие не требует каких-либо накладных расходов, процессы
	  обмениваются информацией со скоростью обращения к памяти.
	</para>

	<para>
	  Однако для пользователя такой способ межпроцессного взаимодействия является
	  труднодоступным. Во-первых, программы, взаимодействующие таким образом, должны
	  изначально содержать соответствующий код&nbsp;&mdash; с помощью специальных
	  <emphasis>системных вызовов</emphasis> обе программы должны обозначить участки
	  своих адресных пространств, предназначенные для обмена информацией. Другая сложность состоит в
	  том, что разделяемая память сама по себе не содержит средств
	  <emphasis>синхронизации</emphasis>, программы должны согласованно изменять общий
	  участок памяти, чтобы не испортить данные; обычно для этих целей применяются
	  <emphasis>семафоры</emphasis> и аналогичные механизмы синхронизации.
	</para>

	<para>
	  Таким образом, разделяемая память&nbsp;&mdash; наиболее быстрый способ обмена,
	  но при этом малопригодный для широкого использования. Обычная сфера применения
	  разделяемой памяти&nbsp;&mdash; специализированные высокопроизводительные
	  программы. Стоит также обратить внимание на явную аналогию разделяемой памяти и
	  исполнения множества потоков в рамках одного процесса&nbsp;&mdash; в UNIX эти
	  инструменты построения программ используются редко и только в связи с
	  высокопроизводительными вычислениями и вводом-выводом.
	</para>

      </sect3>	

      <sect3 id="intro-unixproc-interproc-env">
	<title>Переменные окружения</title>
	<presentation number="3-08" name="переменные окружения"/>
	<para>
	  Каждый запускаемый процесс система снабжает неким <definition id="def-env"
  	  orig="окружение">информационным пространством</definition>, которое этот процесс
  	  может изменять. Правила пользования этим пространством просты: в нем можно
  	  задавать именованные хранилища данных (<definition id="def-env-var"
  	  orig="переменная окружения">переменные окружения</definition>), в которые можно
  	  записывать любую текстовую информацию (присваивать значение переменной окружения),
  	  а впоследствии эту информацию считывать (подставлять значение переменной).
	</para>

	<para>
	  В UNIX дочерний процесс создаётся как точная копия родительского, поэтому его
	  окружение&nbsp;&mdash; точная копия родительского. Если про дочерний
	  процесс известно, что он использует значения некоторых переменных из числа
	  передаваемых ему с окружением, то родительский процесс может заранее указать, каким из
	  копируемых в окружении переменных нужно изменить значение (см. рисунок
	  <xref linkend="img-environment"/>). Одна и та же программа при одинаковом
	  использовании, но в измененном окружении, может выдавать различные
	  результаты. Например, от переменной окружения может зависеть язык интерфейса
	  программы или формат используемых данных.
	</para>

	<para>
	  <figure id="img-environment">
	    <title>Наследование переменных окружения</title>
	    <graphic fileref="&BASEIMAGES;env.png"/>
	  </figure>
	</para>

	<para>
	  Конечно, переменные окружения&nbsp;&mdash; очень ограниченное средство
	  межпроцессного взаимодействия. Во-первых, действие их односторонне, так как
	  дочерний процесс не может изменить окружение родительского
	  процесса. Более того, родительский процесс никак не может
	  воспользоваться информацией из окружения дочернего. Во-вторых,
	  окружение уже запущенного процесса изменить извне нельзя. В-третьих, через
	  переменные окружения можно передавать только текстовые данные, обычно небольшого
	  объёма. Поэтому переменные окружения используются в основном для задания условий
	  запуска программы: положение конфигурационных файлов, требуемые параметры
	  интефейса и аналогичные простые параметры.
	</para>
      </sect3>

      <sect3 id="intro-unixproc-interproc-signals">
	<title>Сигналы</title>
	<presentation number="3-09" name="сигналы"/>
	<question id="quest-3-5">Какие основные сигналы существуют в операционной системе?
	Когда они применяются?</question>
	<para>
	  <definition id="def-signal" orig="сигнал">Сигналы</definition>&nbsp;&mdash; одно
	  из традиционных средств межпроцессного взаимодействия в UNIX. Сигнал может быть
	  отправлен процессу операционной системой или другим
	  процессом. Операционная система использует сигналы для
	  доставки процессу уведомлений об ошибках и неправильном
	  поведении. 
	</para>
	<para>
	  При получении сигнала исполнение процесса приостанавливается и
	  запускается специальная подпрограмма&nbsp;&mdash; <emphasis>обработчик
	  сигнала</emphasis>. Обработчики сигналов могут быть явно
	  определены в исходном тексте исполняемой программы, если же
	  они отсутствуют, а также в некоторых специальных случаях
	  используется стандартный обработчик, определённый
	  операционной системой. 
	</para>
	<para>
	  У сигнала есть только одна характеристика, несущая
	  информацию&nbsp;&mdash; его номер (целое число). Иначе
	  говоря, сигналы&nbsp;&mdash; это заранее определённый и
	  пронумерованный список сообщений. Для удобства использования
	  каждый сигнал имеет сокращённое буквенное имя. Список
	  сигналов и их имён стандартизован и практически не
	  отличается в различных версиях UNIX. Для
	  отправки сигналов процессам используется специальный системный вызов
	  <command>kill()</command> и одноимённая ему пользовательская
	  утилита. К основным сигналам относятся:

 	  <variablelist>
	    <varlistentry>
	      <term>SIGALRM (14)</term>
	      <listitem><para>Процесс может с
	      помощью специального системного вызова <command>abort()</command> задать
	      время, через которое ему необходимо отправить
	      сигнал. Через указанный промежуток времени операционная
	      система доставит процессу сигнал <command>SIGALARM</command>. Обычно этот
	      прием применяется для задания таймаутов. Если процесс не
	      зарегистрировал обработчик этого сигнала, то обработчик
	      по умолчанию завершает процесс.</para></listitem> 
	    </varlistentry>
	    <varlistentry>
	      <term>SIGCHLD</term>
	      <listitem><para>Сигнал отправляется родительскому процессу в случае завершения его
	      дочернего процесса. По умолчанию сигнал игнорируется.</para></listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>SIGCONT</term>
	      <listitem><para>Сигнал продолжения исполнения программы после
	      остановки. Обработчика по умолчанию нет.</para></listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>SIGFPE (8)</term>
	      <listitem><para>Сигнал ошибки в вычислениях с плавающей точкой, отправляется
	      операционной системой при некорректном исполнении программы. Обработчик по
	      умолчанию завершает процесс.</para></listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>SIGHUP (1)</term>
	      <listitem><para>Сигнал закрытия терминала, к которому привязан данный
	      процесс. Обычно отправляется операционной системой всем процессам, запущенным из
	      командной строки при завершении сеанса пользователя. Обработчик по
	      умолчанию завершает процесс.</para></listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>SIGILL (4)</term>
	      <listitem><para>Сигнал некорректной инструкции. Отправляется операционной
	      системой процессу в случае, если в исполнении программы встретилась
	      некорректная инструкция процессора. Обработчик по
	      умолчанию завершает процесс.</para></listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>SIGKILL (9)</term>
	      <listitem><para>Сигнал аварийного завершения процесса. По этому сигналу
	      процесс завершается немедленно&nbsp;&mdash; без освобождения ресурсов. Этот
	      сигнал не может быть перехвачен, заблокирован или
	      переопределён самим процессом, всегда используется
	      стандартный обработчик опрационной системы. Этот сигнал
	      используется для гарантированного завершения процесса.</para></listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>SIGPIPE (13)</term>
	      <listitem><para>Сигнал отправляется процессу, который пытается отправить
	      данные в канал, закрытый с противоположной стороны. Такая ситуация может
	      возникнуть в случае, если один из взаимодействующих процессов был аварийно
	      завершён. Обработчик по умолчанию завершает процесс.</para></listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>SIGSEGV (11)</term>
	      <listitem><para>Сигнал отправляется процессу операционной системой, если
	      была произведена неверная операция с памятью (обращение по несуществующему
	      или защищённому адресу). Обработчик по умолчанию завершает процесс.</para></listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>SIGSTOP</term>
	      <listitem><para>Сигнал приостановки работы процесса. Этот
	      сигнал не может быть перехвачен, заблокирован или
	      переопределён. Используется для гарантированной приостановки работы
	      процесса с полным сохранением его состояния и
	      возможностью возобновления.</para></listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>SIGTERM (15)</term>
	      <listitem><para>Сигнал завершения процесса, как правило используется для
	      корректного завершения его работы. Пример использования сигнала показан на
	      рисунке <xref linkend="img-signal-example"/></para>
	      <para>
	        <figure id="img-signal-example">
	          <title>Пример использования сигнала SIGTERM</title>
	          <graphic fileref="&BASEIMAGES;signal-example.png"/>
	        </figure>
	      </para>
	    </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>SIGUSR1, SIGUSR2</term>
	      <listitem><para><quote>Пользовательские</quote> сигналы&nbsp;&mdash; могут
	      использоваться процессами для всевозможных уведомлений. Обработчик по
	      умолчанию завершает процесс.</para></listitem>
	    </varlistentry>
	  </variablelist>
	</para>
	<para>
	  Сигналы являются ограниченным средством межпроцесснного обмена. Они прекрасно
	  подходят для уведомлений, но не могут использоваться для передачи информации
	  между процессами. Сигналы передаются без каких-либо сопутствующих данных,
	  поэтому они обычно комбинируются с другими способами обмена (например, как
	  показано на рисунке <xref linkend="img-sigusr1-example"/>&nbsp;&mdash; здесь
	  сообщения между процессами сохраняются в общем файле, а сигнал служит для
	  уведомления о приходе нового сообщения). Ещё одна интересная особенность
	  сигналов&nbsp;&mdash; в случае поступления нескольких сигналов одного вида в
	  течение короткого интервала времени принимающий процесс рассматривает их как
	  один поступивший сигнал, и вызывает обработчик только один раз, т.&nbsp;е. сигналы не
	  накапливаются.
	</para>
        <para>
	  <figure id="img-sigusr1-example">
	    <title>Использование сигналов при межпроцессном обмене</title>
	    <graphic fileref="&BASEIMAGES;sigusr1-example.png"/>
	  </figure>
	</para>
      </sect3>	

      <sect3 id="intro-unixproc-interproc-pipes">
	<title>Каналы</title>
	<presentation number="3-10" name="каналы"/>
	<question id="quest-3-6">Чем различаются именованный и неименованный каналы?</question>
	<para>
	  <definition id="def-pipe" orig="канал">Канал</definition>&nbsp;&mdash; поток
	  данных между двумя или несколькими процессами, имеющий интерфейс, аналогичный
	  чтению или записи в файл. Каналы бывают одно- и двунаправленными. В UNIX каналы,
	  как и многие другие системные объекты, представлены в виде файлов, вся работа с
	  ними производится через базовый файловый интерфейс&nbsp;&mdash; открытие и
	  закрытие файла, чтение и запись данных и т.&nbsp;п. В этом смысле каналы можно
	  представлять в виде специализированных файлов, которые не хранят информацию, а
	  лишь накапливают её до следующей операции чтения из канала
	  другим процессом, образуя очередь. Одни
	  процессы записывают данные в канал, другие&nbsp;&mdash; читают из него, данные
	  продвигаются по каналу в порядке очереди (FIFO). 	 
	</para>
	<para>
	  По умолчанию в UNIX каждому процессу при запуске ставится в соответствие три
	  открытых файла: стандартного ввода, стандартного вывода и стандартного вывода
	  для ошибок. С помощью средств командной строки (см. подробнее в <xref
	  linkend="shell-base"/>) такие потоки для разных процессов могут быть объединены
	  так, что, к примеру, вывод одного процесса будет подаваться на ввод другого
	  (см. рисунок <xref linkend="img-pipe"/>). То есть процесс работает с тремя
	  потоками данных одинаково вне зависимости от того, обычные
	  это файлы или же каналы. В более общем смысле такие потоки называют <definition
	  id="def-anonymous-pipe" orig="неименованный канал">неименованными
	  каналами</definition>. Канал создаётся по запросу и
	  существует только в ходе работы двух
	  процессов, другие процессы в системе не могут обратиться к
	  этому каналу. Если процесс
	  на одной из сторон канала завершается и закрывает канал, другому процессу
	  посылается специальный сигнал&nbsp;&mdash; <command>SIGPIPE</command>.
	</para>
	<para>
	  <figure id="img-pipe">
	    <title>Неименованный канал между двумя процессами</title>
	    <graphic fileref="&BASEIMAGES;pipe.png"/>
	  </figure>
	</para>
	<para>
	  Другой вид каналов в UNIX&nbsp;&mdash; <emphasis>именованные
	  каналы</emphasis>&nbsp;&mdash; представляют собой особый тип файлов. Эти файлы
	  располагаются в файловой системе и могут быть открыты любым процессом (если это
	  позволяется правами доступа, см. раздел <xref linkend="security-lect"/>). 
	</para>
	<para>
	  Каналы широко используются в UNIX, как при запуске программ в командной строке,
	  так и при взаимодействии системных процессов. Главное достоинство
	  каналов&nbsp;&mdash; простота и удобство использования привычного файлового
	  интерфейса. С другой стороны, данные в каналах передаются
	  только в одном направлении и строго последовательно, что
	  ограничивает сферу применения каналов.
	</para>
      </sect3>
      
      <sect3 id="intro-unixproc-interproc-sockets">
	<title>Сокеты</title>
	<presentation number="3-11" name="сокеты"/>
	<para>
	  <definition id="def-socket" orig="сокет">Сокеты</definition> предоставляют
	  альтернативный интерфейс обмена данными как в рамках одной системы, так
	  и между процессами, запущенными на разных машинах в сети.
	</para>
	<para>
	  Интерфейс сокетов позволяет явно разделить во взаимодействии двух процессов
	  серверную и клиентскую часть. Серверный процесс инициализирует сокет и ждёт
	  входящих соединений от других процессов. Клиентский процесс
	  устанавливает соединение, и с этого момента по образовавшемуся каналу можно
	  передавать поток данных в обе стороны. Такие сокеты называются
	  <emphasis>потоковыми</emphasis>. Другой тип сокетов,
	  <emphasis>датаграммный</emphasis>, позволяет отправлять сообщения (длиной не
	  более 64 кбайт) между процессами, привязанными к данному сокету.
	</para>
	<para>
	  <figure id="img-sockets">
	    <title>Датаграммный и потоковый сокеты</title>
	    <graphic fileref="&BASEIMAGES;sockets.png"/>
	  </figure>
	</para>
	<para>
	  Интерфейс сокетов впервые появился в операционной системе
	  BSD и использовался для связи компьютеров через сеть Internet
	  по протоколам TCP (потоковые сокеты) и UDP
	  (датаграммные сокеты), о чём подробнее рассказывается в разделе <xref
	  linkend="network-lect"/>. Это основное применение сокетов, и до настоящего
	  времени они являются стандартным средством взаимодействия процессов в
	  сети. Кроме того, существует <emphasis>локальный</emphasis> вариант
	  взаимодействия через сокеты, в котором обмен данными происходит через
	  специальные файлы, расположенные в файловой системе (фактически, это аналог
	  именованных каналов, но с интерфейсом сокетов).
	</para>
      </sect3>

    </sect2>
    <sect2 id="intro-unixproc-summary">
      <title>Резюме</title>
      <presentation number="3-12" name="резюме"/>
      <para>
	Управление процессами&nbsp;&mdash; второй важный аспект работы операционной
	системы UNIX. В операционной системе реализован сложный механизм управления
	памятью, позволяющий организовать собственное виртуальное адресное пространство
	для каждого процессса в системе.
      </para>
      <para>
	Каждый процесс в системе имеет уникальный идентификатор, состояние и контекст
	исполнения. В UNIX реализован механизм псевдопараллельного исполнения множества
	процессов. Планирование процессов производится на основе динамических
	приоритетов.
      </para>
      <para>
	Новые процессы создаются путем разветвления процесса на родительский и
	дочерний. Таким образом, все процессы в системе выстраиваются в строгую иерархию.
      </para>
      <para>
	Для межпроцессного взаимодействия используются специальные средства, основными среди
	которых являются разделяемая память, каналы, сигналы и сокеты. Каждый из этих
	способов взаимодействия обладает своими достоинствами и характерной областью
	применения.
      </para>
      <list-of-definitions/>
    </sect2>    
    <sect2 id="intro-unixproc-additional">
      <title>Дополнительные материалы</title>
      <para>
	<orderedlist>
	  <listitem>
	    Бах Дж.&nbsp;М. <emphasis>Архитектура операционной системы
	      UNIX</emphasis>.&nbsp;&mdash; <ulink
					       url="http://www.opennet.ru/docs/RUS/unix/">
	      http://www.opennet.ru/docs/RUS/unix/</ulink>
	  </listitem>
	  <listitem>
	    Курячий Г.&nbsp;В. <emphasis>Операционная система UNIX</emphasis>.&nbsp;&mdash;
	    М.:Интуит.Ру, 2004.&nbsp;&mdash; 292 с.: ил.
	  </listitem>
	  <listitem>
	    Робачевский А.&nbsp;М. <emphasis>Операционная система UNIX</emphasis>.&nbsp;&mdash;
	    СПб.: БХВ-Петербург, 2002.&nbsp;&mdash; 528 с.: ил.
	  </listitem>
	  <listitem>
	    МакКузик М. К., Невилл-Нил Дж. В. <emphasis>FreeBSD:
	    архитектура и реализация</emphasis>.&nbsp;&mdash; М.:
	    КУДИЦ-ОБРАЗ, 2006.&nbsp;&mdash; 800 с.
	  </listitem>
	  <listitem>
	    Максвелл С. <emphasis>Ядро Linux в комментариях</emphasis>.&nbsp;&mdash;
	    К.: Издательство <quote>Диа-Софт</quote>, 2000.&nbsp;&mdash; 488 с.: ил.
	  </listitem>
	</orderedlist>
      </para>
    </sect2>   
    <list-of-questions id="intro-unixproc-question"/>
    <small-presentation id="intro-unixproc-presentaion"/>
  </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
