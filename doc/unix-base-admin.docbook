<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
	  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [  
	  <!ENTITY BASEIMAGES "images/">
]>
<!--
    Copyright (c) 2005-2006  Aleksey Fedoseev <aleksey@fedoseev.net>.
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.2
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled "GNU
    Free Documentation License"
-->
<book lang="ru">
  <bookinfo>
    <title>Введение в администрирование UNIX</title>
    <author id="aleksey_fedoseev">
      <firstname>Алексей</firstname>
      <surname>Федосеев</surname>
      <affiliation>
	<orgname><ulink url="http://lug.mstu.ru">Linux User Group МГТУ им. Н.Э. Баумана</ulink></orgname>
	<address format="linespecific"><email>aleksey@fedoseev.net</email></address>
      </affiliation>
    </author>
    <copyright>
      <year>2005</year>
      <year>2006</year>
      <holder><xref linkend="aleksey_fedoseev"/></holder>
    </copyright>
    <legalnotice>
      Обращаю внимание читателей на то, что этот текст распространяется под свободной
      лицензией GNU Free Documentation License (<acronym>FDL</acronym>).
    </legalnotice>
  </bookinfo>
  
  <para>
    В создании лекций принимали участие 
    <author>
      <firstname>Сергей</firstname>
      <surname>Виноградов</surname>
    </author> <email>work.serge@gmail.com</email> и
    <author>
      <firstname>Андрей</firstname>
      <surname>Егерев</surname>
    </author> <email>premudrij-peskar@yandex.ru</email>.
  </para>
  <para>
    Эти лекции находятся в ещё достаточно сыром состоянии. Автор будет очень признателен
    за все высказанные поправки и замечания. Пишите: <email>aleksey@fedoseev.net</email>.
  </para>
  
<preface id="chapter-about">
  <title>Вступление к курсу</title>
  <para>
    Тема администрирования UNIX-подобных операционных систем очень обширна, так что
    объединить её одним курсом совершенно не реально. Однако, если говорить
    о <quote>введении в администрирование</quote>, можно органичиться только основными
    деталями: всем тем, что пригодится начинающему системному админимтратору.
  </para>
  <para>
    UNIX-системы характеризуются очень высоким уровнем документированности, так что
    пользователям и администраторам этих систем приходится рано или поздно заниматься
    самообучением, какие-то указатели на соответствующие материалы и книги могут быть
    позаимствованы из этого курса.
  </para>
  <para>
    Курс позиционируется как набор лекций и практических лабораторных работ объёмом в один
    семестр. Он был опробован на Факультете Военного Обучения МГТУ им. Н.Э. Баумана. Часть
    материалов носит дополнительный характер, имеет смысл ознакомиться с ними
    самостоятельно. В конце приводится список вопросов и заданий для самопроверки, которые
    покрывают материал всего курса.
  </para>
  <para>
    В настоящий момент работа над лекциями продолжается, следите за обновлениями.
  </para>
</preface>

  
<chapter id="chapter-intro">
  <title>Введение в операционную систему UNIX</title>
  <para>
    Современные открытые операционные системы, такие как <ulink url="http://www.kernel.org">Linux</ulink> или <ulink url="http://www.openbsd.org">OpenBSD</ulink>,
    предсталяют собой наследие операционной системы UNIX, появившейся в начале 1970-х годов
    и оказавшей огромное влияние на практические реализации операционных систем и развитие
    всей области информационных техногогий. Поэтому изучение любой из современных
    UNIX-подобных операционных систем невозможно без рассмотрения основных идей,
    заложенных в оригинальный UNIX.
  </para>
  <para>
    Из этой главы Вы сможете узнать основы теории операционных систем и то, как эти
    концепции реализованы в операционной системе UNIX. Также в ней рассматриваются
    основные этапы развития операционных систем с момента их возникновения до настоящего
    времени.
  </para>
  <!-- занятие №1 (лекция) -->
  <sect1 id="intro-concepts">
    <title>Основные концепции операционных систем</title>
    <sect2 id="intro-concepts-cs">
      <title>Обзор компьютерных систем</title>
      <para><link linkend="small-pres-1-01">Презентация 1-01: обзор компьютерных систем</link></para>
      <para>
	Все современные компьютерные системы построены по
	<emphasis id="def-von-Neumann" xreflabel="три принципа фон Неймана">трём
	  принципам</emphasis> <personname><firstname>Джона</firstname> <surname>фон
	    Неймана</surname></personname>: <emphasis>программного
	  управления</emphasis>, <emphasis>однородности памяти</emphasis>
	и <emphasis>адресности</emphasis>. Эти принципы можно раскрыть следующим
	образом: программа, состоящая из набора команд, и исходные данные хранятся в
	общей памяти, каждая ячейка которой имеет свой адрес; каждая команда вместе с
	данными выбирается из памяти и исполняется процессором, выбор команды
	осуществляется с помощью специального <emphasis>счётчика команд</emphasis>,
	который содержит в себе адрес исполняемой в данный момент команды; команды
	расположены в памяти друг за другом, за счёт чего организуется последовательная
	выборка из памяти цепочки команд.
      </para>
      <para>
	На основании этого можно выделить три основных структурных элемента компьютера
	(см. <xref linkend="img-computer-structure"/>):
	<variablelist>
	  <varlistentry>
	    <term>Процессор</term>
	    <listitem><para>
		Осуществляет контроль за действиями компьютера, а также выполняет функцию
		обработки данных согласно программе. В современных системах может быть один
		и больше центральных процессоров.
	    </para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Основная память</term>
	    <listitem><para>
		В ней хранятся программы и данные. Как правило является временной
		(информация сохраняется, пока подаётся питание).
	    </para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Устройства ввода-вывода</term>
	    <listitem><para> Служат для передачи данных между компьютером и внешним
		окружением, состоящим из переферийных устройств, в число которых входят
		внешняя память, коммуникационное оборудование, терминалы.
	    </para></listitem>
	  </varlistentry>
	</variablelist>
      </para>
      <para>
	Перечисленные компоненты вычислительной системы объединяются с
	помощью <emphasis id="def-system-bus" xreflabel="системная шина">системной
	  шины</emphasis>. Это структуры и механизмы, обеспечивающие взаимодействие между
	процессором, основной памятью и устройствами ввода-вывода.
      </para>
      <para>
	<figure id="img-computer-structure" float="0">
	  <title>Компоненты компьютерных систем</title>
	  <graphic fileref="images/computer_structure.png"/>
	</figure>
      </para>
      <para><link linkend="small-pres-1-02">Презентация 1-02: центральный процессор</link></para>
      <para>
	<emphasis id="def-cpu" xreflabel="центральный процессор">Центральный
	  процессор</emphasis> извлекает программу из памяти, декодирует и исполняет
	команды, переходит к следующей команде согласно текущей команде.
      </para>
      <para>
	В каждый момент времени процессор может испонять только одну программу. Многие
	современные операционные системы относятся к <emphasis id="def-mp-os" xreflabel="многозадачные ОС">многозадачным</emphasis>, т.е. одновременно может
	исполняться несколько задач, число которых заранее не известно. Так как число
	процессоров конечно, необходимы алгоритмы, позволяющие чередовать исполнения
	процессов так, чтобы каждый из них получал процессорное время. Этот подход
	называется <emphasis id="def-pseudo-parallel" xreflabel="псевдопараллелизм">псевдопараллелизмом</emphasis>
	(см. <xref linkend="img-parallelism"/>): каждому процессу
	выделяется <emphasis id="def-cpu-quant" xreflabel="квант процессорного&#10;&#9;времени">квант процессорного
	времени</emphasis>, по истечение которого управление передается другому процессу
	(это действие называют <emphasis id="def-context-switch" xreflabel="переключение  контекста">переключением контекста</emphasis>). Также управление может быть
	передано другому процессу, если исполняемый процесс ожидает системный ресурс. В
	случае многопроцессорных компьютеров принцип остаётся прежним – только
	лишь большее число процессов может одновременно исполняться на этих процессорах.
      </para>
      <para>
	<figure id="img-parallelism" float="0">
	  <title>Пример пcевдопараллелизма</title>
	  <graphic fileref="images/parallelism.png"/>
	</figure>
      </para>
      <para><link linkend="small-pres-1-03">Презентация 1-03: память</link></para>
      <para>
	Конфигурация памяти компьютера определяется в основном тремя
	параметрами: <emphasis>объём</emphasis>, <emphasis>быстродействием</emphasis>,
	<emphasis>стоимость</emphasis>. Очевидно, между этими противоречивыми
	характеристиками существует компромисс, который представляет
	собой <emphasis id="def-memory-hierarchy" xreflabel="иерархия памяти">иерархию
	  памяти</emphasis> (см. <xref linkend="img-memory-hierarchy"/>). Таким образом, к
	дорогим устройствам с высокой производительностью и малым объёмом добавляются
	дешёвые устройства с меньшей скоростью доступа и большим объёмом. При этом ярко
	выражена функция каждого из уровней: регистровая память хранит операнды команд,
	кэш используется для хранения самых используемых участков памяти, основная память
	хранит исполняющиеся программы, внешняя – сохраняет данные и программы
	между запусками.
      </para>
      <para>
	<figure id="img-memory-hierarchy" float="0">
	  <title>Иерархия видов памяти</title>
	  <graphic fileref="images/memory_hierarchy.png"/>
	</figure>
      </para>
      <para>
	Особое значение имеет <emphasis>основная память</emphasis> – в ней
	хранятся все исполняющиеся программы и данные к ним. Программа может обращаться к
	любой ячейке памяти в своём <emphasis id="def-address-space" xreflabel="адресное  пространство">адресном пространстве</emphasis>. Существует несколько видов
	адресных пространств: <emphasis>реальное</emphasis> (соответствует ячейкам
	физической памяти) и <emphasis>виртуальное</emphasis> (каким-то образом
	проецируемое на реальное адресное пространство). В современных операционных
	системах каждый процесс обладает своим собственным адресным пространством, так что
	не может нанести вред памяти других процессов.
      </para>
      <para><link linkend="small-pres-1-04">Презентация 1-04: управление вводом-выводом</link></para>
      <para>
	Взаимодействие с устройствами ввода-вывода может происходить тремя способами:
	<emphasis>программируемый ввод-вывод</emphasis>, ввод-вывод с
	помощью <emphasis id="def-interrupt" xreflabel="прерывание">прерываний</emphasis>, <emphasis id="def-dma" xreflabel="прямой доступ&#10;&#9;к памяти">прямой доступ
	к памяти</emphasis> (Direct Memory Access, <acronym>DMA</acronym>).
      </para>
      <para>
	В первом случае процессор явно обращяется к контроллеру внешнего устройства,
	вызывая управляющие команды и обмениваясь данными. Так как скорость работы
	процессора значительно превышает скорость работы внешних устройств, при таком
	способе обмена простои в работе процессора будут очень велики. Для избежания этой
	ситуации используется механизм <emphasis>прерываний</emphasis>: выполнение
	программы в процессоре может быть прервано, когда данные на внешнем устройстве
	готовы для чтения или записи – при этом запускается специальная
	функция-обработчик прерывания, затем выполнение исходной программы
	возобновляется. При использовании <emphasis>прямого доступа к памяти</emphasis>,
	процессор не участвует в процессе ввода-вывода – за копированием данных
	из устройства в основную память следит специальный контроллер прямого доступа к
	памяти.
      </para>
    </sect2>
    <sect2 id="intro-concepts-os">
      <title>Назначение операционной системы</title>
      <para><link linkend="small-pres-1-05">Презентация 1-05: Операционная система</link></para>
      <phrase id="quest-1-1" xreflabel="Каково назначение операционной системы? Почему говорят&#10;&#9;об операционной системе как виртуальной машине? Какими ресурсами и&#10;&#9;как управляет операционная система?"/>
      <para>
	<emphasis id="def-os" xreflabel="операционная система">Операционная
	  система</emphasis> – это комплекс взаимосвязанных программ, который
	действует как интерфейс между приложениями и пользователями с одной стороны, и
	аппаратурой компьютера с другой стороны. В соответствии с этим определением,
	операционная система выполняет две основные функции:
	<itemizedlist>
	  <listitem>
	    предоставление пользователю или программисту вместо реальной аппаратуры
	    расширенной <emphasis>виртуальной машины</emphasis> (которую иногда
	    называют <emphasis>операционная среда</emphasis>), с которой удобно работать и
	    которую легче программировать;
	  </listitem>
	  <listitem>
	    повышение эффективности использования компьютера путём рационального
	    управления его ресурсами в соответствии с некоторыми критериями.
	  </listitem>
	</itemizedlist>
      </para>
      <sect3 id="intro-concepts-os-vm">
	<title>Операционная система как виртуальная машина</title>
	<para><link linkend="small-pres-1-06">Презентация 1-06: виртуальная машина</link></para>
	<para>
	  Для того чтобы успешно решать свои задачи, в настоящее время пользователь или
	  программист может обойтись без досконального знания аппаратного устройства
	  компьютера и может даже не знать системы команд процессора (для программистов
	  существует множество библитек и высокоуровневых фукций). 
	</para>
	<para>
	  Программное и аппаратное обеспечение можно выстроить в виде иерархии, каждый
	  уровень которой представляет собой <emphasis id="def-vm" xreflabel="виртуальная    машина">виртуальную машину</emphasis> со своим интерфейсом (например,
	  <xref linkend="img-virtual-machine"/>), за которым скрываются детали
	  нижележащего уровня.
	</para>
	<para>
	  <figure id="img-virtual-machine" float="0">
	    <title>Уровни вычислительной системы</title>
	    <graphic fileref="images/virtual_machine.png"/>
	  </figure>
	</para>
	<para>
	  Операционная система избавляет програмимистов от необходимости напрямую работать
	  с аппаратурой, предоставляя им простой интерефейс (файловый, сетевой и т.п.), а
	  также берет на себя все рутинные операции по управлению аппаратными устройствами
	  компьютера: физической памятью, таймерами, устройствами ввода и т.п..
	</para>
	<para>
	  В результате реальная машина, способная выполнять элементарные действия,
	  определенные её набором команд, превращается в виртуальную машину, выполняющую
	  набор более мощных функций. Виртуальная машина также управляется командами, но
	  более высокого уровня: создание и удаление файлов, установка сетевых соединений
	  и т.п.. В свою очередь, эти команды также могут быть объединены в виртуальную
	  машину с более высоким уровнем абстракции, например графический пользовательский
	  интерфейс, который оперирует объектами.
	</para>
      </sect3>
      <sect3 id="intro-concepts-os-rm">
	<title>Операционная система как менеджер ресурсов</title>
	<para><link linkend="small-pres-1-07">Презентация 1-07: управлнение ресурсами</link></para>
	<para>
	  Операционная система не только предоставляет пользователям и программистам
	  удобный интерфейс к аппаратным средствам компьютера, но и является механизмом,
	  распределяющим ресурсы компьютера.
	</para>
	<para>
	  В разделе <xref linkend="intro-concepts-cs"/> уже рассматривались основные
	  <emphasis id="def-resources" xreflabel="ресурс">ресурсы</emphasis> компьютера:
	  процессорное время, основная память, всевозможные внешние устройства; также к
	  ресурсам можно отнести таймеры и некоторые процедуры операционной
	  системы. Ресурсы эти распределяются между
	  процессами. <emphasis id="def-process" xreflabel="процесс">Процесс</emphasis>
	  предсталяет собой базовое понятие большинства операционных систем, и чаще всего
	  определяется как программа в стадии своего выполнения.
	</para>
	<para>
	  Управление ресурсами вычислительной системы с целью наиболее эффективного их
	  использования – назначение операционной системы. Многозадачная
	  операционная система занимается переключением процессора с одного процесса на
	  другой, максимизируя его загрузку, а также отслеживает конфликты при обращении к
	  общим ресурсам.
	</para>
	<para>
	  Критерий эффективности, в соответствии с которым операционная система организует
	  управление ресурсами компьютера, может быть различным и зависит от назначения
	  информационно-вычислительной системы, частью которой она является. Например, в
	  одних системах важен такой критерий,
	  как <emphasis id="def-production" xreflabel="пропускная&#10;&#9;  способность">пропускная
	  способность</emphasis> – число задач, выполненных за единицу
	  времени, а в других – <emphasis id="def-reaction" xreflabel="время&#10;&#9;  реакции">время
	  реакции</emphasis> (время, прошедшее с момента ввода команды до получения
	  отклика системы).
	</para>
      </sect3>
    </sect2>
    <sect2 id="intro-concepts-arch">
      <title>Архитектура операционной системы</title>
      <para><link linkend="small-pres-1-08">Презентация 1-08: архитектура операционной системы</link></para>
      <phrase id="quest-1-2" xreflabel="Архитектура операционной системы: что такое ядро и&#10;      прикладные программы? Чем отличаются монолитные и микроядерные системы?"/>
      <para>
	Операционная система выполняет множество функций, которые обычно группируются в
	соответствии с видом ресурса, которым управляет операционная система, либо со
	специфической задачей, применимой ко всем видам ресурсов. Можно выделить следующие
	функции современной многозадачной многопользовательской операционнной системы:
	управление процессами, управление памятью, управление файлами и внешними
	устройствами, защита данных и администрирование, интерфейс прикладного
	программирования, пользовательский интерфейс. 
      </para>
      <para>
	Наиболее общим подходом к структуризации операционной системы является её
	разделение всех её модулей на две группы:
	<itemizedlist>
	  <listitem>
	    <emphasis id="def-kernel" xreflabel="ядро">ядро</emphasis> – модули, выполняющие
	    основные функции операционной системы, решающие внутрисистемные задачи
	    организации вычислительного процесса, такие как переключение контекста,
	    управление памятью, обработка прерываний, работа с внешними устройствами и
	    т.п..
	  </listitem>
	  <listitem>
	    компоненты, реализующие дополнительные функции операционной
	    системы – всевозможные служебные программы,
	    или <emphasis id="def-utilites" xreflabel="утилиты">утилиты</emphasis>.
	  </listitem>
	</itemizedlist>
      </para>
      <para> Для надежного управления ходом выполнения программ операционная система
	должна иметь по отношению к пользовательским процессам оперделённые
	привелегии – иначе некорректно работающее приложение сможет вмешаться в
	работу операционной системы. Например, взаимодействие с аппаратурой возможно
	только на самом высоком уровне привелегий, который не дается обычным программам.
	Чаще всего именно ядро является той частью операционной системы, которая работает
	в <emphasis id="def-privilegies" xreflabel="привилегированый режим">привелегированном
	режиме</emphasis>.
      </para>
      <para>
	Большинство современных операционных систем представляет собой хорошо
	структурированные модульные системы, способные к развитию, расширению и переносу
	на новые платформы. Существует ряд универсальных подходов к стуктурированию
	операционных систем, среди которых можно выделить <emphasis>монолитную</emphasis>
	и <emphasis>микроядерную</emphasis> архитектуры.
      </para>
      <sect3 id="intro-concepts-arch-monolith">
	<title>Монолитная операционная система</title>
	<para><link linkend="small-pres-1-09">Презентация 1-09: монолитное ядро</link></para>
	<para>
	  Большинство операционных систем
	  использует <emphasis id="def-monolith-kernel" xreflabel="монолитное ядро">монолитное ядро</emphasis>,
	  которое компонуется как одна программа, работающая в привилегированном режиме и
	  использующая быстрые переходы с одной процедуры на другую, не требующие
	  переключения из привилегированного режима в пользовательский и наоборот (хоть
	  этот процесс и происходит с аппаратной поддержкой, он занимает значительное
	  время). Такое ядро делится на основные компоненты и модули, реализующие
	  дополнительную функциональность – например, работу со специфическими
	  внешними устройствами и файловыми системами
	  (см. <xref linkend="img-monolith-kernel"/>).  Переход из пользовательского
	  режима в режим ядра осуществляется через <emphasis id="def-system-call" xreflabel="системный вызов">системные
	  вызовы</emphasis> – интерфейс ядра операционноый системы.
	</para>
	<para>
	  <figure id="img-monolith-kernel" float="0">
	    <title>Структура монолитного ядра операционной системы</title>
	    <graphic fileref="images/monolith_kernel.png"/>
	  </figure>
	</para>
      </sect3>
      <sect3 id="intro-concepts-arch-microkernel">
	<title>Микроядерная операционная система</title>
	<para><link linkend="small-pres-1-10">Презентация 1-10: микроядро</link></para>
	<para>
	  Альтернативой является построение операционной системы на
	  базе <emphasis id="def-microkernel" xreflabel="микроядро">микроядра</emphasis>,
	  работающего также в привилегированном режиме и выполняющего только минимум
	  функций по управлению аппаратурой. Тогда как функции операционной системы более
	  высокого уровня выполняют специализированные
	  компоненты – <emphasis>серверы</emphasis>, работающие в
	  пользовательском режиме. Управление и обмен данными при этом осуществляется
	  через передачу <emphasis id="def-message" xreflabel="сообщение">сообщений</emphasis>, доставка которых является одной из
	  основных функций микроядра (см. <xref linkend="img-micro-kernel"/>).
	</para>
	<para>
	  При таком построении операционная система работает значительно более медленно,
	  так как часто выполняются переходы между привилегированным и пользовательским
	  режимом, зато система получается более гибкой – её функции можно
	  наращивать или модифицировать, добавляя, изменяя или исключая серверы
	  пользовательского режима. Кроме того, серверы хорошо защищены друг от друга, как
	  и любые пользовательские процессы.
	</para>
	<para>
	  <figure id="img-micro-kernel" float="0">
	    <title>Структура операционной системы с микроядром</title>
	    <graphic fileref="images/micro_kernel.png"/>
	  </figure>
	</para>
      </sect3>
    </sect2>
    <sect2 id="intro-os-history">
      <title>История развития операционных систем</title>
      <para><link linkend="small-pres-1-11">Презентация 1-11: история операционных систем</link></para>
      <para>
	За половину века своего существования операционные системы прошли сложный путь,
	огромное влияние на который оказало развитие вычислительной аппаратуры. Хотя
	большинство алгоритмов и подходов в операционных системах было разработано в
	1960–1970-х годах, в настоящее время операционные системы продолжают
	развиваться и видоизменяться согласно потребностям пользователей. Можно выделить
	три основные характеристики, ставшие уже обязательными для большинства
	операционных систем: переносимость между различными аппаратными архитектурами,
	многозадачность и многопользовательский режим работы.
      </para>
      <para>
	Рассмотрим основные этапы развития операционных систем от момента их появления до
	текущего состояния.
      </para>
      <sect3 id="intro-before-os">
	<title>Что было до операционных систем</title>
	<para>
	  С середины 50-х годов началось бурное развитие вычислительной техники, связанное
	  с появлением полупроводниковых элементов. Вместе с этим заметный прогресс
	  наблюдался в автоматизации программирования и организации вычислений, в эти годы
	  появились первые алгоритмические языки (Алгол, Фортран, Кобол). Для организации
	  эффективного совместного использования трансляторов, библиотечных программ и
	  загрузчиков в штат многих вычислительных комплексов были
	  введены <emphasis>операторы</emphasis> – но как быстро они не
	  работали, они не могли состязаться в производительности с работой
	  компьютера. Для решения этой проблемы были
	  разработаны <emphasis id="def-packet-systems" xreflabel="системы пакетной&#10;&#9;  обработки">системы пакетной
	  обработки</emphasis>, которые автоматизировали последовательность действий
	  оператора. Оператор составлял <emphasis>пакет заданий</emphasis>, которые в
	  дальнейшем без его участия запускались на выполнение специальной
	  программой – монитором.
	</para>  
      </sect3>
      <sect3 id="intro-os-mainframes">
	<title>Операционные системы для мэйнфреймов</title>
	<para>
	  В 1965–1975 годах появилось следующее поколение компьютеров: стала
	  возможна реализация сложных компьютерных архитектур (например, IBM/360) и
	  практически всех основных механизмов, присущих современным операционным
	  системам: многозадачность, поддержка многотерминального многопользовательского
	  режима работы, виртуальная память, файловые системы, разганичение доступа и
	  сетевая работа. Но такие системы всё ещё были очень редки и чрезвычайно дороги.
	</para> 
	<para>
	  Одним из главных достижений стал переход к <emphasis id="def-multiprogramming" xreflabel="мультипрограммирование">мультипрограммированию</emphasis> –
	  способ организации вычислительного процесса, при котором в памяти копьютера
	  одновременно находится несколько программ, попеременно выполняющихся на одном
	  процессоре. Для того, чтобы у пользователя оставалось ощущение непосредственного
	  взаимодействия с компьютером, был разработан такой вариант
	  мультипрограммирования, как <emphasis id="def-shared-time-systems" xreflabel="системы&#10;&#9;  разделения времени">системы
	  разделения времени</emphasis>. Каждый пользователь работает за своим
	  терминалом (подробнее терминалы рассматриваются в разделе
	  <xref linkend="shell-base-terminal"/>), тогда как все процессы работают
	  псевдопараллельно (как было показано выше, в разделе
	  <xref linkend="intro-concepts-cs"/>).
	</para>
      </sect3>
      <sect3 id="intro-os-unix">
	<title>Появление операционной системы UNIX</title>
	<para>
	  В середине 1970-х годов наряду с мэйнфреймами получили широкое распространение
	  мини-компьютеры (слово <quote>мини-</quote> сейчас может показаться смешным,
	  такие компьютеры занимали объём в несколько шкафов), такие как
	  PDP-11. Архитектура таких компьютеров была заметно упрощена по сравнению с
	  мэйнфреймами (что значительно снижало стоимость  с миллионов до сотен тысяч
	  долларов), что сказалось на операционных системах для этих
	  компьютеров – они были лишены части функций, например
	  многопользовательского режима работы.
	</para>
	<para>
	  Важным этапом в истории мини-компьютеров и операционных систем в целом явилось
	  появление операционной системы <emphasis>UNIX</emphasis> в лаборатории Bell Labs
	  компании AT&amp;T. Изначально она была разработана для мини-компьютера PDP-7 и
	  включала в себя множество архитектурных особенностей более сложных операционных
	  систем, такие как разделение времени и многопользовательская работа. В 1970-х
	  годах началось массовое использование операционной системы UNIX, к этому времени
	  она была переписана на языке программирования высокого уровня С, что заметно
	  облегчило её переносимость. Поскольку эта операционная система распространялась
	  вместе с исходными текстаим, она стала первой операционной системой, в которою
	  могли вносить изменения энтузиасты. Удачные архитектурные решения UNIX,
	  гибкость, элегантность, мощные функциональные возможности и открытость позволили
	  этой операционной системе завоевать рынок не только мини-компьютеров, но и
	  мэйнфреймов, серверов, рабочих станций на
	  базе <acronym>RISC</acronym>-процессоров.
	</para>
	<para>
	  Многие появившиеся впоследствии операционные системы позаимствовали некоторые
	  ключевые идеи UNIX: переносимость на основе языка C, иерархическую файловую
	  систему, интерфейс командной строки. 
	</para>
      </sect3>
      <sect3 id="intro-os-internet">
	<title>Развитие операционных систем в глобальных сетях</title>
	<para>
	  В начале 1980-х годов в рамках экспериментальной сети <acronym>ARPANET</acronym>
	  впервые появился рабочий вариант стека
	  протоколов <acronym>TCP/IP</acronym>. Переход на <acronym>TCP/IP</acronym> был
	  ускорен ещё и тем, что его первая реализация была создана в
	  рамках <acronym>BSD</acronym> UNIX (Berkley Software Distribution –
	  академической версии UNIX, созданной в университете Беркли). Новая глобальная
	  сеть, получившая название Интернет, стала средой для развития информационных
	  технологий, создания всевозможных сообществ разработчиков и развития открытых
	  систем.
	</para>  
	<para>
	  В этот период появляется множество коммерческих версий операционной системы
	  UNIX: SunOS (в дальнейшем, Solaris), HP-UX, Irix, AIX и многие
	  другие. Разнообразие версий породило проблему их несовместимости, которую
	  периодически пытались решать различные организации. В результате были приняты
	  стандарты <acronym>POSIX</acronym> (Portable Operation System Interface based on
	  uniX – интерфейс для переносимых операционных систем, основанных на
	  UNIX), включающие формальное описание программного интерфейса операционной
	  системы, описание командной оболочки, безопасности и т.п..
	</para>
      </sect3>
      <sect3 id="intro-os-pc">
	<title>Операционные системы для персональных компьютеров</title>
	<para>
	  Ещё одно знаменательное событие начала 1980-х годов –
	  появление <emphasis>персональных компьютеров</emphasis>. С точки зрения
	  архитектуры они мало отличались от мини-компьютеров и рабочих станций, но
	  стоимость их была значительно ниже. Это позволило персональным компьютерам
	  распространиться повсеместно, и это в значительной степени изменило современные
	  информационные технологии.
	</para>  
	<para>
	  Первые операционные системы для персональных компьютеров были очень просты
	  (например, <acronym>MS-DOS</acronym>). Недостатки в функциональности
	  компенсировались графическим интерфейсом пользователя. Со временем эти
	  операционные системы (например, Microsoft Windows) получили сетевую подсистему и
	  возможность работать с несколькими программами одновременно. Также для
	  персональных компьютеров появились и более мощные операционные системы, как OS/2
	  (не получила широкого распространения) и Windows NT, которые также обладали
	  многозадачностью и многопользовательским режимом работы.
	</para>
	<para>
	  В первую очередь благодаря низкой стоимости аппаратного и программного
	  обеспечения, персональные компьютеры начали вытеснять прежде распространенные
	  рабочие станции и мэйнфреймы. На домашних и офисных компьютерах повсеместно
	  распространились операционные системы компании Microsoft, тогда как нишу
	  серверов заняли наследники UNIX: коммерческие версии UNIX и открытые, свободно
	  распространяемые <ulink url="http://www.kernel.org">Linux</ulink> и операционные системы из семейства BSD, созданные и
	  поддерживаемыми энтузиастами по всему миру.
	</para>
      </sect3>
      <sect3 id="intro-os-embedded">
	<title>Операционные системы для встраиваемых систем</title>
	<para>
	  В начале 21-го века широкое распространение
	  получили <emphasis>встраиваемые</emphasis> и <emphasis>мобильные</emphasis>
	  устройства. Благодаря развитию вычислительных систем, такие устройства, как
	  мобильные телефоны или домашние бытовые приборы, обрели возможности, сравнимые с
	  персональными компьютерами. В настоящее время в этой области существует
	  множество операционных систем, среди которых всё большую роль начинают играть
	  открытые операционные системы, наследующие архитектуру и принципы работы UNIX.
	</para>  
      </sect3>
    </sect2>
    <sect2 id="intro-os-classification">
      <title>Классификация операционных систем по назначению</title>
      <para><link linkend="small-pres-1-12">Презентация 1-12: классификация операционных систем</link></para>
      <phrase id="quest-1-3" xreflabel="Какие можно выделить классы операционных систем? В чём&#10;      заключаются их отличия?"/>
      <para>
	Операционные системы являются неотъемлимой частью информационно-вычислительных
	комплексов, которые выполняют определённые функции и могут быть по этому признаку
	разделены на некоторые классы.
      </para>
      <para>
	<variablelist>
	  <varlistentry>
	    <term><emphasis id="def-realtime-os" xreflabel="ОС реального времени">Системы
	    реального времени</emphasis></term>
	    <listitem>
	      <para>
		Основной особенностью таких систем является сторого регламентированное
		время отклика на внешние события. Другим важным параметром является
		одновременная обработка – даже если одновременно происходит
		несколько событий, реакция системы на них не должна
		запаздывать. Компьютеры для управления самолетами, ядерными реакторами и
		подобными сложными системами работают под управлением часто
		специализированных операционных систем реального времени.
	      </para>
	      <para>
		Операционные системы реального времени принято делить на два
		класса: <emphasis>жесткого</emphasis> и <emphasis>мягкого</emphasis>
		реального времени. Можно выделить признаки
		<emphasis id="def-hard-realtime" xreflabel="жёсткое реальное время">систем
		жёсткого реального времени</emphasis>:
	      </para>
	      <para>
		<itemizedlist>
		  <listitem>
		    недопустимость никаких задержек ни при каких условиях;
		  </listitem>
		  <listitem>
		    бесполезность результатов при опоздании;
		  </listitem>
		  <listitem>
		    катастрофа при задержке реакции;
		  </listitem>
		  <listitem>
		    цена опоздания бесконечно велика.
		  </listitem>
		</itemizedlist>
	      </para>
	      <para>
		Хороший пример системы жесткого реального времени – бортовая
		система управления самолетом. Среди систем с жеским реальным временем
		можно выделить распространённую коммерческую операционную систему QNX,
		которая основывается на UNIX и имеет схожий интерфейс.
	      </para>
	      <para>
		<emphasis id="def-soft-realtime" xreflabel="мягкое реальное время">Система
		мягкого реального времени</emphasis> характеризуется следующими
		признаками:
	      </para>
	      <para>
		<itemizedlist>
		  <listitem>
		    за опоздание результатов приходится платить;
		  </listitem>
		  <listitem>
		    снижение производительности системы, вызванное запаздыванием реакций,
		    приемлемое.
		  </listitem>
		</itemizedlist>
	      </para>
	      <para>
		Операционные системы мягкого времени могут использоваться в мобильных
		и коммуникационных системах – там, где цена опаздания не так
		велика. В настоящее время многие многозадачные операционные системы
		разделения времени модифицируются для того, чтобы соответствовать
		требованием мягкого реального времени. Среди примеров можно выделить
		варианты Windows NT и специфические версии ядра <ulink url="http://www.kernel.org">Linux</ulink>.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Встраиваемые системы</term>
	    <listitem><para>
		Такие системы работают на специфическом аппаратном обеспечении (автомобили,
		микроволновые печи, роботы) и также обладают некоторыми требованиями к
		времени отклика системы. Как правило, в таких операционных системах
		применяются специфичные алгоритмы, минимизирующие потребляемые ресурсы. В
		настоящее время широкое распространение имеют операционные системы Windows
		Embedded фирмы Microsoft и различные версии операционной системы <ulink url="http://www.kernel.org">Linux</ulink>.
	    </para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Операционные системы для супер-компьютеров</term>
	    <listitem><para>
		Для решения очень сложных и объёмных вычислительных задач создается
		специализированные компьютеры, содержащие сотни и тысячи процессоров. Для
		управления такими системами применяются специальные операционные системы, в
		которых особенно важны вопросы производительности и скорости обмена между
		элементами системы. В настоящее время самыми распространёнными среди
		сверх-производительных систем являются модификации операционной системы
		<ulink url="http://www.kernel.org">Linux</ulink>.
	    </para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Операционные системы для серверов</term>
	    <listitem>
	      <para>
		С момента расцвета сети Интернет нишу <emphasis id="def-server" xreflabel="сервер">серверов</emphasis> (специализированных систем,
		предоставляющих по сети какой-то сервис <emphasis>клиентским
		системам</emphasis>) занимают универсальные многопользовательские
		многозадачные операционные системы. Для таких систем имеют большое
		значение имеют стабильность работы, безопасность и производительность,
		меньшее – интерфейс пользователя.
	      </para>
	      <para>
		Примерами таких систем могут служить: банковские системы, веб-серверы и
		серверы баз данных, файловые серверы масштаба предприятия,
		многопользовательские терминальные серверы и т.п.  Традиционно этот класс
		систем обслуживается коммерческими операционными системами –
		различными версиями UNIX, операционными системами от компаний IBM, Nowell,
		а затем и Microsoft. Сейчас все большую популярность в этом классе систем
		завоёвывают открытые и свободные операционные системы, базирующиеся на
		UNIX.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Операционные системы для домашних и офисных компьютеров</term>
	    <listitem><para>
		Современные персональные компьютеры обладают высокой производительностью и
		богатыми мультимедийными возможностями. Для операционных систем этого класса
		важны удобный пользовательский интерфейс и поддержка широкого набора
		устройств для персональных компьютеров. Самыми распространёнными
		операционными системами в этом классе являются продукты компании Micrososft,
		также на персональных компьютерах Apple используется операционная система
		MacOS (с версии 10 она также основывается на UNIX).
	    </para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Исследовательские операционные системы</term>
	    <listitem><para>
		Многие алгоритмы и подходы в построении операционных систем не пошли дальше
		исследовательских лабораторий. Например, операционные системы, основанные на
		микроядре, в чистом виде не используются до сих пор из-за огромных затрат на
		пересылку сообщений. Одной из самых известных микроядерных операционных
		систем является Mach, на которой основывается целый ряд операционных систем,
		в том числе <ulink url="http://www.gnu.org/software/hurd/hurd.html">GNU Hurd</ulink>, реализующая интерфейс UNIX.
	    </para></listitem>
	  </varlistentry>
	</variablelist>	
      </para>
    </sect2>
    <sect2 id="intro-concepts-summary">
      <title>Резюме</title>
      <para><link linkend="small-pres-1-13">Презентация 1-13: резюме</link></para>
      <para>
	В первой лекции было рассмотрено введение в операционные системы.
      </para>
      <para>
	Операционные системы существуют в рамках информационно-вычислительных систем,
	которые сейчас, как и много лет назад, построены по принципам фон Неймана и
	содержат три основных компонента: центральный процессор, основную память и
	устройства ввода-вывода.
      </para>
      <para>
	Операционная система является комплексом программ, объединяющих пользователей,
	программы и аппаратуру компьютера. Выделяют две основные функции операционной
	системы: предоставление виртуальной машины и управление ресурсами компьютера.
      </para>
      <para>
	Операционная система состоит из модулей, среди которых выделяют ядро, как основу
	всей операционной системы. Существует два типа ядер: монолитные и микроядра.
      </para>
      <para>
	За время существования операционные системы прошли длительную эволюцию, однако,
	большинство идей, алгоритмов и архитектурных решений было реализовано в
	1960–70-е года: тогда появились многозадачность, многопользовательсякая
	работа, файловые системы и т.п..
      </para>
      <para>
	Современные операционные системы можно классифицировать по их назназначению. При
	этом выделяют операционные системы: реального времени, для встраиваемых систем,
	для супер-компьютеров, для серверов, для домашних и офисных компьютеров и
	исследовательские.
      </para>
      <para><emphasis>Ключевые термины: </emphasis><xref linkend="def-von-Neumann"/>, <xref linkend="def-system-bus"/>, <xref linkend="def-cpu"/>, <xref linkend="def-mp-os"/>, <xref linkend="def-pseudo-parallel"/>, <xref linkend="def-cpu-quant"/>, <xref linkend="def-context-switch"/>, <xref linkend="def-memory-hierarchy"/>, <xref linkend="def-address-space"/>, <xref linkend="def-interrupt"/>, <xref linkend="def-dma"/>, <xref linkend="def-os"/>, <xref linkend="def-vm"/>, <xref linkend="def-resources"/>, <xref linkend="def-process"/>, <xref linkend="def-production"/>, <xref linkend="def-reaction"/>, <xref linkend="def-kernel"/>, <xref linkend="def-utilites"/>, <xref linkend="def-privilegies"/>, <xref linkend="def-monolith-kernel"/>, <xref linkend="def-system-call"/>, <xref linkend="def-microkernel"/>, <xref linkend="def-message"/>, <xref linkend="def-packet-systems"/>, <xref linkend="def-multiprogramming"/>, <xref linkend="def-shared-time-systems"/>, <xref linkend="def-realtime-os"/>, <xref linkend="def-hard-realtime"/>, <xref linkend="def-soft-realtime"/>, <xref linkend="def-server"/></para>
    </sect2>    
    <sect2 id="intro-concepts-additional">
      <title>Дополнительные материалы</title>
      <para>
	<orderedlist inheritnum="ignore" continuation="restarts">
	  <listitem>
	    Курячий Г.В. <emphasis>Операционная система UNIX</emphasis>. –
	    М.:Интуит.Ру, 2004. – 292 с.: ил.
	  </listitem>
	  <listitem>
	    Олифер В.Г., Олифер Н.А. <emphasis>Сетевые операционные
	    системы</emphasis>. – СПб.: Питер, 2005. – 539 с.: ил.
	  </listitem>
	  <listitem>
	    Эрик С. Рэймонд <emphasis>Искусство программирования для
	      UNIX</emphasis>. – М.: Издательский дом <quote>Вильямс</quote>,
	      2005. – 544 стр.: ил.
	  </listitem>
	  <listitem>
	    Вильям Столлингс <emphasis>Операционные системы, 4-е
	    издание</emphasis>. – М.:Издательский дом <quote>Вильямс</quote>,
	    2002. – 848 с.: ил.
	  </listitem>
	</orderedlist>
      </para>
    </sect2>
    <sect2 id="intro-concepts-questions"><title>Вопросы</title><para><orderedlist><listitem><xref linkend="quest-1-1"/></listitem><listitem><xref linkend="quest-1-2"/></listitem><listitem><xref linkend="quest-1-3"/></listitem></orderedlist></para></sect2>
    <sect2 id="intro-concepts-presentaions"><title>Презентация</title><para><figure id="small-pres-1-01" float="0"><title>Презентация 1-01: обзор компьютерных систем</title><graphic fileref="pres/small-lect1-01.png"/></figure></para><para><figure id="small-pres-1-02" float="0"><title>Презентация 1-02: центральный процессор</title><graphic fileref="pres/small-lect1-02.png"/></figure></para><para><figure id="small-pres-1-03" float="0"><title>Презентация 1-03: память</title><graphic fileref="pres/small-lect1-03.png"/></figure></para><para><figure id="small-pres-1-04" float="0"><title>Презентация 1-04: управление вводом-выводом</title><graphic fileref="pres/small-lect1-04.png"/></figure></para><para><figure id="small-pres-1-05" float="0"><title>Презентация 1-05: Операционная система</title><graphic fileref="pres/small-lect1-05.png"/></figure></para><para><figure id="small-pres-1-06" float="0"><title>Презентация 1-06: виртуальная машина</title><graphic fileref="pres/small-lect1-06.png"/></figure></para><para><figure id="small-pres-1-07" float="0"><title>Презентация 1-07: управлнение ресурсами</title><graphic fileref="pres/small-lect1-07.png"/></figure></para><para><figure id="small-pres-1-08" float="0"><title>Презентация 1-08: архитектура операционной системы</title><graphic fileref="pres/small-lect1-08.png"/></figure></para><para><figure id="small-pres-1-09" float="0"><title>Презентация 1-09: монолитное ядро</title><graphic fileref="pres/small-lect1-09.png"/></figure></para><para><figure id="small-pres-1-10" float="0"><title>Презентация 1-10: микроядро</title><graphic fileref="pres/small-lect1-10.png"/></figure></para><para><figure id="small-pres-1-11" float="0"><title>Презентация 1-11: история операционных систем</title><graphic fileref="pres/small-lect1-11.png"/></figure></para><para><figure id="small-pres-1-12" float="0"><title>Презентация 1-12: классификация операционных систем</title><graphic fileref="pres/small-lect1-12.png"/></figure></para><para><figure id="small-pres-1-13" float="0"><title>Презентация 1-13: резюме</title><graphic fileref="pres/small-lect1-13.png"/></figure></para></sect2>
  </sect1>
  <!-- занятие №2 (лекция) -->
  <sect1 id="intro-unix">
    <title>Архитектура UNIX</title>
    <sect2 id="intro-unix-concepts">
      <title>Особенности архитектуры UNIX</title>
      <para><link linkend="small-pres-2-01">Презентация 2-01: основные концепции UNIX</link></para>
      <para>
	Знакомство с архитектурой UNIX начнем с рассмотрения таких неотъемлимых для неё
	характеристических понятий, как <emphasis>стандартизация</emphasis>
	и <emphasis>многозадачность</emphasis>:
      </para>
      <para>
	<variablelist>
	  <varlistentry>
	    <term>Стандартизация</term>
	    <listitem>
              <para>
		Несмотря на многообразие версий UNIX, основой всего семейства являются
		принципиально одинаковая архитектура и ряд стандартных интерфейсов (в UNIX
		стандартизовано почти всё – от расположения системных папок и
		файлов, до интерфейса системных вызовов и списка драйверов базовых
		устройств). Опытный администратор без особого труда сможет обслуживать
		другую версию, тогда как для пользователей переход на другую систему и вовсе
		может оказаться незаметным. Для системных же программистов такого рода
		стандарты позволяют полностью сосредоточиться на программировании, не тратя
		время на изучение архитектуры и особенностей конкретной реализации системы.
              </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>Многозадачность</term>
	    <listitem>
              <para>
		В системе UNIX может одновременно выполняться множество процессов (задач),
		причем их число логически не ограничивается, и множество частей одной
		программы может одновременно находиться в системе. Благодаря специальному
		механизму управления памятью, каждый процесс развивается в своем защищенном
		адресном пространстве, что гарантирует безопасность и независимость от
		других процессов. Различные системные операции позволяют процессам порождать
		новые процессы, завершают процессы, синхронизируют выполнение этапов
		процесса и управляют реакцией на наступление различных событий.
              </para>
	    </listitem>
	  </varlistentry>
	</variablelist>      
      </para>
      <sect3 id="intro-unix-concepts-fp">
	<title>Два кита UNIX: файлы и процессы</title>    
	<phrase id="quest-2-1" xreflabel="В чём заключается особенность архитектуры UNIX?"/>
	<para>
	  Существует два основных объекта операционной системы UNIX, с которыми приходиться
	  работать пользователю – <emphasis>файлы</emphasis>
	  и <emphasis>процессы</emphasis>. Эти объекты сильно связаны друг с другом, и в
	  целом организация работы с ними как раз и определяет архитектуру операционной
	  системы.
	</para>
	<para>
	  Все данные пользователя храняться в <emphasis id="def-unix-file" xreflabel="файл">файлах</emphasis>; доступ к периферийным устройствам
	  осуществляется посредством чтения и записи специальных файлов; во время
	  выполнения программы, операционная система считывает исполняемый код из файла в
	  память и передает ему управление.
	</para>  
	<para>
	  С другой стороны, вся функциональность операционная определяется выполнением
	  соответствующих <emphasis id="def-unix-process" xreflabel="процесс">процессов</emphasis>. В частности, обращение к файлам на диске
	  невозможно, если файловая подсистема операционной системы (совокупность
	  процессов, осуществляющих доступ к файлам) не имеет необходимого для этого кода
	  в памяти.
	</para>
      </sect3>
      <sect3 id="intro-unix-concepts-arch">
	<title>Беглый взгляд на архитектуру UNIX</title>    
	<para><link linkend="small-pres-2-02">Презентация 2-02: беглый взгляд на архитектуру UNIX</link></para>
	<para>
	  Самый общий взляд на архитектуру UNIX позволяет
	  увидеть <emphasis id="def-unix-two-levels" xreflabel="двухуровневая модель    системы">двухуровневую модель системы</emphasis>, состоящую
	  из <emphasis>пользовательской</emphasis> и <emphasis>системной части
	  (ядра)</emphasis> (см. <xref linkend="img-unix-arch"/>). Ядро непосредственно
	  взаимодействует с аппаратной частью компьютера, изолируя прикладные программы
	  (процессы в пользовательской части операционной системы) от особенностей ее
	  архитектуры. Ядро имеет набор услуг, предоставляемых прикладным программам
	  посредством системных вызовов. Таким образом, в системе можно выделить два
	  уровня привилегий: <emphasis>уровень системы</emphasis> (привиегии специального
	  пользователя root) и <emphasis>уровень пользователя</emphasis> (привилегии всех
	  остальных пользователей). Подробнее об управлении доступом рассказывается в
	  следующих главах (<xref linkend="chapter-security"/>).
	</para>
	<para>
	  <figure id="img-unix-arch" float="0">
	    <title>Архитектура операционной системы UNIX</title>
	    <graphic fileref="images/unix_arch.png"/>
	  </figure>
	</para>
	<phrase id="quest-2-2" xreflabel="Какие программы называют демонами? Приведите&#10;&#9;примеры."/>
      	<para>
	  Важной частью системных программ являются <emphasis id="def-daemon" xreflabel="демон">демоны</emphasis>. Демон – это процесс, выполняющий
	  опеределенную функцию в системе, который запускается при старте системы и не
	  связан ни с одним пользовательским терминалом. Демоны предоставляют
	  пользователям определенные сервисы, примерами которых могут служить системный
	  журнал, веб-сервер и т.п.. Аналогом демонов в операционной системе Windows NT и
	  более поздних версиях являются <emphasis>системные службы</emphasis>.
	</para>
      </sect3>
      <sect3 id="intro-unix-concepts-kernel">
	<title>Ядро UNIX</title>
	<para><link linkend="small-pres-2-03">Презентация 2-03: ядро UNIX</link></para>
	<phrase id="quest-2-3" xreflabel="Из каких частей состоит ядро UNIX?"/>
	<para>
	  Операционная система UNIX обладает классическим монолитным ядром
	  (см. <xref linkend="intro-concepts-arch"/>), в котором можно выделить следующие
	  основные части:
	  <variablelist>
	    <varlistentry>
	      <term>Файловая подсистема</term>
	      <listitem>
		<para>
		  Доступ к структурам ядра осуществляется через файловый
		  интерфейс.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Управление процессами</term>
	      <listitem>
		<para>
		  Сюда входит управление параллельным выполнением процессов (планирование
		  и диспетчеризация), виртуальной памятью процесса, и взаимодействием
		  между процессами (сигналы, очереди сообщений и т.п.). 
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Драйверы устройств</term>
	      <listitem>
		<para>
		  Драйверы устройств делятся на символьные и блочные по типу внешнего
		  устройства. Для каждого из устройств определен набор возможных операций
		  (открытие, чтение и т.д.). Блочные устройства кэшируются с помощью
		  специального внутреннего механизма управления буферами.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
	<para>
	  <figure id="img-unix-kernel" float="0">
	    <title>Ядро операционной системы UNIX</title>
	    <graphic fileref="images/unix_kernel.png"/>
	  </figure>
	</para>
	<para>
	  Благодаря тому, что в UNIX аппаратно-независимая
	  часть явно отделена, это семейство операционных систем может быть с минимальными
	  затратами перенесено на новые аппаратные платформы.
	</para>
	<para>
	  Видно, что ядро операционной системы UNIX является классическим для многозадачной
	  многопользовательской операционной системы, поэтому оно широко используется в
	  обучении системному программированию и теории операционных систем.
	</para>
      </sect3>
    </sect2>
    <sect2 id="intro-unix-files">
      <title>Файловая система UNIX</title>
      <para>
        Термин <emphasis id="def-fs" xreflabel="файловая система">файловая система</emphasis> по историческим
        причинам обозначает одновременно и иерархию каталогов и файлов, и часть ядра,
        управляющую доступом к каталогам и файлам.
      </para>
      <sect3 id="intro-unix-files-fs">
	<title>Особенности файловой системы</title>    
	<para><link linkend="small-pres-2-04">Презентация 2-04: файловая система UNIX</link></para>
	<phrase id="quest-2-4" xreflabel="Какими отличительными особенностями обладает файловая&#10;&#9;система UNIX?"/>
	<para> 
          <emphasis>Первое</emphasis> значение термина упирается в рассмотрение структур, в
          которые могут быть организованы файлы на носителях данных. Существует несколько
          видов таких структур: линейные, древовидные, объектные и другие, но в
          настоящее время широко распространены только древовидные структуры.
	</para>
	<para> Каджый файл в древовидной структуре расположен в определенном хранилище
	  файлов – <emphasis id="def-directory" xreflabel="каталог">каталоге</emphasis>, каждый каталог, в свою очередь, также
	  расположен в некотором каталоге. Таким образом, по принципу вложения элементов
	  файловой системы (файлов и каталогов) друг в друга строится дерево, вершинами
	  которого являются непустые каталоги, а листьями – файлы или пустые
	  каталоги. Корень такого дерева имеет
	  название <emphasis id="def-root-dir" xreflabel="корневой каталог">корневой каталог</emphasis> и
	  обозначается каким-либо специальным символом или группой символов
	  (например, <quote>C:</quote> в операционной системе Windows). Каждому файлу
	  соответствует некоторое <emphasis id="def-file-name" xreflabel="имя    файла">имя</emphasis>, отпределяющее его расположение в дереве файловой
	  системы. Полное имя файла состоит из имен всех вершин дерева файловой системы,
	  через которые можно пройти от корня до данного файла (каталога), записывая их
	  слева-направо и разделяя специальными символами-разделителями.
	</para> 
	<para> В настоящее время существует огромное количество файловых систем, каждая из
          которых используется для определенной цели: для быстрого доступа к данным, для
          обеспечения целостности данных при сбоях системы, для простоты реализации, для
          компактного хранения данных, и т.д. Однако среди всего множества файловых систем
          можно выделить такие, которые обладают рядом схожих признаков, а именно:
	</para>
	<para>
	  <itemizedlist>
            <listitem>
	      <para><link linkend="small-pres-2-05">Презентация 2-05: индексный узел</link></para>
	      <para>
		Файлы и каталоги идентифицируются не по именам, а
		по <emphasis id="def-index-node" xreflabel="индексный узел">индексным
		узлам</emphasis> (i-node) – индексам в общем массиве файлов
		для данной файловой системе. В этом массиве хранится информация об
		используемых блоках данных на носителе, а также – длина файла,
		владелец файла, права доступа и другая служебная информация под общим
		названием <quote>метаданные о файле</quote>. Логические же связки
		типа <quote>имя–i-node</quote> – есть ни что иное как
		содержимое каталогов.
	      </para>
	      <para>
		Таким образом, каждый файл характеризуется одним
		i-node, но может быть связан с несколькими именами – в UNIX это
		называют <emphasis id="def-hard-link" xreflabel="жёсткая ссылка">жёсткими
		ссылками</emphasis> (см. <xref linkend="img-hard-link"/>).
		При этом, удаление файла происходит тогда, когда удаляется последняя
		жёсткая ссылка на этот файл.
	      </para>
	      <para>
		<figure id="img-hard-link" float="0">
		  <title>Пример жесткой ссылки</title>
		  <graphic fileref="images/hard_link.png"/>
		</figure>
	      </para>
	      <para>
		Важной особенностью таких файловых систем является то, что имена файлов
		зависят от регистра, другими словами файлы <filename moreinfo="none">test.txt</filename>
		и <filename moreinfo="none">TEST.txt</filename> отличаются (т.е. являются разными строками
		в файле директории).
	      </para>
	    </listitem>
            <listitem>
	      <para> В определенных (фиксированных для данной файловой системы) блоках
		физического носителя данных находится
		т.н. <emphasis id="def-superblock" xreflabel="суперблок">суперблок</emphasis>. Суперблок – это
		наиболее ответственная область файловой системы, содержащая информацию для
		работы файловой системы в целом, а также – для ёе
		идентификации. В суперблоке находится
		<quote>магическое число</quote> – идентификатор файловой
		системы, отличающий её от других файловых систем, список свободных блоков,
		список свободных i-node'ов и некоторая другая служебная информация.
              </para>
	    </listitem>
	    <phrase id="quest-2-5" xreflabel="Назовите типы файлов в UNIX. В чём все они схожи,&#10;&#9;    каковы отличия между ними?"/>
            <listitem>
	      <para>
		Помимо <emphasis>каталогов</emphasis> и <emphasis>обычных файлов</emphasis>
		для хранения информации, ФС может содержать следующие виды файлов:
		<variablelist>
		  <varlistentry>
		    <term>Специальный <emphasis id="def-device-file" xreflabel="файл&#10;&#9;&#9;    устройства">файл
		    устройства</emphasis></term>
		    <listitem>  
		      <para>
			Обеспечивает доступ к физическому устройству. При создании такого
			устройства указывается тип устройства (блочное или
			символьное), <emphasis>старший номер</emphasis> – индекс
			драйвера в таблице драйверов операционной системы и <emphasis>младший
			  номер</emphasis> – параметр, передаваемый драйверу,
			поддерживающему несколько устройств, для уточнения о каком
			<quote>подустройстве</quote> идет речь (например, о каком из
			нескольких IDE-устройств или COM-портов).
		      </para>
		    </listitem> 
		  </varlistentry>
		  <varlistentry>
		    <term><emphasis id="def-named-pipe" xreflabel="именованый       канал">Именованный канал</emphasis></term>
		    <listitem>  
		      <para>
			Используется для передачи данных между процессами, работает по
			принципу двунаправленной очереди
			(<acronym>FIFO</acronym>). Является одним из способов обмена между
			изолированными процессами (подробнее
			см. <xref linkend="intro-unix-proc-interproc"/>).
		      </para>         
		    </listitem>             
		  </varlistentry>
		  <varlistentry>
		    <term><emphasis id="def-sym-link" xreflabel="символическая       ссылка">Символическая ссылка</emphasis></term>
		    <phrase id="quest-2-6" xreflabel="Чем жёсткие ссылки отличаются от&#10;&#9;&#9;    символических? Какими преимуществами обладают символические&#10;&#9;&#9;    ссылки?"/>
		    <listitem>
		      <para>
			Особый тип файла, содержимое которого – не данные, а
			имя какого-либо другого файла
			(см. <xref linkend="img-sym-link"/>. Для пользователя такой файл
			неотличим от того, на который он ссылается.
		      </para>
		      <para>
			Символическая ссылка имеет ряд преимуществ по сравнению с жёсткой
			ссылкой: она может использоваться для связи файлов в разных
			файловых системах (ведь номера индексных узлов уникальны только в
			рамках одной файловой системы), а также более прозрачно удаление
			файлов – ссылка может удаляться совершенно независимо
			от отсновного файла.
		      </para>
		      <para>
			<figure id="img-sym-link" float="0">
			  <title>Пример символической ссылки</title>
			  <graphic fileref="images/symbolic_link.png"/>
			</figure>
		      </para>
		    </listitem>     
		  </varlistentry>
		  <varlistentry>
		    <term><emphasis id="def-fs-socket" xreflabel="сокет">Сокет</emphasis></term>
		    <listitem><para>
			Предназначен для взаимодействия между процессами через специальное
			API, схожее с TCP/IP-сокетеми (подробнее
			см. <xref linkend="intro-unix-proc-interproc"/>).
		      </para>                
		    </listitem>
		  </varlistentry>
		</variablelist>
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>	  
	<para>
	  Такие файловые системы наследуют особенности оригинального UNIX. К ним можно
	  отнести, например: s5 (используемая в версиях UNIX System V), ufs (BSD UNIX),
	  ext2, ext3, reiserfs (Linux), qnxfs (QNX). Все эти файловые системы различаются
	  форматами внутренних структур, но совместимы с точки зрения основных концепций.
	</para>
      </sect3>
      <sect3 id="intro-unix-files-processors">
	<title>Дерево каталогов</title>
	<para><link linkend="small-pres-2-06">Презентация 2-06: монтирование файловых систем</link></para>
	<para>
	  Рассмотрение <emphasis>второго</emphasis> значения термина ФС приводит нас к уже
	  обозначенной ранее совокупности процедур, осуществляющих доступ к файлам на
	  различных носителях. Особенностью операционных систем семейства UNIX является
	  существование единого дерева файловой системы для любого количества носителей
	  данных с одинаковыми или разными типами файловых систем на них. Это достигается
	  путем <emphasis id="def-mount" xreflabel="монтирование">монтирования</emphasis> – временной
	  подстановкой вместо каталога одной файловой системы дерева другой файловой
	  системы, вследствие чего система имеет не несколько деревьев никак не связанных
	  друг с другом, а одно большое разветвленное дерево с единым корневым
	  каталогом.
	</para>
	<para>
	  Файловая подсистема операционной системы UNIX имеет имеет уникальную систему
	  обработки запросов к файлам – <emphasis>переключатель файловых
	  систем</emphasis> или <emphasis id="def-vfs" xreflabel="виртуальная файловая&#10;&#9;  система">виртуальная файловая
	  система</emphasis> (<acronym>VFS</acronym>). <acronym>VFS</acronym>
	  предоставляет пользователю стандартный набор функций (интерфейс) для работы с
	  файлами, вне зависимости от места их расположения и принадлежности к разным
	  файловым системам.
	</para>
	<para>
          В мире стандартов UNIX определено, что корневой каталог единого дерева файловой
          системы должен иметь имя <filename moreinfo="none">/</filename>, как и символ-разделитель при
          формировании полного имени файла. Тогда полное имя файла может быть, например,
          <filename moreinfo="none">/usr/share/doc/bzip2/README</filename>. Задача VFS – по
          полному имени файла найти его местоположение в дереве файловой системы,
          определить её тип в этом месте дерева и <quote>переключить</quote>,
          т.е. передать файл на дальнейшую обработку драйверу конктретной файловой
          системы. Такой подход позволяет использовать практически неограниченое
          количество различных файловых систем на одном компьютере под управлением одной
          операционной системы, а пользователь даже не будет знать, что файлы физически
          находятся на разных носителях информации.
	</para>
	<para> Использование общепринятых имен основных файлов и структуры каталогов
          существенно облегчает работу в операционной системе, её администрирование и
          переносимость. Некоторые из этих структур используются при запуске системы,
          некоторые – во время работы, но все они имеют большое значение для ОС
          вцелом, а нарушение этой структуры может привести к неработоспособности системы
          или ее отдельных компонентов.
	</para>
	<para>
          <figure float="0">
            <title>Стандартные каталоги в файловой системе UNIX</title>
            <graphic fileref="images/unix_filesystem.png"/>
          </figure>
	</para>  
	<para><link linkend="small-pres-2-07">Презентация 2-07: стандарт на файловую систему</link></para>
	<phrase id="quest-2-7" xreflabel="Какие каталоги стандартизованы в UNIX? Что обычно &#10;&#9;  хранится в каждом из них?"/>
	<para>Приведем краткое описание основных каталогов системы, формально описываемых
          специальным стандартом на <emphasis id="def-fs-hierarchy" xreflabel="иерархия           файловой системы">иерархию файловой системы</emphasis> (Filesystem Hierarchy
          Standart). Все каталоги можно разделить на две группы: для статической (редко
          меняющейся)
          информации – <filename moreinfo="none">/bin</filename>, <filename moreinfo="none">/usr</filename> и
          динамической (часто меняющейся)
          информации – <filename moreinfo="none">/var</filename>, <filename moreinfo="none">/tmp</filename>.
	  Исходя из этого администраторы могут разместить каждый из этих каталогов на
          собственном носителе, обладающем соответствующими характеристиками.
	  <variablelist>
	    <varlistentry>
	      <term>Корневой каталог</term>
	      <listitem> 
                <para>
		  Корневой каталог <filename moreinfo="none">/</filename> является основой любой ФС
		  UNIX. Все остальные каталоги и файлы располагаются в рамках струтуры
		  (дерева), порождённой корневым каталогом, независимо от их физического
		  местонахождения.
		</para>                
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename moreinfo="none">/bin</filename></term>
	      <listitem>
		<para>
		  В этом каталоге находятся часто употребляемые команды и утилиты
		  системы общего пользования. Сюда входят все базовые команды, доступные
		  даже если была примонтирована только корневая файловая система. Примерами
		  таких команд являются: <command moreinfo="none">ls</command>, <command moreinfo="none">cp</command>,
		  <command moreinfo="none">sh</command> и т.п..
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename moreinfo="none">/boot</filename></term>
	      <listitem>
		<para>
		  Директория содержит всё необходимое для процесса загрузки операционной
		  системы: программу-загрузчик, образ ядра операционной системы и т.п..
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename moreinfo="none">/dev</filename></term>
	      <listitem> 
		<para>
		  Каталог содержит специальные файлы устройств, являющиеся интерфейсом
		  доступа к периферийным устройствам. Наличие такого каталога не означает,
		  что специальные файлы устройств нельзя создавать в другом месте, просто
		  достаточно удобно иметь один каталог для всех файлов такого типа.
		</para>                
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename moreinfo="none">/etc</filename></term>
	      <listitem> 
		<para>
		  В этом каталоге находятся системные конфигурационные файлы. В качестве
		  примеров можно привести файлы <filename moreinfo="none">/etc/fstab</filename>,
		  содержащий список монтируемых файловых систем,
		  и <filename moreinfo="none">/etc/resolv.conf</filename>, который задаёт правила
		  составления локальных DNS-запросов. Среди наиболее
		  важных файлов – скрипты инифиализации и деинициализации
		  системы. В системах, наследующих особенности UNIX System V, для них
		  отведены каталоги с <filename moreinfo="none">/etc/rc0.d</filename> по
		  <filename moreinfo="none">/etc/rc6.d</filename> и общий для всех файл описания –
		  <filename moreinfo="none">/etc/inittab</filename>.
		</para>                
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename moreinfo="none">/home</filename> (необязательно)</term>
	      <listitem> 
		<para>
		  Директория содержит домашние директории пользователей. Её существование
		  в корневом каталоге не обязательно и её содержимое зависит от
		  особенностей конкретной UNIX-подобной операционной системы.
		</para>                
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename moreinfo="none">/lib</filename></term>
	      <listitem> 
		<para>
		  Каталог для статических и динамических библиотек, необходимых для
		  запуска программ, находящихся в директориях <filename moreinfo="none">/bin</filename>
		  и <filename moreinfo="none">/sbin</filename>. 
		</para>                
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename moreinfo="none">/mnt</filename></term>
	      <listitem> 
		<para>
		  Стандартный каталог для временного монтирования файловых
		  систем – например, гибких и флэш-дисков, компакт-дисков и т.п..
		</para>                
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename moreinfo="none">/root</filename> (необязательно)</term>
	      <listitem> 
		<para>
		  Директория содержит домашюю директорию суперпользователя. Её
		  существование в корневом каталоге не обязательно.
		</para>                
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename moreinfo="none">/sbin</filename></term>
	      <listitem>
		<para>
		  В этом каталоге находятся команды и утилиты для системного
		  администратора. Примерами таких команд
		  являются: <command moreinfo="none">route</command>, <command moreinfo="none">halt</command>,
		  <command moreinfo="none">init</command> и т.п.. Для аналогичных целей применяются
		  директории <filename moreinfo="none">/usr/sbin</filename>
		  и <filename moreinfo="none">/usr/local/sbin</filename>. 
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename moreinfo="none">/usr</filename></term>
	      <listitem>
		<para>
		  Эта директория повторяет структуру корневой директории –
		  содержит
		  каталоги <filename moreinfo="none">/usr/bin</filename>, <filename moreinfo="none">/usr/lib</filename>,
		  <filename moreinfo="none">/usr/sbin</filename>, служащие для аналогичных целей.
		</para>
		<para>
		  Каталог <filename moreinfo="none">/usr/include</filename> содержит заголовочные файлы
		  языка C для всевозможные библиотек, расположенных в системе.
		</para>
		<para>
		  Каталог <filename moreinfo="none">/usr/local</filename> является следующим уровнем
		  повторения корневого каталога и служит для хранения программ,
		  установленных администратором в дополнение к стандартной поставке
		  операционной системы.
		</para>
		<para>
		  Каталог <filename moreinfo="none">/usr/share</filename> хранит неизменяющиеся данные для
		  установленных программ. Особый интерес представляет
		  каталог <filename moreinfo="none">/usr/share/doc</filename>, в который добавляется
		  документация ко всем установленным программам.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><filename moreinfo="none">/var</filename>, <filename moreinfo="none">/tmp</filename></term>
	      <listitem> 
		<para> Используются для хранения временных данных процессов –
		  системных и пользовательских соответственно.
		</para>                
	      </listitem>
	    </varlistentry>
	  </variablelist>	    
	</para>
      </sect3>            
    </sect2>      
    <sect2 id="intro-unix-proc">
      <title>Управление процессами</title>
      <para><link linkend="small-pres-2-08">Презентация 2-08: контекст процесса</link></para>
      <para>
	В операционной системе UNIX традиционно поддерживается классическая схема
	мультипрограммирования. Система поддерживает возможность параллельного (или
	псевдопараллельного в случае наличия только одного аппаратного процессора)
	выполнения нескольких пользовательских программ. Каждому такому выполнению
	соответствует процесс операционной системы. Каждый процесс выполняется в
	собственной виртуальной памяти, и, тем самым, процессы защищены один от другого,
	т.е. один процесс не в состоянии неконтроллируемым образом прочитать что-либо из
	памяти другого процесса или записать в нее.
      </para>
      <sect3 id="intro-unix-proc-context">
	<title>Контекст процесса</title>
	<phrase id="quest-2-8" xreflabel="Что такое контекст процесса? Из чего состоит контекст&#10;&#9;  процесса в UNIX?"/>
	<para>
	  Каждому процессу соответствует <emphasis id="def-process-context" xreflabel="контекст процесса">контекст</emphasis>, в котором он выполняется. Этот
	  контекст включает содержимое пользовательского адресного
	  пространства – пользовательский контекст (т.е. содержимое сегментов
	  программного кода, данных, стека, разделяемых сегментов и сегментов файлов,
	  отображаемых в виртуальную память), содержимое аппаратных регистров –
	  регистровый контекст (регистр счетчика команд, регистр состояния процессора,
	  регистр указателя стека и регистры общего назначения), а также структуры данных
	  ядра (контекст системного уровня), связанные с этим процессом. Контекст процесса
	  системного уровня в ОС UNIX состоит из <quote>статической</quote>
	  и <quote>динамических</quote> частей. Для каждого процесса имеется одна
	  статическая часть контекста системного уровня и переменное число динамических
	  частей.
	</para>
	<para>
	  Статическая часть контекста процесса системного уровня включает следующее:
	</para>
	<para>
	  <variablelist>
	    <varlistentry>
	      <term><emphasis id="def-pid" xreflabel="идентификатор процесса">Идентификатор
		  процесса (PID)</emphasis></term>
	      <listitem>
		<para>
		  Уникальный номер, идентифицирующий процесс. По сути, это номер строки в
		  таблице процессов – специальной внутренней структуре ядра
		  операционной системы, хранящей информацию о процессах.
		</para>
		<para>
		  В любой момент времени номера запущенных в ситеме процессов отличаются,
		  однако после завершения процесса, его номер может быть в дальнейшем
		  использован для идентификации вновь запущенного процесса.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis id="def-parent-process" xreflabel="родительский        процесс">Идентификатор родительского процесса
	      (PPID)</emphasis></term>
	      <listitem>
		<para>
		  В операционнной системе UNIX процессы выстраиваются
		  в <emphasis>иерархию</emphasis> – новый процесс может быть
		  создан в рамках текущего, который выступает для него родительским.
		</para>
		<para>
		  Таким образом, можно построить дерево из процессов, в вершине которого
		  находится <emphasis id="def-init-process" xreflabel="процесс init">процесс init</emphasis>,
		  запускающийся при старте системы и являющийся прародителем для всех
		  системных процессов. Подробнее об этом процессе сказано в разделе
		  <xref linkend="base-admin-lect-sysinit-init"/>. 
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis id="def-process-state" xreflabel="состояние процесса">Состояние
		  процесса</emphasis></term>
	      <listitem>
		<para>
		  Каждый процесс может находиться в одном из возможных состояний:
		  инициализация, исполнение, приостановка, ожидание ввода-вывода, завершение
		  и т.п. (см. <xref linkend="img-process-states"/>).
		</para>
		<para>
		  <figure id="img-process-states" float="0">
		    <title>Состояния процесса в UNIX</title>
		    <graphic fileref="images/process_states.png"/>
		  </figure>
		</para>
		<para>
		  Большинство этих состояний совпадает с классическим набором состояний
		  процессов в многозадачных операционных системах. Для операционной
		  системы UNIX характерно особое состояние процесса –
		  <emphasis id="def-zombie" xreflabel="зомби">зомби</emphasis>. Это состояние имеет
		  завершившийся процесс, родительский процесс которого еще не закончил
		  работу, и служит для корректного завершния группы процессов,
		  освобождения ресурсов и т.п..
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Идентификаторы пользователя</term>
	      <listitem>
		<para>
		  Идентификатор пользователя и группы, от имени которых исполняется
		  процесс. Подробнее о безопасности будет сказано в главе
		  <xref linkend="chapter-security"/>.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis id="def-process-prio" xreflabel="приоритет процесса">Приоритет
		  процесса</emphasis></term>
	      <listitem>
		<para>
		  Число, используемое при <emphasis>планировании</emphasis>
		  (см. <xref linkend="intro-unix-proc-schedule"/>) исполнения процесса в
		  операционной системе. Традиционное решение операционной системы UNIX
		  состоит в использовании динамически изменяющихся приоритетов. Каждый
		  процесс при своем образовании получает некоторый устанавливаемый
		  системой статический приоритет, который в дальнейшем может быть изменен
		  с помощью системного вызова <function moreinfo="none">nice</function>. Этот статический
		  приоритет является основой начального значения динамического приоритета
		  процесса, являющегося реальным критерием планирования. Все процессы с
		  динамическим приоритетом не ниже порогового участвуют в конкуренции за
		  процессор.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Таблица дескрипторов открытых файлов</term>
	      <listitem>
		<para>
		  Список структур ядра, описывающий все файлы, открытые этим процессом для
		  ввода-вывода.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Другая информация, связанная с процессом</term>
	      <listitem><para/></listitem>
	    </varlistentry>
	  </variablelist>
	</para>
	<para>
	  Динамическая часть контекста процесса – это один или несколько стеков,
	  которые используются процессом при его выполнении в режиме ядра. Число ядерных
	  стеков процесса соответствует числу уровней прерывания, поддерживаемых конкретной
	  аппаратурой.
	</para>
      </sect3>
      <sect3 id="intro-unix-proc-schedule">
	<title>Планирование процессов</title>
	<para><link linkend="small-pres-2-09">Презентация 2-09: планирование процессов</link></para>
	<phrase id="quest-2-9" xreflabel="Что такоае планирование и диспетчеризация процессов?&#10;&#9;Какие в UNIX применяются алгоритмы планирования?"/>
	<para>
	  Основной проблемой организации многопользовательского (правильнее сказать,
	  мультипрограммного) режима в любой операционной системе является организация
	  <emphasis id="def-scheduling" xreflabel="планирование">планирования</emphasis> <quote>параллельного</quote>
	  выполнения нескольких процессов. Операционная система должна обладать четкими
	  критериями для определения того, какому готовому к выполнению процессу и когда
	  предоставить ресурс процессора.
	</para>
	<para>
	  Наиболее распространенным алгоритмом планирования в системах разделения времени
	  является <emphasis id="def-round-robin" xreflabel="Round Robin">кольцевой
	  режим</emphasis> (Round Robin). Основной смысл алгоритма состоит в том, что
	  время процессора делится на кванты фиксированного размера, а процессы, готовые к
	  выполнению, выстраиваются в кольцевую очередь
	  (см. <xref linkend="img-round-robin"/>). У этой очереди имеются два
	  указателя – начала и конца. Когда процесс, выполняющийся на
	  процессоре, исчерпывает свой квант процессорного времени, он снимается с
	  процессора, ставится в конец очереди, а ресурсы процессора отдаются процессу,
	  находящемуся в начале очереди. Если выполняющийся на процессоре процесс
	  откладывается (например, по причине обмена с некоторым внешнем устройством) до
	  того, как он исчерпает свой квант, то после повторной активизации он становится
	  в конец очереди (не смог доработать - не вина системы). Это прекрасная схема
	  разделения времени в случае, когда все процессы одновременно помещаются в
	  оперативной памяти.
	</para>
	<para>
	  <figure id="img-round-robin" float="0">
	    <title>Схема планирования с кольцевой очередью</title>
	    <graphic fileref="images/scheduling.png"/>
	  </figure>
	</para>
	<para>
	  Однако операционная система UNIX всегда была рассчитана на то, чтобы обслуживать
	  больше процессов, чем можно одновременно разместить в основной памяти. Другими
	  словами, часть процессов, потенциально готовых выполняться, размещалась во
	  внешней памяти (куда образ памяти процесса попадал в результате
	  своппинга). Поэтому требовалась несколько более гибкая схема планирования
	  разделения ресурсов процессора(ов). В результате было введено понятие приоритета
	  (см. <xref linkend="img-round-robin-prio"/>). В операционной системе UNIX значение
	  приоритета определяет, во-первых, возможность процесса пребывать в основной
	  памяти и на равных конкурировать за процессор. Во-вторых, от значения приоритета
	  процесса, вообще говоря, зависит размер временного кванта, который
	  предоставляется процессу для работы на процессоре при достижении своей
	  очереди. В-третьих, значение приоритета, влияет на место процесса в общей
	  очереди процессов к ресурсу процессора.
	</para>
	<para>
	  <figure id="img-round-robin-prio" float="0">
	    <title>Схема планирования с кольцевой очередью и приоритетами</title>
	    <graphic fileref="images/scheduling_prio.png"/>
	  </figure>
	</para>
      </sect3>
      <sect3 id="intro-unix-proc-interproc">
	<title>Межпроцессное взаимодействие</title>
	<para><link linkend="small-pres-2-10">Презентация 2-10: межпроцессное взаимодействие</link></para>
	<phrase id="quest-2-10" xreflabel="Какие средства межпроцессного обмена предоставляются в&#10;&#9;UNIX?"/>
	<para>
	  Полная изоляция процессов в операционной системе бессмысленна, так как им частно
	  необходимо обмениваться данными в процессе работы.  Операционной системой
	  допускаются контролируемые взаимодействия процессов, в том числе за счет
	  возможности разделения одного сегмента памяти между виртуальной памятью
	  нескольких процессов.  Для решения
	  задачи <emphasis id="def-interprocess-communication" xreflabel="межпроцессное    взаимодействие">межпроцессного взаимодействия</emphasis> в операционной
	  системе существует набор специальных средств:
	</para>
	<para>
	  <variablelist>
	    <varlistentry>
	      <term><emphasis id="def-stdio" xreflabel="стандартный ввод-вывод">Стандартные
		  потоки ввода-вывода</emphasis></term>
	      <listitem>
		<para>
		  По умолчанию каждому процессу при запуске ставится в соответствие три
		  открытых файла: стандартного ввода, стандартного вывода и стандартного
		  вывода ошибок. С помощью средств командной строки (см. подробнее в
		  <xref linkend="chapter-shell"/>) такие потоки для разных процессов могут
		  быть объединены так, что, к примеру, вывод одного процесса будет
		  подаваться на ввод другого. В более общем смысле такие потоки называют
		  <emphasis id="def-anonymous-pipe" xreflabel="неименованный     канал">неименованными каналами</emphasis>.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis id="def-shmem" xreflabel="разделяемая память">Разделяемая
	      память</emphasis></term>
	      <listitem>
		<para>
		  Специальный механизм, с помощью которого средствами операционной системы
		  два процесса могут обращаться к общему участку физической
		  памяти – каждый через свое адресное пространство.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis id="def-signal" xreflabel="сигнал">Сигналы</emphasis></term>
	      <listitem>
		<para>
		  Это способ информирования процесса со стороны ядра о происшествии
		  некоторого события. Смысл термина <quote>сигнал</quote> состоит в том,
		  что сколько бы однотипных событий в системе не произошло, по поводу
		  каждой такой группы событий процессу будет подан ровно один
		  сигнал. Т.е. сигнал означает, что определяемое им событие произошло, но
		  не несет информации о том, сколько именно произошло однотипных событий.
		  Сигналы могут инициироваться одними процессами по отношению к другим
		  процессам с помощью специального системного
		  вызова <function moreinfo="none">kill</function>.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Именованные каналы и сокеты</term>
	      <listitem>
		<para>
		  Специальные файлы, через которые может осуществляться обмен данными
		  между процессами.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>	  
      </sect3>
    </sect2>
    <sect2 id="intro-unix-summary">
      <title>Резюме</title>
      <para><link linkend="small-pres-2-11">Презентация 2-11: резюме</link></para>
      <para>
	Во второй лекции была рассмотрена архитектура операционной системы UNIX.
      </para>
      <para>
	Основными принципами операционной системы UNIX являются многозадачность и
	стандартизация. Пользователю приходиться работать с двумя основными объектами
	операционной системы: файлами и процессами.
      </para>
      <para>
	Операционную систему UNIX можно представить в виде трёх уровней: монолитное ядро,
	системные утилиты и демоны, пользовательские программы. Первые два работают на
	уровне привилегий системы, третий – на уровне пользователя.
      </para>
      <para>
	Все файловые системы семейства UNIX обладают схожей структурой. Основным элементом
	файловой системы является индексный узел, каталог связывает файл с именем. Помимо
	файлов и директорий существуют специальные виды файлов: устройства, каналы,
	символические ссылки и сокеты. Стандарт на файловую систему описывает основные
	директории иерархической файловой системы UNIX. Для объединения файловых систем
	нескольких устройств используется механизм монтирования.
      </para>
      <para>
	Каждый процесс в системе имеет уникальный идентификатор и состояние. Планирование
	исполнения процессов производится на основе динамических приоритетов. Для
	межпроцессного взяимодействия используются специальные средства, основными среди
	которых являются неименованные каналы и сигналы.
      </para>
      <para><emphasis>Ключевые термины: </emphasis><xref linkend="def-unix-file"/>, <xref linkend="def-unix-process"/>, <xref linkend="def-unix-two-levels"/>, <xref linkend="def-daemon"/>, <xref linkend="def-fs"/>, <xref linkend="def-directory"/>, <xref linkend="def-root-dir"/>, <xref linkend="def-file-name"/>, <xref linkend="def-index-node"/>, <xref linkend="def-hard-link"/>, <xref linkend="def-superblock"/>, <xref linkend="def-device-file"/>, <xref linkend="def-named-pipe"/>, <xref linkend="def-sym-link"/>, <xref linkend="def-fs-socket"/>, <xref linkend="def-mount"/>, <xref linkend="def-vfs"/>, <xref linkend="def-fs-hierarchy"/>, <xref linkend="def-process-context"/>, <xref linkend="def-pid"/>, <xref linkend="def-parent-process"/>, <xref linkend="def-init-process"/>, <xref linkend="def-process-state"/>, <xref linkend="def-zombie"/>, <xref linkend="def-process-prio"/>, <xref linkend="def-scheduling"/>, <xref linkend="def-round-robin"/>, <xref linkend="def-interprocess-communication"/>, <xref linkend="def-stdio"/>, <xref linkend="def-anonymous-pipe"/>, <xref linkend="def-shmem"/>, <xref linkend="def-signal"/></para>
    </sect2>    
    <sect2 id="intro-unix-additional">
      <title>Дополнительные материалы</title>
      <para>
	<orderedlist inheritnum="ignore" continuation="restarts">
	  <listitem>
	    Бах Дж.М. <emphasis>Архитектура операционной системы
	      UNIX</emphasis>. – <ulink url="http://www.opennet.ru/docs/RUS/unix/">
	      http://www.opennet.ru/docs/RUS/unix/</ulink>
	  </listitem>
	  <listitem>
	    Курячий Г.В. <emphasis>Операционная система UNIX</emphasis>. –
	    М.:Интуит.Ру, 2004. – 292 с.: ил.
	  </listitem>
	  <listitem>
	    Робачевский А.М. <emphasis>Операционная система UNIX</emphasis>. –
	    СПб.: БХВ-Петербург, 2002. – 528 с.: ил.
	  </listitem>
	  <listitem>
	    <emphasis>Стандарт на файловую систему</emphasis>. –
	    <ulink url="http://www.pathname.com/fhs/">http://www.pathname.com/fhs/</ulink>
	  </listitem>
	  <listitem>
	    Максвелл С. <emphasis>Ядро Linux в комментариях</emphasis>. –
	    К.: Издательство <quote>Диа-Софт</quote>, 2000. – 488 с.: ил.
	  </listitem>
	</orderedlist>
      </para>
    </sect2>    
    <sect2 id="intro-unix-question"><title>Вопросы</title><para><orderedlist><listitem><xref linkend="quest-2-1"/></listitem><listitem><xref linkend="quest-2-2"/></listitem><listitem><xref linkend="quest-2-3"/></listitem><listitem><xref linkend="quest-2-4"/></listitem><listitem><xref linkend="quest-2-5"/></listitem><listitem><xref linkend="quest-2-6"/></listitem><listitem><xref linkend="quest-2-7"/></listitem><listitem><xref linkend="quest-2-8"/></listitem><listitem><xref linkend="quest-2-9"/></listitem><listitem><xref linkend="quest-2-10"/></listitem></orderedlist></para></sect2>
    <sect2 id="intro-unix-presentaion"><title>Презентация</title><para><figure id="small-pres-2-01" float="0"><title>Презентация 2-01: основные концепции UNIX</title><graphic fileref="pres/small-lect2-01.png"/></figure></para><para><figure id="small-pres-2-02" float="0"><title>Презентация 2-02: беглый взгляд на архитектуру UNIX</title><graphic fileref="pres/small-lect2-02.png"/></figure></para><para><figure id="small-pres-2-03" float="0"><title>Презентация 2-03: ядро UNIX</title><graphic fileref="pres/small-lect2-03.png"/></figure></para><para><figure id="small-pres-2-04" float="0"><title>Презентация 2-04: файловая система UNIX</title><graphic fileref="pres/small-lect2-04.png"/></figure></para><para><figure id="small-pres-2-05" float="0"><title>Презентация 2-05: индексный узел</title><graphic fileref="pres/small-lect2-05.png"/></figure></para><para><figure id="small-pres-2-06" float="0"><title>Презентация 2-06: монтирование файловых систем</title><graphic fileref="pres/small-lect2-06.png"/></figure></para><para><figure id="small-pres-2-07" float="0"><title>Презентация 2-07: стандарт на файловую систему</title><graphic fileref="pres/small-lect2-07.png"/></figure></para><para><figure id="small-pres-2-08" float="0"><title>Презентация 2-08: контекст процесса</title><graphic fileref="pres/small-lect2-08.png"/></figure></para><para><figure id="small-pres-2-09" float="0"><title>Презентация 2-09: планирование процессов</title><graphic fileref="pres/small-lect2-09.png"/></figure></para><para><figure id="small-pres-2-10" float="0"><title>Презентация 2-10: межпроцессное взаимодействие</title><graphic fileref="pres/small-lect2-10.png"/></figure></para><para><figure id="small-pres-2-11" float="0"><title>Презентация 2-11: резюме</title><graphic fileref="pres/small-lect2-11.png"/></figure></para></sect2>
  </sect1>
</chapter>

  
<chapter id="chapter-shell">
  <title>Коммандная строка UNIX</title>
  <para>
    Операционная система предоставляет пользователю специальный интерфейс –
    <emphasis>командную строку</emphasis>, через которую пользователи получают
    персональную рабочую среду. Несмотря на то, что в современных UNIX-системах широко
    используются графические пользовательские интерфейсы, командная строка остаётся
    основным рабочим инструментом администратора системы.
  </para>
  <!-- занятие №3 (лекция) -->
  <sect1 id="shell-base">
    <title>Терминал и командная строка</title>
    <para><link linkend="small-pres-3-01">Презентация 3-01: терминал и командная строка</link></para>
    <sect2 id="shell-base-terminal">
      <title>Терминал</title>
      <phrase id="quest-3-1" xreflabel="Что такое терминал? Какие бывают терминалы?"/>
      <para>
	В операционной системе UNIX основными средствами взаимодействия пользователя с
	системой являются клавиатура и экран монитора, работающий в текстовом режиме.
	Вводимый пользователем текст немедленно отображается на мониторе соответствующими
	знаками, однако может и не отображаться (например, в случае ввода пароля). Для
	управления вводом используются некоторые нетекстовые клавиши на клавиатуре:
	<keycap moreinfo="none">Backspace</keycap> (он же <quote>Забой</quote>) – для удаления
	последнего введенного символа или <keycap moreinfo="none">Enter</keycap> – для передачи
	команды системе. Нажатие на эти клавиши не приводит к отображению символа, вместо
	этого вводимый текст обрабатывается системой тем или иным способом –
	эти клавиши и их комбинации объединяют понятием
	<emphasis id="def-control-chars" xreflabel="управляющие символы">управляющие символы</emphasis>.
      </para>
      <para>
	Текстовый принцип работы с машиной позволяет отвлечься от конкретных частей
	компьютера, вроде системной клавиатуры и видеокарты с монитором, рассматривая
	единое оконечное устройство, посредством которого пользователь вводит текст и
	передает его системе, а система выводит необходимые пользователю данные и
	сообщения. Такое устройство называется <emphasis id="def-terminal" xreflabel="терминал">терминалом</emphasis>. В общем случае терминал – это
	точка входа пользователя в систему, обладающая способностью передавать текстовую
	информацию. Терминалом может быть отдельное внешнее устройство, подключаемое к
	компьютеру через порт последовательной передачи данных
	(<quote>COM-порт</quote>). В роли терминала может работать (с некоторой поддержкой
	со стороны системы) и программа (например, <application moreinfo="none">xterm</application>
	или <application moreinfo="none">ssh</application>).
      </para>
      <para>
	Свойство терминала передавать только символьную информацию приводит к тому, что
	некоторые из передаваемых символов должны восприниматься не как текстовые, а как
	управляющие (например, символы, возвращаемые клавишами Backspace и Enter). На
	самом деле управляющих символов больше: часть из них предназначена для экстренной
	передачи команд системе, часть – для редактирования вводимого
	текста. Многие из этих символов не имеют специальной клавиши на клавиатуре,
	поэтому их необходимо извлекать с помощью клавиатурного
	модификатора <keycap moreinfo="none">Ctrl</keycap>. Проблема в том, что на клавиатуре может быть
	так много разных нетекстовых клавиш, что на них не хватает ограниченного
	количества разных управляющих символов. Поэтому большинство нетекстовых клавиш
	возвращают так называемую <emphasis id="def-control-seq" xreflabel="управляющая  последовательность">управляющую последовательность</emphasis>, которая
	начинается управляющим символом, за которым следует строго определенное число
	обычных символов.
      </para>
      <para>
	Одной из полезных особенностей терминала является позможность
	его <quote>прокрутки</quote> с помощью
	клавиш <keycombo moreinfo="none"><keycap moreinfo="none">Shift</keycap><keycap moreinfo="none">PgUp</keycap></keycombo>
	и <keycombo moreinfo="none"><keycap moreinfo="none">Shift</keycap><keycap moreinfo="none">PgDn</keycap></keycombo>. Это может быть
	полезно, если вывод программы занимает больший объём, чем размер экрана.
      </para>
    </sect2>
    <sect2 id="shell-base-shell">
      <title>Командная оболочка</title>
      <para>
	Основная среда взаимодействия с
	UNIX – <emphasis id="def-command-string" xreflabel="командная&#10;&#9;строка">командная
	строка</emphasis>. Суть её в том, что каждая строка, передаваемая пользователем
	системе, – это команда, которую та должна выполнить. Пока не нажата
	клавиша
	<keycap moreinfo="none">Enter</keycap>, строку можно редактировать, затем она отсылается системе.
      </para>
      <para>
	Команды интерпретируются и выполняются специальной программой –
	<emphasis id="def-command-shell" xreflabel="командная оболочка">командной
	оболочкой</emphasis> (или <quote>shell</quote>, по-английски). Через командную
	оболочку производится управление пользовательскими процессами – для
	этого используются средства межпроцессного обмена, описанные ранее
	(см. <xref linkend="intro-unix-proc-interproc"/>).
      </para>
      <para>
	Командная оболочка непосредственно связана с терминалом, через который
	осуществляется передача управляющих последовательностей и текста. На рисунке
	<xref linkend="img-terminal"/> представлена общая схема взаимодействия пользователя
	с системой при использовании командной строки.
      </para>
      <para>
	<figure id="img-terminal" float="0">
	  <title>Интерфейс командной строки</title>
	  <graphic fileref="images/terminal.png"/>
	</figure>
      </para>
    </sect2>   
    <sect2 id="shell-base-vc">
      <title>Одновременный доступ к системе</title>
      <para><link linkend="small-pres-3-02">Презентация 3-02: одновременный доступ к системе</link></para>
      <para>
	То, что UNIX – многопользовательская и многозадачная система,
	проявляется не только в разграничении прав доступа (см. раздел
	<xref linkend="chapter-security"/>), но и в организации рабочего места. Каждый
	компьютер, на котором работает UNIX, предоставляет возможность зарегистрироваться
	и получить доступ к системе нескольким пользователям одновременно. Даже если в
	распоряжении всех пользователей есть только один монитор и одна системная
	клавиатура, эта возможность небесполезна: одновременная регистрация в системе
	нескольких пользователей позволяет работать по очереди без необходимости каждый
	раз завершать все начатые задачи (закрывать все окна, прерывать исполнение всех
	программ) и затем возобновлять их. Более того, ничто не препятствует
	зарегистрироваться в системе несколько раз под одним и тем же входным
	именем. Таким образом, можно получить доступ к одним и тем же ресурсам (своим
	файлам) и организовать параллельную работу над несколькими задачами.
      </para>
      <para>
	Характерный для современных версий UNIX способ организации параллельной работы
	пользователей – <emphasis id="def-vc" xreflabel="виртуальная  консоль">виртуальные консоли</emphasis>. Виртуальные консоли (virtual
	console) – это несколько параллельно выполняемых операционной системой
	программ, предоставляющих пользователю возможность зарегистрироваться в системе в
	текстовом режиме и получить доступ к командной строке
	(см. <xref linkend="img-virtual-consoles"/>).
      </para>
      <para>
	В операционной системе Linux переключение между виртуальными консолями в текстовом
	режиме производится с помощью комбинации клавиш
	<keycombo moreinfo="none"><keycap moreinfo="none">Alt</keycap><keycap moreinfo="none">F1</keycap></keycombo>, 
	<keycombo moreinfo="none"><keycap moreinfo="none">Alt</keycap><keycap moreinfo="none">F2</keycap></keycombo> и т.п.. При этом
	каждая виртуальная консоль обозначается специальным
	именем: <quote>tty1</quote>, <quote>tty2</quote> и т.д.. По умолчанию в Linux
	доступно не менее шести виртуальных консолей, переключаться между которыми можно
	при помощи сочетания клавиши <keycap moreinfo="none">Alt</keycap> с одной из функциональных клавиш
	(<keycap moreinfo="none">F1</keycap>-<keycap moreinfo="none">F6</keycap>). С каждым сочетанием связана
	соответствующая по номеру виртуальная консоль. Виртуальные консоли обозначаются
	<quote>ttyN</quote>, где <quote>N</quote> – номер виртуальной консоли.
	На самом деле, каждая из таких конолей связано с
	собственным <emphasis>терминалом</emphasis>, который характеризуется файлом
	устройства с соответствующим именем (например, <filename moreinfo="none">/dev/tty1</filename>).
      </para>
      <para>
	Современные версии UNIX предоставляют пользователям графические пользовательские
	интерфейсы (подробнее графическая подсистема UNIX рассматривается в разделе
	<xref linkend="chapter-x-windows"/>), которые также дают возможность работы в
	командной строке. Эта возможность достигается с помощью
	<emphasis id="def-xterms" xreflabel="графический терминал">графических
	терминалов</emphasis> – специальных программ, которые эмулируют
	текстовый терминал в графическом окне.
      </para>
      <para>
	Также существует возможность запуска нескольких графических подсистем, тогда
	переключение между ними будет осуществляться аналогично переключению между
	виртуальными консолями – комбинацией клавиш 
	<keycombo moreinfo="none"><keycap moreinfo="none">Ctrl</keycap><keycap moreinfo="none">Alt</keycap>
	  <keycap moreinfo="none">F1</keycap></keycombo>.
      </para>
      <para>
	<figure id="img-virtual-consoles" float="0">
	  <title>Виртуальные и графические консоли</title>
	  <graphic fileref="images/virtual_consoles.png"/>
	</figure>
      </para>
      <para>
	Каждое устройство терминала имеет свои <emphasis>возможности</emphasis> по вводу и
	выводу информации. Примерати таких возможностей являются: число цветов
	отображения, способность перемещать курсор и изменять размер экрана, набор
	управляющих символов и т.п.. Терминалы разделяют по <emphasis id="def-termtype" xreflabel="тип терминала">типам</emphasis>: набору возможностей, регламентированных в
	специальном конфигурационном файле. Примерами типов являются: tty (телетайп) или
	xterm (графический терминал). Тип терминала явно указан в имени устройства
	терминала (например, <filename moreinfo="none">/dev/tty1</filename>). Все настройки типов
	терминалов находятся в директории <filename moreinfo="none">/etc/termcap</filename>.
      </para>
    </sect2>
    <sect2 id="shell-base-cmd">
      <title>Формат командной строки</title>
      <para><link linkend="small-pres-3-03">Презентация 3-03: формат командной строки</link></para>
      <phrase id="quest-3-2" xreflabel="Командная строка UNIX: из каких частей состоит, основные&#10;      управляющие клавиши, примеры команд?"/>
      <sect3 id="shell-base-cmd-prompt">
	<title>Приглашение</title>
	<para>
	  Командная строка состоит из <emphasis id="def-command-prompt" xreflabel="приглашение">приглашения</emphasis> и вводимой
	  команды. Приглашение – это специальная последовательность символов,
	  которая располагается в начале строки и задает начало области ввода команды.
	  Рассмотрим пример выполнения команды:
	</para>
	<para>
	  <example>
	    <title>Пример выполнения команды</title>
	    <screen format="linespecific">user@desktop ~ $ date
Втр Окт  4 23:15:37 MSD 2005
user@desktop ~ $</screen>
	  </example>
	</para>
	<para>
	  Здесь приглашением является строка <prompt moreinfo="none">user@desktop ~ $</prompt>, которая
	  помимо символа начала ввода ($) содержит информацию об имени пользователя, имени
	  компьютера и текущей директории.
	</para>
      </sect3>
      <sect3 id="shell-base-cmd-format">
	<title>Формат команды</title>
	<para>
	  Каждая команда UNIX состоит из следующих частей:
	  <variablelist>
	    <varlistentry>
	      <term><emphasis id="def-cmd-name" xreflabel="имя команды">Имя
	      команды</emphasis></term>
	      <listitem><para>
		  Идентификатор команды, совпадающий с именем программы, которая
		  запускается для исполнения команды. Некоторые команды (такие
		  как <command moreinfo="none">echo</command>) являются <emphasis id="def-internal-cmd" xreflabel="встроенная команда">встроенными</emphasis> для данной командной
		  оболочки и для их выполнения вызывается не программа, а внутренняя
		  функция оболочки.
	      </para></listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis id="def-cmd-params" xreflabel="параметры        команды">Параметры</emphasis> или ключи или флаги или опции</term>
	      <listitem><para> Команда может иметь один или несколько параметров,
		  разделённых пробелом. Параметры могут быть однобуквенными
		  (как <parameter class="command" moreinfo="none">-l</parameter>) или полнословными
		  (например, <parameter class="command" moreinfo="none">--help</parameter>).
		  Однобуквенные параметры могут группироваться, например запуск команды
		  <command moreinfo="none">ls -al</command> эквивалентен запуску <command moreinfo="none">ls -a
		  -l</command>. Некоторые параметры состоят из имени и аргумента, например
		  в коменде <command moreinfo="none">grep -f access.log -n test</command> имя
		  файла <filename moreinfo="none">access.log</filename> – часть параметра 
		  <parameter class="command" moreinfo="none">-f</parameter>.
	      </para></listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis id="def-cmd-args" xreflabel="аргументы        команды">Аргументы</emphasis></term>
	      <listitem><para>
		  Некоторые команды могут иметь аргументы. Аргументом может являться
		  текстовая строка, соответвтующая имени файла или другого
		  объекта. Аргументы также разделяются символом пробела, чтобы передать в
		  качестве аргумента строку символов с пробелами, можно воспользоваться
		  символами кавычек: 
	      </para>
		<para>
	  <screen format="linespecific">user@desktop ~ $ echo "Hello, world."
Hello, world.</screen>
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis id="def-cmd-redirection" xreflabel="перенаправление        ввода-вывода">Перенаправления</emphasis></term>
	      <listitem><para> Стандартный ввод и вывод каждой команды
		  (см. <xref linkend="intro-unix-proc-interproc"/>) может быть
		  перенаправлен в файл. По умолчанию ввод и вывод команды связываются с
		  пользовательским терминалом. Для указания источника ввода или назначения
		  вывода (для обычной информации и для ошибок отдельно) используются
		  специальные символы (&lt;, &gt; и &gt;&gt;).
	      </para></listitem>
	    </varlistentry>
	  </variablelist>
	</para>
	<para>
	  Как правило, порядок данных частей команды должен быть именно таким, однако
	  некоторые из них (кроме имени команды) могут отсутствовать.
	</para>
      </sect3>
      <sect3 id="shell-base-cmd-exec">
	<title>Процесс выполнения команды</title>
	<para><link linkend="small-pres-3-04">Презентация 3-04: исполнение команды</link></para>
	<phrase id="quest-3-3" xreflabel="Что такое командная оболочка? Что происходит при запуске&#10;&#9;команды?"/>
	<para>
	  Командная оболочка – это обычный процесс в операционной системе
	  UNIX. Когда пользователь вводит команду (например, по
	  нажатию <keycap moreinfo="none">Enter</keycap>), командная оболочка выполняет следующие
	  действия:
	  <orderedlist inheritnum="ignore" continuation="restarts">
	    <listitem>анализ команды: выделение имени, параметров и аргументов;</listitem>
	    <listitem>если это <emphasis>встроенная команда</emphasis>, для неё вызывается
	      функция-обработчик;</listitem>
	    <listitem>если это <emphasis>внешняя команда</emphasis>:
	      <orderedlist inheritnum="ignore" continuation="restarts">
		<listitem>производится поиск программы с соответвующим именем;</listitem>
		<listitem>создаётся дочерний процесс оболочки (системный вызов
		  fork);</listitem>
		<listitem>в дочернем процессе запускается необходимая команда с
		  расшифрованными параметрами и аргументами (системный вызов
		exec);</listitem>
		<listitem>оболочка контролирует выполнение дочернего процесса, передаёт
		  ему сигналы и ввод пользователя, ожидает его завершения (системный вызов
		  wait);</listitem>
	      </orderedlist>
	    </listitem>
	    <listitem>результаты работы возвращаются пользователю, отображается
	    приглашение – он может вводить следую команду.</listitem>
	  </orderedlist>
	</para>
	<para>
	  <figure id="img-running-child" float="0">
	    <title>Запуск команды оболочкой</title>
	    <graphic fileref="images/running_child.png"/>
	  </figure>
	</para>
      </sect3>
      <sect3 id="shell-base-cmd-retval">
	<title>Возвращаемое значение</title>
	<para><link linkend="small-pres-3-05">Презентация 3-05: возвращаемое значение</link></para>
	<para>
	  Каждый процесс при завершении возвращает своему родительскому процессу
	  специальный <emphasis id="def-return-value" xreflabel="код завершения">код завершения</emphasis>
	  программы. Этот код может использоваться для получения результата выполнения
	  программы и для проверки корректности её выполнения (возврата кода ошибки).
	</para>
	<para>
	  Традиционно для UNIX, в случае успешного выполнения программа (а также
	  большинство системных функций) возвращает значение <literal moreinfo="none">0</literal>. Другие
	  значения (все, отличные от <literal moreinfo="none">0</literal>) означают тот или иной вид
	  ошибки. Так как программы часто выводят инфоромацию об ошибках через специальный
	  <emphasis>поток вывода ошибок</emphasis> (stderr), возвращаемые значения чаще
	  всего могут принимать только два значения: <quote>ноль</quote> и <quote>не
	  ноль</quote>. 
	</para>
	<para>
	  Если рассмотреть простейший пример программы на языке C:
	</para>
	<para>
	  <example>
	    <title>Возвращаемое значение в программе на языке C</title>
	    <programlisting format="linespecific">
int main(int argc, char* argv[]) {
    ...
    if(error) {
        exit(1);
    }
    ...
    return 0;
}
	    </programlisting>
	  </example>
	</para>
	<para>
	  видно, что программы передают код завершения через возвращаемое значение
	  главной функции (<function moreinfo="none">main</function>) или как параметр
	  функции <function moreinfo="none">exit</function>.
	</para>
	<para>
	  В командной строке результат выполнения программы можно проанализировать с
	  помощью специальной переменной (<varname>$?</varname>):
	</para>
	<para>
	  <screen format="linespecific">user@desktop ~ $ test -f /tmp/file.txt
user@desktop ~ $ echo $?
0</screen>
	</para>
      </sect3>
      <sect3 id="shell-base-cmd-join">
	<title>Способы объединения команд</title>
	<para><link linkend="small-pres-3-06">Презентация 3-06: способы объединения команд</link></para>
	<phrase id="quest-3-4" xreflabel="Какие существуют способы объединения команд? Чем они&#10;&#9;отличаются?"/>
	<para>
	  Существует возможность объединять несколько команд в одной командной строке. Это
	  можно делать несколькими способами:
	  <variablelist>
	    <varlistentry>
	      <term>Последовательное выполнение</term>
	      <listitem><para>
		  Команды выполняются одна за другой, не зависимо от результата их
		  исполнения. В качестве разделителя выступает символ точки с запятой
		  (<quote>;</quote>).
		</para>
		<para>
		  В качестве примера можно рассмотреть составную команду
		  <command moreinfo="none">du -sh; date</command>, которая выводит на экран содержимое
		  домашней директории, а затем текущие дату и время.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Условное выполнение (И)</term>
	      <listitem><para> Проверяется код завершения первой программы, если он
		  равен <literal moreinfo="none">0</literal>, производится выполнение второй программы, и
		  так далее. Таким образом, последняя команда выполнится только при
		  успешном завершении всех предыдущих. В качестве разделителя выступают
		  два амперсанда (<quote>&amp;&amp;</quote>).
		</para>
		<para>
		  В качестве примера можно рассмотреть составную команду
		  <command moreinfo="none">test -r /tmp/txt &amp;&amp; cp /tmp/txt .</command>, которая
		  проверяет возможность чтения файла <filename moreinfo="none">/tmp/txt</filename> и в
		  случае успеха, копирует этот файл в локальную директорию.
		</para>
	      </listitem>  
	    </varlistentry>
	    <varlistentry>
	      <term>Условное выполнение (ИЛИ)</term>
	      <listitem><para>
		  Проверяется код завершения первой программы, если он
		  <emphasis>не</emphasis> равен <literal moreinfo="none">0</literal>, производится
		  выполнение второй программы, и так далее. Последняя команда будет
		  запущена только если ни одна из предыдущих не закончилась успешно. В
		  качестве разделителя выступают две вертикальный черты
		  (<quote>||</quote>).
		</para>
		<para>
		  В качестве примера можно рассмотреть составную команду
		  <command moreinfo="none">test -d /tmp/dir || mkdir /tmp/dir</command>, которая
		  проверяет существование директории <filename moreinfo="none">/tmp/dir</filename> и если
		  её нет, создаёт её.
		</para>
	      </listitem>  
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis id="def-conv" xreflabel="конвейер">Конвейер</emphasis></term>
	      <listitem><para> При выполнении программ связываются их стандартные выходы и
		  входы, так что текстовые данные передаются через них последовательно,
		  как по конвейеру. Этот механизм является одной из самых фундаментальных
		  особенностей UNIX и широко используется при работе в командной стоке.
		</para>
		<para>
		  Все программы могут быть запущены одновременно, так чтобы обеспечить
		  интерактивность вывода при прохождении данных через цепочку
		  программ. Если одна из программ в цепочке конвейера завершится
		  (например, в случае ошибки), остальным будет отправлен специальный
		  сигнал (SIGPIPE). 
		</para>
		<para>
		  В качестве разделителя используется символ вертикальный черты
		  (<quote>|</quote>).
		</para>
		<para>
		  Рассмотрим пример команды <command moreinfo="none">cat file.txt | uniq | sort</command>,
		  которая читает содержимое файла <filename moreinfo="none">file.txt</filename>, удаляет
		  из него повторяющиеся строки и сортирует оставшиеся строки по
		  алфавиту. Результат выводится на экран.
		</para>
	      </listitem> 
	    </varlistentry>
	  </variablelist>
	</para>
	<para>
	  Современные командные оболочки позволяют строить более гибкие условные выражения
	  (с импользованием скобок и знака отрицания) из выполняющихся команд.
	</para>
      </sect3>
      <sect3 id="shell-base-cmd-chars">
	<title>Служебные символы</title>
	<para><link linkend="small-pres-3-07">Презентация 3-07: служебные символы</link></para>
	<para>
	  Из предыдущих разделов видно, что в командной строке присутствует множество
	  <emphasis id="def-reservesd-chars" xreflabel="служебные символы">служебных
	  символов</emphasis>, каждый из которых имеет своё значение. Все эти символы
	  следует с осторожностью использовать в именах файлов.
	</para>
	<para>
	  Рассмотрим основные группы служебных символов командной оболочки:
	  <variablelist>
	    <varlistentry>
	      <term>Символы-разделители</term>
	      <listitem>
		<para>
		  Используются для отлеления частей команды или нескольких команд. К ним
		  относятся: пробел, табуляция. По умолчанию команды разделяются символом
		  перевода строки. При использовании символа пробела в именах файлов
		  необходимо заключать параметр в кавычки или предварять пробел символом
		  обратной косой (<quote>\</quote>).
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Символы пути</term>
	      <listitem>
		<para>
		  Используются для разделения элементов пути. Сюда можно отнести символ
		  корня (<quote>/</quote>) и символ домашней директории
		  (<quote>~</quote>) – в командной строке он автоматически
		  заменяется на полный путь к домашней директории. При этих символов в
		  именах файлов необходимо предварять их символом обратной косой
		  (<quote>\</quote>).
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Символы команд</term>
	      <listitem>
		<para>
		  Применяются в аргументах команд, для отделения нескольких команд, для
		  запуска процессов на заднем фоне и т.п. К таким символам можно отнести:
		  <quote>*</quote>, <quote>&amp;</quote>, <quote>&lt;</quote>,
		  <quote>&gt;</quote>, <quote>;</quote>, <quote>(</quote>,
		  <quote>)</quote>, <quote>|</quote>, <quote>"</quote>.  При этих
		  символов в именах файлов необходимо предварять их символом обратной
		  косой (<quote>\</quote>).
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Символ параметров команды</term>
	      <listitem>
		<para>
		  Символ <quote>-</quote> используются для задания параметров
		  команд. Проблемы могут возникнуть, если имя файла начинается с этого
		  символа – в этом случае командная оболочка может принять
		  такой аргумент за набор параметров. Стандартным выходом из этой ситуации
		  является явное указание окончания списка параметров с <quote>--</quote>,
		  например: 
		</para>
		<para>
		  <screen format="linespecific">user@desktop ~ $ ls -l -- -test-file
-rw-r--r--   1 user  users      90 Сен 19 00:20 -test-file</screen>
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Символы управления переменными</term>
	      <listitem>
		<para>
		  Используются для задания (<quote>=</quote>) и подстановки
		  (<quote>$</quote>) значений переменных среды. При этих символов в именах
		  файлов необходимо предварять их символом обратной косой
		  (<quote>\</quote>).
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>ESC-символы</term>
	      <listitem>
		<para>
		  Специальные ASCII-символы, вроде возврата каретки или табуляции. Их
		  синтаксис эквивалентен используемому в языке C – с
		  применением символа обратной косой (<quote>\</quote>).
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
      </sect3>
    </sect2>      
    <sect2 id="shell-base-env">
      <title>Программное окружение</title>
      <para><link linkend="small-pres-3-08">Презентация 3-08: программное окружение</link></para>
      <phrase id="quest-3-5" xreflabel="Что такое программное окружение? Какие стандартные&#10;      переменные окружения существуют в UNIX?"/>
      <para>
	Каждый запускаемый процесс система снабжает неким <emphasis id="def-env" xreflabel="окружение">информационным пространством</emphasis>, которое этот процесс
	вправе изменять как ему заблагорассудится. Правила пользования этим пространством
	просты: в нем можно задавать именованные хранилища данных
	(<emphasis id="def-env-var" xreflabel="переменная окружения">переменные
	окружения</emphasis>), в которые записывать какую угодно информацию (присваивать
	значение переменной окружения), а впоследствии эту информацию считывать
	(подставлять значение переменной).
      </para>
      <para>
	В UNIX дочерний процесс – точная копия родительского, поэтому его
	окружение – также точная копия родительского. Если про дочерний процесс
	известно, что он использует значения некоторых переменных из числа передаваемых
	ему с окружением, родительский может заранее указать, каким из копируемых в
	окружении переменных нужно изменить значение. При этом, с одной стороны, никто
	(кроме системы, конечно) не сможет вмешаться в процесс передачи данных, а с другой
	стороны, одна и та же утилита может быть использована одним и тем же способом, но
	в измененном окружении – и выдавать различные результаты:
      </para>
      <para>
	<screen format="linespecific">user@desktop ~ $ date
Птн Ноя 5 16:20:16 MSK 2004
user@desktop ~ $ LC_TIME=C date
Fri Nov 5 16:20:23 MSK 2004</screen>
      </para>
      <para>
	В последнем примере пользователь присвоил некоторое значение переменной окружения
	в командной строке перед именем команды. Командный интерпретатор,
	увидев <quote>=</quote> внутри первого слова командной строки, приходит к выводу,
	что это – операция присваивания, а не имя команды, и запоминает, как
	надо изменить окружение команды, которая последует далее. Переменная окружения
	<envar>LC_TIME</envar> предписывает использовать определенный язык при выводе даты
	и времени, а значение <literal moreinfo="none">"C"</literal> соответствует стандартному
	системному языку (чаще всего – английскому).
      </para>
      <para>
	Для получения значения переменной окружения необходимо воспользоваться
	символом <quote>$</quote>:
      </para>
      <para>
	<screen format="linespecific">user@desktop ~ $ echo $PWD
/home/user</screen>
      </para>
      <sect3 id="shell-base-env-std">
	<title>Стандартные переменные окружения</title>
	<para>
	  При старте командной оболочки, инициализируется множество системных переменных,
	  которые можно посмотреть с помощью команды <command moreinfo="none">env</command>. Некоторые из
	  них представляют особый интерес для пользователя системы:
	</para>
	<para>
	  <variablelist>
	    <varlistentry>
	      <term><envar>DISPLAY</envar></term>
	      <listitem>
		<para>
		  Переменная используется графической подсистемой X11 и указывает на адрес
		  X-сервера и номер используемого экрана (подробнее об этом будет сказано
		  в разделе <xref linkend="chapter-x-windows"/>).
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><envar>EDITOR</envar></term>
	      <listitem>
		<para>
		  Если какая-то утилита требует редактирования файла, то вместо
		  написания и использования встроенного редактора, этот файл можно
		  передать на редактирование программе, путь к которой хранится в
		  переменной <envar>EDITOR</envar>. 
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><envar>HOME</envar></term>
	      <listitem>
		<para>
		  Переменная сожержит имя домашней директории текущего пользователя.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><envar>PATH</envar></term>
	      <listitem>
		<para>
		  Переменная окружения содержит список директорий, разделённый
		  символом <quote>:</quote>. Этот список просматривается при каждом
		  запуске команды – в нём производится поиск исполнемых файлов
		  с соответвтующем команде именем. Примером значения переменной окружения
		  может быть <quote>/bin:/usr/bin:/usr/local/bin</quote>.
		</para>
		<para>
		  Как правило, значение этой переменной различается для простого
		  пользователя и администратора – для того, чтобы разделить их
		  рабочий инструментарий.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><envar>SHELL</envar></term>
	      <listitem>
		<para>
		  Имя текущей программы оболочки.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><envar>TERM</envar></term>
	      <listitem>
		<para>
		  Тип терминала, используемого в настоящий момент. Эта переменная
		  анализируется программами для того, чтобы варьировать свой интерфейс в
		  зависимости от возможностей терминала.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><envar>USER</envar></term>
	      <listitem>
		<para>
		  Имя текущего пользователя.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><envar>_</envar> (одиночный символ подчёркивания)</term>
	      <listitem>
		<para>
		  В точности последняя команда, выполненная в командной оболочке.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
      </sect3>
    </sect2>      
    <sect2 id="shell-base-shellfeat">
      <title>Возможности интерфейса командной оболочки</title>
      <para><link linkend="small-pres-3-09">Презентация 3-09: возможности командной оболочки</link></para>
      <para>
	Современные командные оболочки, например <application moreinfo="none">bash</application>
	предоставляют пользователю ряд удобных особеностей пользовательского интерфейса,
	облегчающих работу с командной строкой.
      </para>    
      <sect3 id="shell-base-shellfeat-edit">
	<title>Редактирование командной строки</title>
	<para>
	  Вводимую команду можно редактировать с помощью
	  клавиш <keycap moreinfo="none">Backspace</keycap> и <keycap moreinfo="none">Delete</keycap>, перемещаться
	  стрелками по всей строке.
	</para>
	<para>
	  Для управления запущенными командами используются сочетания клавиш. Ввод следует
	  завершать командой <keycombo moreinfo="none"><keycap moreinfo="none">Ctrl</keycap><keycap moreinfo="none">D</keycap></keycombo>
	  (конец ввода). Эту команду интерпретирует при вводе с терминала система. Она же
	  превращает некоторые другие управляющие символы
	  (например, <keycombo moreinfo="none"><keycap moreinfo="none">Ctrl</keycap>
	    <keycap moreinfo="none">C</keycap></keycombo> – <quote>перывание</quote> или 
	  <keycombo moreinfo="none"><keycap moreinfo="none">Ctrl</keycap>
	    <keycap moreinfo="none">Z</keycap></keycombo> – <quote>засыпание</quote>) в
	    сигналы.
	</para>
	<para>
	  Командная оболочка позволяет настраивать все функциональные клавиши и
	  команды. Настройки ввода для <application moreinfo="none">bash</application> располагаются в
	  файле <filename moreinfo="none">/etc/inputrc</filename>.
	</para>
      </sect3>
      <sect3 id="shell-base-shellfeat-history">
	<title>История команд</title>
	<para>
	  Двумя другими клавишами со стрелками – вверх и вниз –
	  задействуется весьма мощный
	  механизм <application moreinfo="none">bash</application> – работа с
	  <emphasis id="def-history" xreflabel="история команд">историей
	  команд</emphasis>. Все команды, набранные пользователем, командная оболочка
	  запоминает и позволяет обращаться к ним впоследствии. По стрелке вверх, список
	  поданных команд <quote>прокручивается</quote> от последней к первой, а по
	  стрелке вниз – обратно. Соответствующая команда отображается в
	  командной строке как только что набранная, её можно отредактировать и подать
	  оболочке (подгонять курсор к концу строки при этом необязательно).
	</para>
	<para>
	  Чтобы история команд могла сохраняться <emphasis>между</emphasis> сеансами
	  работы пользователя, <application moreinfo="none">bash</application> записывает ее в файл
	  <filename moreinfo="none">.bash_history</filename>, находящийся в домашнем каталоге
	  пользователя. Делается это в момент завершения оболочки: накопленная за время
	  работы история дописывается в конец этого файла. При следующем запуске командной
	  оболочки считывает <filename moreinfo="none">.bash_history</filename> целиком. История хранится
	  не вечно, количество запоминаемых команд в <filename moreinfo="none">.bash_history</filename>
	  ограничено (обычно сохраняется 500 команд, но это можно и перенастроить).
	</para>
      </sect3>
      <sect3 id="shell-base-shellfeat-aliases">
	<title>Псевдонимы</title>
	<para>
	  Поиск по истории – удобное средство: длинную командную строку можно
	  не набирать целиком, а отыскать и использовать. Однако давнюю команду придется
	  добывать с помощью нескольких нажатий клавиши вверх – а можно и
	  совсем не доискаться, если она уже выбыла оттуда. Для того чтобы оперативно
	  заменять короткие команды длинными, стоит воспользоваться
	  <emphasis id="def-alias" xreflabel="псевдоним">псевдонимами</emphasis>
	  (aliases). В конфигурационных файлах командного интерпретатора пользователя
	  обычно уже определено несколько сокращений, список которых можно посмотреть с
	  помощью команды alias без параметров:
	</para>
	<para>
	  <screen format="linespecific">user@desktop ~ $ alias
alias cp='cp -i'
alias l='ls -lapt'
alias ll='ls -laptc'
alias ls='ls --color=auto'
alias md='mkdir'
alias mv='mv -i'
alias rd='rmdir'
alias rm='rm -i'</screen>
	</para>
	<para>
	  Например, по команде <command moreinfo="none">ls</command> вместо
	  утилиты <application moreinfo="none">/bin/ls</application> <application moreinfo="none">bash</application>
	  запускает собственную команду-сокращение, превращающееся в команду
	  <command moreinfo="none">ls --color=auto</command>. Повторно появившуюся в команде подстроку
	  "ls" интерпретатор уже не обрабатывает, во избежание вечного цикла. Например,
	  команда <command moreinfo="none">ls -al</command> превращается в результате
	  в <command moreinfo="none">ls --color=auto -al</command>.
	</para>
	<para>
	  Сокращения не наследуются с окружением.
	</para>
      </sect3>
      <sect3 id="shell-base-shellfeat-autocompl">
	<title>Автодополнение</title>
	<para>
	  Автодополнения позволяют быстро набирать команды и пути в файловой системе. Во
	  время набора имени команды или файла пользователь может нажать
	  клавишу <keycap moreinfo="none">Tab</keycap>, и командная оболочка
	  попытается <quote>дополнить</quote> указанную команду или файл: предложит
	  возможные варианты с данным началом или же дополнит имя, ведь часто набранной
	  строки – пути к файлу и нескольких первых букв его имени –
	  достаточно для однозначного указания на этот файл, потому что по введенному пути
	  других файлов, чье имя начинается на эти буквы, просто нет.
	</para>
      </sect3> 
      <sect3 id="shell-base-shellfeat-templates">
	<title>Шаблоны</title>
	<para>
	  Автодополнение очень удобно, когда цель пользователя – задать один
	  конкретный файл в командной строке. Если же нужно работать сразу с несколькими
	  файлами – например, для перемещения их в другой каталог с помощью mv,
	  достраивание не помогает. Необходим способ задать одно <quote>общее</quote> имя
	  для группы файлов, с которыми будет работать команда. В подавляющем большинстве
	  случаев это можно сделать при помощи <emphasis id="def-template" xreflabel="шаблон">шаблона</emphasis>.
	</para>
	<para>
	  Шаблон в командном интерпретаторе используется примерно в тех же целях, что и
	  регулярное выражение, которое будет описано в разделе
	  <xref linkend="shell-maincmd-text-regexp"/>: для поиска строк определенной
	  структуры среди множества разнообразных строк. В отличие от регулярного
	  выражения, шаблон всегда примеряется к строке целиком, кроме того, он устроен
	  значительно проще (а значит, и беднее).
	</para>
	<para>
	  Символы в шаблоне разделяются на обычные и специальные. Обычные символы
	  соответствуют таким же символам в строке, а специальные –
	  обрабатываются особым образом:
	</para>
	<para>
	  <itemizedlist>
	    <listitem>
	      <para>
		Шаблону, состоящему только из обычных символов, соответствует единственная
		строка, состоящая из тех же символов в том же порядке. Например, шаблону
		<quote>abc</quote> соответствует строка <literal moreinfo="none">abc</literal>, но
		не <literal moreinfo="none">aBc</literal> или <literal moreinfo="none">ABC</literal>, потому что большие и
		маленькие буквы различаются.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		Шаблону, состоящему из единственного спецсимвола <quote>*</quote>,
		соответствует любая строка любой длины (в том числе и пустая).
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		Шаблону, состоящему из единственного спецсимвола <quote>?</quote>,
		соответствует любая строка длиной в один символ,
		например, <literal moreinfo="none">a</literal>, <literal moreinfo="none">+</literal>
		или <literal moreinfo="none">@</literal>, но не <literal moreinfo="none">ab</literal>
		или <literal moreinfo="none">8888</literal>.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		Шаблону, состоящему из любых символов, заключенных в квадратные
		скобки <quote>[</quote> и <quote>]</quote> соответствует строка длиной в
		один символ, причем этот символ должен встречаться среди заключенных в
		скобки. Например, шаблону <quote>[bar]</quote> соответствуют только строки
		<literal moreinfo="none">a</literal>, <literal moreinfo="none">b</literal> и <literal moreinfo="none">r</literal>, но не
		<literal moreinfo="none">c</literal>, <literal moreinfo="none">B</literal>, <literal moreinfo="none">bar</literal> или
		<literal moreinfo="none">ab</literal>. Символы внутри скобок можно не перечислять
		полностью, а задавать диапазон, в начале которого стоит символ с
		наименьшим ASCII-кодом, затем следует <quote>-</quote>, а
		затем – символ с наибольшим ASCII-кодом. Например, шаблону
		<quote>[0-9a-fA-F]</quote> соответствует одна шестнадцатеричная цифра
		(скажем, <literal moreinfo="none">5</literal>, <literal moreinfo="none">e</literal>
		или <literal moreinfo="none">C</literal>). Если после <quote>[</quote> в шаблоне
		следует <quote>!</quote>, то ему соответствует строка из одного символа,
		не перечисленного между скобками.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		Шаблону, состоящему из нескольких частей, соответствует строка, которую
		можно разбить на столько же подстрок (возможно, пустых), причем первая
		подстрока будет отвечать первой части шаблона, вторая – второй
		и т. д. Например, шаблону <quote>a*b?c</quote> будут соответствовать
		строки <literal moreinfo="none">ab@c</literal> (<quote>*</quote> соответствует пустая
		подстрока), <literal moreinfo="none">a+b=c</literal> и <literal moreinfo="none">aaabbc</literal>, но не
		будут соответствовать <literal moreinfo="none">abc</literal> (<quote>?</quote>
		соответствует подстрока <literal moreinfo="none">c</literal>, а для <quote>c</quote>
		соответствия не находится), <literal moreinfo="none">@ab@c</literal> (нет соответствия для
		<quote>a</quote>) или <literal moreinfo="none">aaabbbc</literal> (из
		трех <literal moreinfo="none">b</literal> первое соответствует <quote>b</quote>,
		второе – <quote>?</quote>, а вот третье приходится
		на <quote>c</quote>).
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>
	<para>
	  Шаблоны используются в нескольких конструкциях shell. Главное место их
	  применения – командная строка. Если оболочка <quote>видит</quote> в
	  командной строке шаблон, она немедленно заменяет его списком файлов, имена
	  которых ему соответствуют. Команда, которая затем вызывается, получает в
	  качестве параметров список файлов уже без всяких шаблонов, как если бы этот
	  список пользователь ввел вручную. Шаблоны используются в нескольких конструкциях
	  shell. Главное место их применения – командная строка. Если оболочка
	  <quote>видит</quote> в командной строке шаблон, она немедленно заменяет его
	  списком файлов, имена которых ему соответствуют. Команда, которая затем
	  вызывается, получает в качестве параметров список файлов уже без всяких
	  шаблонов, как если бы этот список пользователь ввел вручную.
	</para>	  
      </sect3>
      <sect3 id="shell-base-shellfeat-programming">
	<title>Командная оболочка как средство программирования</title>
	<para>
	  Большая часть того, что нужно начинающему пользователю UNIX, делается с помощью
	  одной правильной команды, или вызовом нескольких команд в конвейере. От
	  пользователя только требуется оформить решение задачи в виде сценария на
	  shell. На самом же деле уже самый первый из командных
	  интерпретаторов, <application moreinfo="none">sh</application>, был настоящим высокоуровневым
	  языком программирования – если, конечно, считать все утилиты системы
	  его операторами. При таком подходе от <application moreinfo="none">sh</application> требуется
	  совсем немного: возможность вызывать утилиты, возможность свободно
	  манипулировать результатом их работы и несколько алгоритмических конструкций
	  (условия и циклы).
	</para>
	<para>
	  Программирование на shell, а также других, более мощных интерпретируемых языках
	  в UNIX, остается за рамками этого курса.
	</para>
      </sect3>
    </sect2>      
    <sect2 id="shell-base-help">
      <title>Справочная подсистема</title>
      <para><link linkend="small-pres-3-10">Презентация 3-10: справочная подсистема</link></para>
      <phrase id="quest-3-6" xreflabel="Что входит в справочную систему UNIX?"/>
      <para>
	Работать с UNIX, не заглядывая в документацию, практически невозможно. Это
	возможно, потому что документированы практически все области операционной
	системы. Всем пользователям настоятельно рекомендуется, приступая к работе, а тем
	более – к изучению UNIX, пользоваться всеми доступными
	руководствами. Исторически первым и основным средством документации во всех
	версиях являются страницы руководства (manual pages), которые будут подробно
	рассмотрены далее.
      </para>
      <para>
	Документация в подавляющем большинстве случаев пишется на простом английском
	языке. Если английский – не родной язык для автора документации, она
	будет только проще. Традиция писать по-английски идет от немалого вклада США в
	развитие компьютерной науки вообще и UNIX в частности. Кроме того, английский
	становится языком международного общения во всех областях, не только в
	компьютерной. Необходимость писать на языке, который будет более или менее понятен
	большинству пользователей, объясняется постоянным развитием UNIX. Дело не в том,
	что страницу руководства нельзя перевести, а в том, что ее придется переводить
	всякий раз, когда изменится описываемый ею объект! Например, выход новой версии
	программного продукта сопровождается изменением его возможностей и особенностей
	работы, а следовательно, и новой версией документации.
      </para>
      <para>
	Документация в UNIX играет важнейшую роль. Решение любой задачи должно начинаться
	с изучения руководств. Не стоит жалеть на это времени. Даже если рядом есть
	опытный пользователь UNIX, который, возможно, знает ответ, не стоит беспокоить его
	сразу же. Возможно, даже зная, что нужно сделать, он не помнит как
	именно – и поэтому (а также потому, что он – опытный
	пользователь) начнет с изучения руководства. Это – закон, у которого
	даже собственное название: <acronym>RTFM</acronym>, что означает <quote>Read That
	Fine Manual</quote>.
      </para>
      <para>
	Современные свободные UNIX-системы обладают большим сообществом пользователей и
	разработчиков, объединённых через Интернет. В этих сообществах является нормальной
	практикой взаимопомощь и ответы на вопросы по системе. Однако, здесь необходимо
	следовать описанному выше принципу <acronym>RTFM</acronym>.
      </para>
      <sect3 id="shell-base-help-man">
	<title>Страницы руководтсва</title>
	<para><link linkend="small-pres-3-11">Презентация 3-11: страницы руководств (man)</link></para>
	<para>
	  Больше всего полезной информации содержится в <emphasis id="def-manpage" xreflabel="страница руководства">страницах руководства</emphasis>, для краткости мы
	  будем называть их просто <quote>руководство</quote>. Каждая страница посвящена
	  какому-нибудь одному объекту системы. Для того чтобы посмотреть страницу
	  руководства, нужно дать команду системе <command moreinfo="none">man объект</command>:
	</para>
	<para>
	  <screen format="linespecific">user@desktop ~ $ man cal
CAL(1)       BSD General Commands Manual   CAL(1)
NAME
        cal - displays a calendar
SYNOPSIS
        cal [-smjy13] [[month] year]
DESCRIPTION
        Cal displays a simple calendar. If arguments
        are not specified, the current month is 
        displayed. 
        The options are as follows:
...</screen>
	</para>
	<para>
	  Страница руководства занимает, как правило, больше одной страницы экрана. Для
	  того чтобы читать было удобнее, man запускает программу постраничного просмотра
	  текстов – <xref linkend="def-cmd-less"/>. Управлять
	  программой <command moreinfo="none">less</command> просто: страницы перелистываются пробелом, а
	  когда читать надоест, надо нажать
	  <keycap moreinfo="none">q</keycap> (Quit). Перелистывать страницы можно и клавишами
	  <keycap moreinfo="none">Page Up</keycap>/<keycap moreinfo="none">Page Down</keycap>, для сдвига на одну строку
	  вперед можно применять <keycap moreinfo="none">Enter</keycap> или стрелку вниз, а на одну строку
	  назад – стрелку вверх. Переход на начало и конец текста выполняется
	  по командам <keycap moreinfo="none">g</keycap> и <keycap moreinfo="none">G</keycap> соответственно (Go). Полный
	  список того, что можно делать с текстом в <command moreinfo="none">less</command>, выводится по
	  команде <keycap moreinfo="none">h</keycap> (help). Для поиска и подстветки интересующего понятия
	  можно воспользоваться командой <keycap moreinfo="none">/</keycap>, после которой необходимо
	  ввести интересующий Вас термин – по нажатию
	  клавиши <keycap moreinfo="none">Enter</keycap>, курсор перейдёт к первому упоминанию термина,
	  который будет выделен серым цветом. Последующие нажатия <keycap moreinfo="none">/</keycap>
	  и <keycap moreinfo="none">Enter</keycap> приведут к продолжению поиска слова по документу.
	</para>
	<para>
	  Страница руководства состоит из полей – стандартных разделов, с
	  разных сторон описывающих заинтересовавший объект – например, команду
	  <command moreinfo="none">cal</command>. В поле NAME содержится краткое описание объекта (такое,
	  чтобы его назначение было понятно с первого взгляда). В поле SYNOPSIS дается
	  формализованное описание способов использования объекта (в данном
	  случае – того, как и с какими параметрами запускать
	  команду <command moreinfo="none">cal</command>). Как правило, в квадратные скобки в этом поле
	  заключены необязательные параметры команды, которые можно ей передать, а можно и
	  опустить. Например, строка <quote>[[month] year]</quote> означает, что в этом
	  месте командной строки параметров у команды может не быть вообще, может быть
	  указан год или пара – месяц и год. Наконец, текст в поле
	  DESCRIPTION – это развернутое описание объекта, достаточное для того,
	  чтобы им воспользоваться.
	</para>
	<para>
	  Одно из самых важных полей руководства находится в конце текста. Если в процессе
	  чтения NAME или DESCRIPTION пользователь понимает, что не нашел в руководстве
	  того, что искал, он может захотеть посмотреть, а есть ли другие руководства или
	  иные источники информации по той же теме. Список таких источников содержится в
	  поле SEE ALSO:
	</para>
	<para>
	  <screen format="linespecific">user@desktop ~ $ man man
...
SEE ALSO
    apropos(1), whatis(1), less(1), groff(1), man.conf(5).</screen>
	</para>
	<para>
	  Справочные руководства делятся на разделы – в зависимости от типа
	  описываемых объектов. Если один и тот же термин описывается в нескольких
	  разделах, необходимо явно указать, какой из них использовать,
	  например, <command moreinfo="none">man 3 printf</command> для 3-го раздела руководств.
	</para>
	<para>
	  Всего существует 8 разделов руководств:
	</para>
	<para>
	  <orderedlist inheritnum="ignore" continuation="restarts">
	    <listitem>пользовательские утилиты и прочие инструменты</listitem>
	    <listitem>системные вызовы</listitem>
	    <listitem>библиотечные функции</listitem>
	    <listitem>внешние устройства (и их представление в системе)</listitem>
	    <listitem>форматы и таблицы (типы файлов, протоколы и прочее)</listitem>
	    <listitem>игры и всевозможные <quote>ненужные</quote> утилиты</listitem>
	    <listitem><quote>остальное</quote>, т. е. то, что не подходит под другие
	      разделы</listitem>
	    <listitem>команды и инструменты системного администратора</listitem>
	  </orderedlist>
	</para>
      </sect3>
      <sect3 id="shell-base-help-mansearch">
	<title>Поиск по руководствам</title>
	<para>
	  В примере выше в поле SEE ALSO обнаружились ссылки на руководства
	  по <command moreinfo="none">less</command>, <command moreinfo="none">groff</command> (программе форматирования
	  страницы руководства), структуре конфигурационного файла для man, а также по
	  двум сопутствующим командам с такими говорящими
	  названиями <quote>apropos</quote> и <quote>whatis</quote>. Как и
	  команда <command moreinfo="none">apropos</command>, <command moreinfo="none">whatis</command> ищет подстроку в
	  некоторой базе данных, состоящей из полей NAME всех страниц помощи в
	  системе. Различие между ними в том, что <command moreinfo="none">whatis</command> –
	  только среди имен объектов (в левых частях полей NAME), а apropos –
	  по всей базе. В результате у <command moreinfo="none">whatis</command> получается список кратких
	  описаний объектов с именами, включающими искомое слово, а
	  у <command moreinfo="none">apropos</command> – список, в котором это слово
	  упоминается. Для того, чтобы это узнать, все равно пришлось один раз прочесть
	  документацию.
	</para>
	<para>
	  Описания объектов, выводимые <command moreinfo="none">whatis</command>
	  или <command moreinfo="none">apropos</command>, отличаются числом в скобках – номером
	  раздела:
	</para>
	<para>
	  <screen format="linespecific">user@desktop ~ $ whatis passwd
passwd (1) - update a user's authentication tokens(s)
passwd (5) - password file
passwd (8) - manual page for passwd wrapper version 1.0.5</screen>
	</para>
      </sect3>
      <sect3 id="shell-base-help-info">
	<title>Программа info</title>
	<para>
	  Другой источник информации о UNIX (а точнее, в UNIX-подобных системах,
	  базирующихся на программном обеспечении от GNU) и составляющих ее
	  программах – справочная подсистема <command moreinfo="none">info</command>. Страница
	  руководства, несмотря на обилие ссылок различного типа,
	  остается <quote>линейным</quote> текстом, структурированным только
	  логически. Документ info структурирован прежде всего
	  топологически – это настоящий гипертекст, в котором множество
	  небольших страниц объединены в дерево. В каждом разделе документа info всегда
	  есть оглавление, из которого можно перейти сразу к нужному подразделу, откуда
	  всегда можно вернуться обратно. Кроме того, info-документ можно читать и как
	  непрерывный текст, поэтому в каждом подразделе есть ссылки на предыдущий и
	  последующий подразделы.
	</para>
	<para>
	  Программа <application moreinfo="none">info</application> использует весь экран: на большей его
	  части она показывает текст документа, а первая и две последних строки ориентации
	  в его структуре.
	</para>
	<para>
	  Одна или несколько страниц, которые можно перелистывать
	  клавишей <keysym>Пробел</keysym> или <keycap moreinfo="none">Page Up</keycap>/<keycap moreinfo="none">Page
	  Down</keycap> – это узел (node). Узел содержит обычный текст и меню
	  (menu) – список ссылок на другие узлы, лежащие в дереве на более
	  низком уровне. Ссылки внутри документа имеют вид <quote>* имя_узла::</quote> и
	  перемещать по ним курсор можно клавишей <keycap moreinfo="none">Tab</keycap>, а переходить к
	  просмотру выбранного узла –
	  клавишей <keycap moreinfo="none">Enter</keycap>. Вернуться к предыдущему просмотренному узлу
	  можно клавишей <keycap moreinfo="none">l</keycap> (oт <quote>Last</quote>). И, главное, выйти из
	  программы info можно, нажав <keycap moreinfo="none">q</keycap> (<quote>Quit</quote>). Более
	  подробную справку об управлении программой info можно в любой момент получить у
	  самой <application moreinfo="none">info</application>, нажав <keycap moreinfo="none">?</keycap>.
	</para>
      </sect3>
      <sect3 id="shell-base-help-docs">
	<title>Документация, поставляемая с программой</title>
	<para>
	  Некоторые объекты системы не имеют документации ни в формате man, ни в формате
	  info. В этом случае можно надеяться, что при них есть сопроводительная
	  документация, не имеющая, увы, ни стандартного формата, ни тем более ссылок на
	  руководства по другим объектам системы. Такая документация (равно как и примеры
	  использования объекта), обычно помещается в
	  каталог <filename moreinfo="none">/usr/share/doc/имя_объекта</filename>. Как правило, <emphasis>имя
	  объекта</emphasis> здесь – это имя программы и её текущая версия.
	</para>
	<para>
	  Существует ещё одна довольно распространённая ситуация, в которой обширная
	  документация по продукту, расположенная в
	  директории <filename moreinfo="none">/usr/share/doc/</filename> выходит далеко за рамки man или
	  info – если продукт достаточно сложен и имеет собственную
	  структурированную и очень объёмную документацию. Примерами могут служить
	  веб-сервер <application moreinfo="none">Apache</application> или почтовый
	  сервер <application moreinfo="none">Postfix</application>.
	</para>
      </sect3>
      <sect3 id="shell-base-help-modern">
	<title>Современные системы документации</title>
	<para>
	  В современных свободных версиях UNIX существуют проекты, целью которых является
	  объединение и структуризация документации на основе XML. Одним из них является
	  проект Scrollkeeper, который объединяет всю документацию (в первую очередь в
	  современных оконных средах GNOME и KDE) и позволяют просматривать её с помощью
	  простого браузера, предоставляют поиск, индекс и т.п..
	</para>
	<para>
	  Однако, доля этих средств документации всё еще очень мала. Основным средством
	  для большинства UNIX систем остаются страницы руководств.
	</para>
      </sect3>
    </sect2>      
    <sect2 id="shell-base-summary">
      <title>Резюме</title>
      <para><link linkend="small-pres-3-12">Презентация 3-12: резюме</link></para>
      <para>
	Командная строка UNIX является основным средством работы администратора
	системы. Это происходит еще и потому, что в настоящее время широко распространены
	средства удалённой работы с системой через сетевые терминалы.
      </para>
      <para>
	Интерфейс командной строки состоит из специального устройства терминала, который
	инкапсулирует особенности физических устройств ввода и вывода информации, и
	командной оболочки – специального процесса, который отвечает за
	интерактивную работу пользователя, исполняет команды и т.п..
      </para>
      <para>
	Командная строка имеет строго определённый формат и состоит из приглашения и
	команды. Команда может иметь параметры и аргументы. Каждая команда возвращает
	вспециальный код завершения. Несколько команд могут быть объединены в одну.
      </para>
      <para>
	Каждый процесс имеет свое программное окружнение, которое достаётся ему в
	наследство от родительского процесса. Окружение состоит из переменных, среди
	которых выделяют ряд стандартных.
      </para>
      <para>
	Современные командные оболочки (в частности, <application moreinfo="none">bash</application>)
	имеют ряд дополнительных удобных возможностей интерфейса пользователя, например,
	псевдонимы, автодополнение, шаблоны имен и встроенные средства программирования.
      </para>
      <para>
	В UNIX существует огромное количество документации, основная часто которой
	сосредоточена в страницах руководств (man). Также выделяют расширенные
	руководства (info) и документацию, поставляемую с программой (которую можно найти
	в директории <filename moreinfo="none">/usr/share/doc</filename>).
      </para>
      <para><emphasis>Ключевые термины: </emphasis><xref linkend="def-control-chars"/>, <xref linkend="def-terminal"/>, <xref linkend="def-control-seq"/>, <xref linkend="def-command-string"/>, <xref linkend="def-command-shell"/>, <xref linkend="def-vc"/>, <xref linkend="def-xterms"/>, <xref linkend="def-termtype"/>, <xref linkend="def-command-prompt"/>, <xref linkend="def-cmd-name"/>, <xref linkend="def-internal-cmd"/>, <xref linkend="def-cmd-params"/>, <xref linkend="def-cmd-args"/>, <xref linkend="def-cmd-redirection"/>, <xref linkend="def-return-value"/>, <xref linkend="def-conv"/>, <xref linkend="def-reservesd-chars"/>, <xref linkend="def-env"/>, <xref linkend="def-env-var"/>, <xref linkend="def-history"/>, <xref linkend="def-alias"/>, <xref linkend="def-template"/>, <xref linkend="def-manpage"/></para>
    </sect2>    
    <sect2 id="shell-base-additional">
      <title>Дополнительные материалы</title>
      <para>
	<orderedlist inheritnum="ignore" continuation="restarts">
	  <listitem>
	    Д. Тейнсли <emphasis>Linux и UNIX: программирование в shell. Руководство
	    разработчика</emphasis>. – К.: Издательская группа BHV,
	    2001. – 464 с.: ил.
	  </listitem>
	  <listitem>
	    Курячий Г.В., Маслинский К.А. <emphasis>Операционная система
	    Linux</emphasis>. – М.: Интуит.Ру, 2005. – 392 с.: ил.
	  </listitem>
	  <listitem>
	    Курячий Г.В. <emphasis>Операционная система UNIX</emphasis>. –
	    М.: Интуит.Ру, 2004. – 292 с.: ил.
	  </listitem>
	  <listitem>
	    Соловьёв А. <emphasis>Программирование на shell</emphasis>. –
	    <ulink url="http://www.linuxcenter.ru/lib/books/shell/">http://www.linuxcenter.ru/lib/books/shell/</ulink>
	  </listitem>
	</orderedlist>
      </para>
    </sect2>    
    <sect2 id="shell-base-questions"><title>Вопросы</title><para><orderedlist><listitem><xref linkend="quest-3-1"/></listitem><listitem><xref linkend="quest-3-2"/></listitem><listitem><xref linkend="quest-3-3"/></listitem><listitem><xref linkend="quest-3-4"/></listitem><listitem><xref linkend="quest-3-5"/></listitem><listitem><xref linkend="quest-3-6"/></listitem></orderedlist></para></sect2>
    <sect2 id="shell-base-presentaion"><title>Презентация</title><para><figure id="small-pres-3-01" float="0"><title>Презентация 3-01: терминал и командная строка</title><graphic fileref="pres/small-lect3-01.png"/></figure></para><para><figure id="small-pres-3-02" float="0"><title>Презентация 3-02: одновременный доступ к системе</title><graphic fileref="pres/small-lect3-02.png"/></figure></para><para><figure id="small-pres-3-03" float="0"><title>Презентация 3-03: формат командной строки</title><graphic fileref="pres/small-lect3-03.png"/></figure></para><para><figure id="small-pres-3-04" float="0"><title>Презентация 3-04: исполнение команды</title><graphic fileref="pres/small-lect3-04.png"/></figure></para><para><figure id="small-pres-3-05" float="0"><title>Презентация 3-05: возвращаемое значение</title><graphic fileref="pres/small-lect3-05.png"/></figure></para><para><figure id="small-pres-3-06" float="0"><title>Презентация 3-06: способы объединения команд</title><graphic fileref="pres/small-lect3-06.png"/></figure></para><para><figure id="small-pres-3-07" float="0"><title>Презентация 3-07: служебные символы</title><graphic fileref="pres/small-lect3-07.png"/></figure></para><para><figure id="small-pres-3-08" float="0"><title>Презентация 3-08: программное окружение</title><graphic fileref="pres/small-lect3-08.png"/></figure></para><para><figure id="small-pres-3-09" float="0"><title>Презентация 3-09: возможности командной оболочки</title><graphic fileref="pres/small-lect3-09.png"/></figure></para><para><figure id="small-pres-3-10" float="0"><title>Презентация 3-10: справочная подсистема</title><graphic fileref="pres/small-lect3-10.png"/></figure></para><para><figure id="small-pres-3-11" float="0"><title>Презентация 3-11: страницы руководств (man)</title><graphic fileref="pres/small-lect3-11.png"/></figure></para><para><figure id="small-pres-3-12" float="0"><title>Презентация 3-12: резюме</title><graphic fileref="pres/small-lect3-12.png"/></figure></para></sect2>
  </sect1>
  <sect1 id="shell-maincmd">
    <title>Методические указания по основным командам UNIX</title>
    <para>
      Описание команд разбито на несколько разделов – по функциональному
      назначению команд.
    </para>
    <sect2 id="shell-maincmd-fs">
      <title>Команды по работе с файловой системой</title>
      <para>
	<variablelist>
	  <varlistentry>
	    <term><emphasis id="def-cmd-pwd" xreflabel="pwd">pwd</emphasis></term>
	    <listitem>
	      <para>
		Команда <command moreinfo="none">pwd</command> (print working directory –
		печать pабочего каталога) позволяет узнать имя текущего каталога:
	      </para>
	      <para>
		<informalexample>
		  <screen format="linespecific">user@desktop / $ pwd 
/</screen>
		</informalexample>
	      </para>
	      <para>
		Т.е. в настоящее вpемя Вы находитесь в коpневом каталоге.
	      </para>
	      <para>
		Если вы в пpоцессе путешествия по файловой системе
		вы <quote>потеpялись</quote> и не знаете, где находитесь, пpосто набеpите
		эту команду, котоpая выведет на экpан полное имя текущего каталога,
		начиная от коpневого.
	      </para>
	      <para>
		Если вместо имени текущего каталога на экpан будет выдано диагностическое
		сообщение типа: <computeroutput moreinfo="none">Cannot open..</computeroutput> (<quote>Не
		может открыть..</quote>) и <computeroutput moreinfo="none">Read error
		in..</computeroutput> (<quote>Ошибка считывания в..</quote>), то значит
		пpоизошло наpушение файловой системы, возможно у Вас не хватает прав на
		чтение этой директории.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-cd" xreflabel="cd">cd</emphasis></term>
	    <listitem>
	      <para>
		Команда <command moreinfo="none">cd</command> используется для смены текущего каталога,
		т.е. для пеpехода в дpугой каталог и является встpоенной командой оболочки
		(аналог соответствующей команды для DOS-систем). В качестве аpгумента этой
		команды укажите имя каталога, в котоpый Вы хотите пеpейти. Напpимеp:
	      </para>
	      <para>
		Например, <command moreinfo="none">cd /etc</command> – пеpейти в каталог
		<filename moreinfo="none">/etc</filename>, т.е. сделать его текущим.
	      </para>
	      <para>
		Если Вы хотите пеpейти в подкаталог, то <quote>/</quote> не указывается.
		Допустим Вы находитесь в каталоге <filename moreinfo="none">/usr</filename> и вам надо
		пеpейти в каталог <filename moreinfo="none">local</filename>, котоpый является
		подкаталогом этого каталога. В этом случае вы можете выполнить следующие
		действия:
	      </para>
	      <para>
		<informalexample>
		  <screen format="linespecific">user@desktop usr $ pwd
/usr
user@desktop usr $ cd local
user@desktop local $ pwd
/usr/local</screen>
		</informalexample>
	      </para>
	      <para>
		Таким обpазом каталог <filename moreinfo="none">/usr/local</filename> стал текущим.
	      </para>
	      <para>
		Если ввести команду <command moreinfo="none">cd</command> без аpгументов, то вы веpнетесь
		в свой домашний (начальный) каталог. Пpи этом используется системная
		пеpеменная окружения <envar>HOME</envar>.
	      </para>
	      <para>
		<informalexample>
		  <screen format="linespecific">user@desktop usr $ cd
user@desktop ~ $ pwd
/home/user</screen>
		</informalexample>
	      </para>
	      <para>
	        Пpиведем еще несколько пpимеpов использования этой команды:
		<itemizedlist>
		  <listitem><command moreinfo="none">cd ..</command> – веpнуться в pодительский
		  каталог (подняться на один каталог ввеpх по деpеву);</listitem>
		  <listitem><command moreinfo="none">cd ../..</command> – подняться на два
		  каталога ввеpх по деpеву;</listitem>
		  <listitem><command moreinfo="none">cd /</command> – пеpейти в коpневой
		  каталог;</listitem>
		  <listitem><command moreinfo="none">cd ../local</command> – веpнуться в
		  pодительский каталог и пеpейти в его
		  подкаталог <filename moreinfo="none">local</filename>.</listitem>
		</itemizedlist>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-ls" xreflabel="ls">ls</emphasis></term>
	    <listitem>
	      <para>
		Команды <command moreinfo="none">ls</command> выдает pазличную инфоpмацию о файлах и
		каталогах (аналог команды <command moreinfo="none">DIR</command> для DOS-систем).
		Как и большинство команд, <command moreinfo="none">ls</command> имеет возможные аpгументы
		и параметры (флаги), котоpые позволяют изменить её действие.
	      </para>
	      <para>
		Пеpейдите с помощью команды<command moreinfo="none">cd /</command> в коpневой каталог и
		посмотpите его содеpжимое. Если опции не указаны команда выводит
		отсоpтиpованные по алфавиту имена файлов и каталогов.
	      </para>
	      <para>
		<informalexample>
		  <screen format="linespecific">user@desktop / $ ls
bin/   dev/  home/  mnt/  proc/  sbin/  tmp/  var/
boot/  etc/  lib/   opt/  root/  sys/   usr/</screen>
		</informalexample>
	      </para>
	      <para>
		К сожалению, пока не очень понятно, что является каталогом, а что
		файлом. Помочь в этом может следующая команда, котоpая выдает инфоpмацию в
		pасшиpенном фоpмате, котоpый содеpжит больший объем инфоpмации о каждом
		файле (пpава доступа, pазмеp, дата последней модификации и т.д.):
	      </para>
	      <para>
		<informalexample>
		  <screen format="linespecific">user@desktop / $ ls -l
итого 19
drwxr-xr-x   2 root root  3640 Окт 10 10:14 bin/
drwxr-xr-x   3 root root   432 Сен  7 01:09 boot/
drwxr-xr-x  16 root root 13360 Окт 11 18:24 dev/
drwxr-xr-x  61 root root  3976 Окт 11 18:24 etc/
drwxr-xr-x   6 root root   168 Авг 17 17:04 home/
drwxr-xr-x  10 root root  4688 Окт  8 20:40 lib/
drwxr-xr-x   8 root root   216 Авг 24 12:56 mnt/
drwxr-xr-x   5 root root   144 Июн 10 10:15 opt/
dr-xr-xr-x  96 root root     0 Окт 11  2005 proc/
drwx------  10 root root   432 Окт 11 00:38 root/
drwxr-xr-x   2 root root  4200 Окт 10 10:14 sbin/
drwxr-xr-x  10 root root     0 Окт 11  2005 sys/
drwxrwxrwt  18 root root  2608 Окт 11 21:27 tmp/
drwxr-xr-x  15 root root   520 Авг 28 14:36 usr/
drwxr-xr-x  13 root root   360 Июн  4 20:37 var/</screen>
		</informalexample>
	      </para>
	      <para>
		Столбцы слева направо: тип файла и права доступа, число жестких ссылок,
		имя владельца, группа владельца, размер в байтах, время модификации, имя.
	      </para>
	      <para>
		Если в качестве опеpанда указать имя файла то <command moreinfo="none">ls</command> выдаст
		информацию только об этом файле:
	      </para>
	      <para>
		<informalexample>
		  <screen format="linespecific">user@desktop / $ ls -l bin/ls
-rwxr-xr-x  1 root root 78212 Окт  8 20:56 bin/ls*</screen>
		</informalexample>
	      </para>
	      <para>
		Если качестве опеpанда указать имя каталога, то будет выдано содеpжимое
		этого каталога, т.е. имена файлов в этом каталоге:
	      </para>
	      <para>
		<informalexample>
		  <screen format="linespecific">user@desktop / $ ls -l bin
итого 7175
-rwxr-xr-x  1 root root    3260 Окт 10 10:14 arch*
lrwxrwxrwx  1 root root      10 Сен  7 00:29 awk -&gt; gawk-3.1.5*
-rwxr-xr-x  1 root root   14928 Окт  8 20:56 basename*
-rwxr-xr-x  1 root root  718312 Июл 10 21:36 bash*</screen>
		</informalexample>
	      </para>
	      <para>
		Если не указаны какие-либо опеpанды, будет выдано содеpжимое текущего
		каталога. В случае, если указано несколько опеpандов, сначала выводится
		инфоpмация о файлах, а потом о каталогах. Вывод пpоисходит в алфавитном
		поpядке.
	      </para>
	      <para>
		Можно использовать следующие опции:
		<variablelist>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-C</parameter></term>
		    <listitem>
		      Вывод   содеpжимого   каталога   в   несколько   столбцов.
		      Пpинимается по умолчанию пpи выводе на теpминал.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-F</parameter></term>
		    <listitem>
		      Добавить <quote>слэш</quote> (<literal moreinfo="none">/</literal>) к имени
		      каталога, звездочку (<literal moreinfo="none">*</literal>) к имени исполнимого
		      файла, знак (<literal moreinfo="none">@</literal>) к каждой символической ссылке.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-R</parameter></term>
		    <listitem>
		      Рекуpсивный обход встpетившихся подкаталогов. Может быть полезна для
		      создания списка всех файлов системы.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-c</parameter></term>
		    <listitem>
		      Вывод соpтиpуется по вpемени последней модификации файла.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-d</parameter></term>
		    <listitem>
		      Вывод только имени каталога (но не содеpжимого).
		      <informalexample>
			<screen format="linespecific">user@desktop / $ ls -ld bin
drwxr-xr-x  2 root root 3640 Окт 10 10:14 bin/</screen>
		      </informalexample>
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-f</parameter></term>
		    <listitem>
		      Вывод не сортируется, т.е. поpядок  вывода  соответствует
		      поpядку файлов в каталоге.
		      <informalexample>
			<screen format="linespecific">user@desktop / $ ls -f
./   bin/  etc/  mnt/  tmp/  var/  boot/  proc/  root/
../  dev/  lib/  opt/  sys/  usr/  home/  sbin/</screen>
		      </informalexample>
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-i</parameter></term>
		    <listitem>
		      Для каждого файла выводится номер индексного дескpиптоpа
		      (уникальный номеp файла).
		      <informalexample>
			<screen format="linespecific">user@desktop / $ ls -f
   2797 bin/   4816541 etc/      3306 mnt/   4843384 root/  4816986 tmp/
4843263 boot/     3299 home/  4816984 opt/   4843270 sbin/      351 usr/
   1301 dev/   4816821 lib/         1 proc/        1 sys/   4816990 var/</screen>
		      </informalexample>
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-r</parameter></term>
		    <listitem>
		      Изменение поpядка соpтиpовки на обpатный (по алфавиту или по вpемени
		      последнего использования).
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-t</parameter></term>
		    <listitem>
		      Сортиpовать по вpемени последней модификации файла (последний
		      модифициpованный выводится пеpвым).
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-1</parameter></term>
		    <listitem>
		      Вывод одного имени на каждой стpоке. Пpинимается по умолчанию пpи
		      выводе не на терминал.
		    </listitem>
		  </varlistentry>
		</variablelist>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-mkdir" xreflabel="mkdir">mkdir</emphasis></term>
	    <listitem>
	      <para>
		В пpоцессе освоения системы Вам необходимо будет создать свою собственную
		стpуктуpу каталогов. После установки системы, каталогов в ней довольно
		немного и в них пока еще тpудно затеpяться начинающему пользователю. В
		пpоцессе pасшиpения файловой системы вам пpидется постоянно создавать
		новые и уничтожать стаpые каталоги, поэтому pассмотpим, как это все можно
		сделать.
	      </para>
	      <para>
		Создать каталог довольно легко.  Для этого существует
		команда <command moreinfo="none">mkdir</command> (аналог её есть и в DOS системах). В
		качестве аргумента необходимо указать имя создаваемого каталога:
		<synopsis format="linespecific">mkdir [-p] имя_каталога</synopsis>
	      </para>
	      <para>
		<informalexample>
		  <screen format="linespecific">user@desktop / $ cd
user@desktop ~ $ mkdir test
user@desktop ~ $ ls
test/</screen>
		</informalexample>
	      </para>
	      <para>
		Стандартные элементы точка (.) для самого каталога и две точкт (..)  для
		его родительского каталога создаются автоматически.
	      </para>
	      <para>
		Команда <command moreinfo="none">mkdir</command> может быть использована и для создания
		нижележащих подкаталогов непосpедственно из текущего каталога с указанием
		полного пути к ним. В этом случае все указанные в пути каталоги должны
		существовать и быть доступны. Если же Вам необходимо моздать иерархию
		каталогов, удобно пользоваться
		опцией <parameter class="command" moreinfo="none">-p</parameter>:
	      </para>
	      <para>
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ mkdir -p test/xxx/yyy/zzz
user@desktop ~ $ ls -R test
test:
xxx/

test/xxx:
yyy/

test/xxx/yyy:
zzz/

test/xxx/yyy/zzz:

</screen>
		</informalexample>
	      </para>
	      <para>
		Без использования опции <parameter class="command" moreinfo="none">-p</parameter> при
		попытке создать уже существующий каталог будет выдано соответствующее
		предупреждение.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-rmdir" xreflabel="rmdir">rmdir</emphasis></term>
	    <listitem>
	      <para>
		После создания pазнообpазнейших каталогов, чеpез некотоpое вpемя у вас
		возникнет естественное желание удалить некотоpые из них. В этом вам может
		помочь команда <command moreinfo="none">rmdir</command>. Ее фоpмат также пpост, как и
		фоpмат пpедыдущей команды <command moreinfo="none">mkdir</command>: 
		<synopsis format="linespecific">rmdir имя_каталога</synopsis>
	      </para>
	      <para>
		Команда <command moreinfo="none">rmdir</command> удаляет каталог, имя котоpого указано в
		качестве параметра. Удаляемый каталог должен быть пустым, то есть пеpед
		его уничтожением вы должны удалить все находящиеся в нем
		файлы. Пpактически это пpиходится делать очень pедко, так как с двумя
		этими пpоблемами успешно спpавляется команда <command moreinfo="none">rm</command>,
		котоpая будет pассмотpена позже.
	      </para>
	      <para>
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ rmdir test
rmdir: `test/': Directory not empty</screen>
		</informalexample>
	      </para>
	      <para>
		Указанные имена каталогов обрабатываются по поpядку. Пpи одновpеменном
		удалении каталога и его подкаталога, подкаталог должен быть удален pаньше.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-touch" xreflabel="touch">touch</emphasis></term>
	    <listitem>
	      <para>
		Команда <command moreinfo="none">touch</command> только и делает, что меняет время
		последнего доступа к файлу. Замечательной особенностью этой команды
		является то, что с ёё помощью можно создавать новые пустые
		файлы – если в качестве аргумента передаётся имя
		несуществующего файла:
	      </para>
	      <para>
		<informalexample>
		  <screen format="linespecific">user@desktop test $ ls
xxx/
user@desktop test $ touch file.test
user@desktop test $ ls -l
итого 0
-rw-r--r--  1 user users  0 Окт 12 00:01 test.file
drwxr-xr-x  3 user users 72 Окт 11 23:09 xxx/</screen>
		</informalexample>
	      </para>      
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-rm" xreflabel="rm">rm</emphasis></term>
	    <listitem>
	      <para>
		В пpоцессе pаботы с системой довольно часто возникает необходимость
		удаления файлов. Для этого существует команда <command moreinfo="none">rm</command>,
		котоpая позволяет удалять как файлы, так и каталоги. Пользоваться ей нужно
		с большой остоpожностью, так как UNIX-системы не имеют пpивычки, в отличии
		от Windows, пеpеспpашивать пользователя пеpед удалением файла, а делают
		это быстpо и навсегда. Поэтому, связи с тем, что в UNIX-системах нет
		пpивычных пpогpамм восстановления удаленных файлов, кpепко поду- майте
		пеpед тем, как что-то удалять.
	      </para>
	      <para>
		Команда <command moreinfo="none">rm</command> имеет следующий фоpмат:
                <synopsis format="linespecific">rm [-f | -i ] [-dRr ] имя_файла ...</synopsis>
	      </para>
	      <para>
		С помощью данной команды вы можете удалить файлы, имена котоpых указаны в
		качестве паpаметpов. Если файл защищен от записи и стандартным
		устройством ввода данных является терминал, пользователю будет выдан
		запpос на подтвеpждение удаления файла.
	      </para>
	      <para>
		Пpи попытке удаления каталога с помощью этой команды  будет  выдано
		сообщение об ошибке.
	      </para>
	      <para>
		Вы можете использовать следующие опции:
		<variablelist>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-d</parameter></term>
		    <listitem>
		      Если удаляемый файл окажется каталогом, то также его
		      удалить.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-f</parameter></term>
		    <listitem>
		      Удалить защищенный от записи файл без подтвеpждения.  Если данный
		      файл не существует, то не выводить сообщение об его
		      отсутствии. Опция <parameter class="command" moreinfo="none">-f</parameter> отменяет
		      предыдущую опцию <parameter class="command" moreinfo="none">-i</parameter>.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-i</parameter></term>
		    <listitem>
		      Запpашивать подтверждение на удаление любого файла, независимо от
		      того, является ли теpминал стандаpтным устpойством ввода или
		      нет. Опция <parameter class="command" moreinfo="none">-i</parameter> отменяет
		      предыдущую опцию <parameter class="command" moreinfo="none">-f</parameter>.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-r</parameter></term>
		    <listitem>
		      Удалить все файлы и подкаталоги данного каталога, а после этого
		      удалить и сам каталог.
		      Опция <parameter class="command" moreinfo="none">-R</parameter> подразумевает опцию
		      <parameter class="command" moreinfo="none">-d</parameter>. Если также указана опция
		      <parameter class="command" moreinfo="none">-i</parameter>, то пользователю выдается
		      запpос на подтвеpжение удаления файлов и каталогов.
		    </listitem>
		  </varlistentry>
		</variablelist>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-cp" xreflabel="cp">cp</emphasis></term>
	    <listitem>
	      <para>
		Программа копирует содержимое файла в файл с другим именем либо в другой
		каталог с сохранением существующего имени файла, также применяется для
		копирования каталогов с их содержимым. Программа имеет следующий формат:
                <synopsis format="linespecific">cp [-ipr] имя_файла ... имя_файла_назначения</synopsis>
	      </para>
	      <para>
		Вы можете использовать следующие опции:
		<variablelist>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-i</parameter></term>
		    <listitem>
		      Пользователю выдается запpос на подтвеpжение при перезаписи
		      существующих файлов и каталогов.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-p</parameter></term>
		    <listitem>
		      Сохранять существующий режим доступа к файлу.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-r</parameter></term>
		    <listitem>
		      Копирование каталога с его подкаталогами.
		    </listitem>
		  </varlistentry>
	      	</variablelist>
	      </para>
	      <para>
		Копирование файла в текущую директорию с новым именем:
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ cp /etc/resolv.conf resolv</screen>
		</informalexample>
	      </para>
	      <para>
		Копирование файла в текущую директорию с сохранением имени:
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ cp /var/log/apache/access_log .</screen>
		</informalexample>
	      </para>
	      <para>
		Копирование директории:
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ cp -r /etc/ppp /etc/ppp.old</screen>
		</informalexample>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-mv" xreflabel="mv">mv</emphasis></term>
	    <listitem>
	      <para>
		Переименование файла или перемещение одного либо нескольких файлов (или
		каталогов) в другой каталог. Формат команды:
		<synopsis format="linespecific">mv [-i | -f] имя_файла ... имя_файла_назначения</synopsis>
	      </para>
	      <para>
		При переносе в рамках одной файловой системы команда только меняет путевое
		имя файла, поэтому переименование и перенос идентичны по реализации.
	      </para>
	      <para>
		Вы можете использовать следующие опции:
		<variablelist>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-f</parameter></term>
		    <listitem>
		      Запрет запроса подтверждений при перезаписи существующих файлов.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-i</parameter></term>
		    <listitem>
		      Пользователю выдается запpос на подтвеpжение при перезаписи
		      существующих файлов и каталогов.
		    </listitem>
		  </varlistentry>
		</variablelist>
	      </para>
	      <para>
		Пример использования команды для переноса файла в каталог:
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ mv text/user.html text/htmls/</screen>
		</informalexample>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-ln" xreflabel="ln">ln</emphasis></term>
	    <listitem>
	      <para>
		Эта команда создаёт ссылки на файлы как жёсткие, так и символические. Она
		имеет следующий формат (аналогичный команде <command moreinfo="none">mv</command> по
		порядку аргументов):
		<synopsis format="linespecific">ln [-s] имя_файла имя_файла_ссылки</synopsis>
	      </para>
	      <para>
		Вы можете использовать следующие опции:
		<variablelist>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-f</parameter></term>
		    <listitem>
		      Запрет запроса подтверждений при перезаписи существующих файлов
		      (ссылок). 
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-s</parameter></term>
		    <listitem>
		      Создание символической ссылки.
		    </listitem>
		  </varlistentry>
		</variablelist>
	      </para>
	      <para>
		Примеры использования команды:
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ ln text/alex/linux.html working/linux-todo.html</screen>
		</informalexample>
		Создание символической ссылки на директорию:
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ ln -s images/my/photos photos</screen>
		</informalexample>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-du" xreflabel="du">du</emphasis></term>
	    <listitem>
	      <para>
		Команда выводит размер пространства на диске, занятого каталогом (и всеми
		его подкаталогами), в блоках (по умолчанию, 1 блок составляет 512
		байт). По умолчанию выводится информация о текущем каталоге.
	      </para>
	      <para>
		Программа имеет следующие параметры:
		<variablelist>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-a</parameter></term>
		    <listitem>
		      Выводить информацию не только о каталогах, но и о файлах.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-h</parameter></term>
		    <listitem>
		      Вывод размера директории в <quote>человеческом</quote> формате:
		      килобайтах, мегабайтах и т.п..
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-s</parameter></term>
		    <listitem>
		      Вывод только общего итога, без отображения промежуточной информации.
		    </listitem>
		  </varlistentry>
		</variablelist>
	      </para>
	      <para>
		Пример выполнения программы:
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ du -sh test
925K    test</screen>
		</informalexample>
	      </para>      
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-tar" xreflabel="tar">tar</emphasis></term>
	    <listitem>
	      <para>
		Команда <command moreinfo="none">tar</command> предназначена для архивации груп файлов и
		директории. Эта команда позволяет объединять группу файлов и директорий со
		всеми атрибутами в единый файл, который имеет
		расширение <quote>.tar</quote>. Полученный файл затем с помощью той же
		команды <command moreinfo="none">tar</command>. Команда <command moreinfo="none">tar</command> имеет
		множество опций, мы же остановимся на следующем формате использования
		команды: 
		<synopsis format="linespecific">tar [-c | -x] [-z | -j] -f имя_tar_файла имена_файлов_и_каталогов</synopsis>
	      </para>
	      <para>
		Опция <parameter class="command" moreinfo="none">-c</parameter> соответствует созданию
		архива, <parameter class="command" moreinfo="none">-x</parameter> –
		разворачивание архива. 
	      </para>
	      <para>
		Созданный архив можно также сжать с помощью
		архиваторов <application moreinfo="none">gzip</application>
		или <application moreinfo="none">bzip2</application>. Для этого применяются соответственно
		опции <parameter class="command" moreinfo="none">-z</parameter> и 
		<parameter class="command" moreinfo="none">-j</parameter>.
	      </para>
	      <para>
		Имя архива, который создаётся или разворачивается передаётся после
		параметра <parameter class="command" moreinfo="none">-f</parameter>.
	      </para>
	      <para>
		Рассмотрим примеры работы с этой программой:
		<itemizedlist>
		  <listitem>
		    Создание архива <filename moreinfo="none">etc.tar.bz2</filename>
		    директории <filename moreinfo="none">/etc</filename> с использованием
		    сжатия <application moreinfo="none">bzip2</application>:
		    <para>
		      <informalexample>
			<screen format="linespecific">user@desktop test $ tar -cjf etc.tar.bz2 /etc
user@desktop test $ ls
etc.tar.bz2
</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		  <listitem>
		    Разворачивание архива <filename moreinfo="none">etc.tar.bz2</filename>
		    в текущую директорию с использованием
		    разсжатия <application moreinfo="none">bzip2</application>:
		    <para>
		      <informalexample>
			<screen format="linespecific">user@desktop test $ tar -xjf etc.tar.bz2
user@desktop test $ ls
etc/ etc.tar.bz2
</screen>
		      </informalexample>
		    </para>  
		  </listitem>	  
		</itemizedlist>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-find" xreflabel="find">find</emphasis></term>
	    <listitem>
	      <para>
		При работе с файлами часто бывает необходимо найти что-нибудь. В UNIX для
		этого существует команда <command moreinfo="none">find</command>. В общем виде эта команда
		имеет следующий формат:
		<synopsis format="linespecific">find [где_искать] [условие_поиска] [действие]</synopsis>
	      </para>
	      <para>
		Первый аргумент команды <command moreinfo="none">find</command> –
		это <emphasis>имя директории</emphasis>, в которой производится поиск. По
		умолчанию, это текущая директория.
	      </para>		
	      <para>
		Далее указываются <emphasis>условия поиска</emphasis>, которые могут
		принимать следующие значения:
		<variablelist>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-name</parameter></term>
		    <listitem>
		      Имя файла. В нём можно использовать шаблоны, но при этом необходимо
		      заключить имя в двойные кавычки.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-type</parameter></term>
		    <listitem>
		      Тип файла: <literal moreinfo="none">f</literal> – обычный
		      файл, <literal moreinfo="none">d</literal> –
		      директория, <literal moreinfo="none">l</literal> – символическая ссылка и
		      т.п..
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-user</parameter></term>
		    <listitem>
		      Имя владельца файла или его уникальный идентификатор
		      (<acronym>UID</acronym>).
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-group</parameter></term>
		    <listitem>
		      Имя группы владельца файла или её уникальный идентификатор
		      (<acronym>GID</acronym>).
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-perm</parameter></term>
		    <listitem>
		      Права доступа файла.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-size</parameter></term>
		    <listitem>
		      Размер файла. Обычно за числом следует буква – в чём
		      измеряется размер (в блоках, байтах, килобайтах и т.п.).
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-atime</parameter></term>
		    <listitem>
		      Время доступа к файлу.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-ctime</parameter></term>
		    <listitem>
		      Время последнего изменения владельца файла.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-mtime</parameter></term>
		    <listitem>
		      Время последнего изменения содержимого файла.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-newer</parameter></term>
		    <listitem>
		      Поиск всех файлов новее указанного.
		    </listitem>
		  </varlistentry>
		</variablelist>
	      </para>
	      <para>
		Условия поиска могут быть объединены с помощью модификаторов:
		<parameter class="command" moreinfo="none">-a</parameter> – И, 
		<parameter class="command" moreinfo="none">-o</parameter> – ИЛИ, 
		<parameter class="command" moreinfo="none">\!</parameter> – НЕ,
		<parameter class="command" moreinfo="none">\(...\)</parameter> – группа условий.
	      </para>
	      <para>
		К найденым файлам могут применяться
		следующие <emphasis>действия</emphasis>:
		<variablelist>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-print</parameter></term>
		    <listitem>
		      Вывести на экран имя найденного файла вместе с путём. Это действие
		      выполняется по умолчанию.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-delete</parameter></term>
		    <listitem>
		      Удалить найденные файлы.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-exec</parameter> команда {}
		      \;</term>
		    <listitem>
		      Исполнение указанной команды для каждого найденного файла с
		      передачей имени файла в качестве артумента ({}).
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-ok</parameter> команда {}
		      \;</term>
		    <listitem>
		      Аналогична действию <parameter class="command" moreinfo="none">-exec</parameter>,
		      только для каждого файла запрашивается подьверждение перед
		      выполнением команды.
		    </listitem>
		  </varlistentry>
		</variablelist>		  
	      </para>
	      <para>
		Рассмотрим примеры использования команды:
		<itemizedlist>
		  <listitem>
		    Вывод всех файлов в текущей директории и поддиректориях:
		    <para>
		      <informalexample>
			<screen format="linespecific">user@desktop test $ find
.
./xxx
./xxx/yyy
./xxx/yyy/zzz
./test.file</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		  <listitem>
		    Вывод всех файлов в директории <filename moreinfo="none">/etc</filename>, начинающихся
		    на <quote>re</quote>:
		    <para>
		      <informalexample>
			<screen format="linespecific">user@desktop test $ find /etc -name "re*"
/etc/apm/resume.d
/etc/ppp/resolv.conf
/etc/pam.d/rexec
/etc/ssmtp/revaliases
/etc/conf.d/reslisa
/etc/init.d/reslisa
/etc/init.d/reboot.sh
/etc/resolv.conf</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		  <listitem>
		    Вывод всех поддиректорий в директории <filename moreinfo="none">/etc</filename>,
		    начинающихся на <quote>re</quote>:
		    <para>
		      <informalexample>
			<screen format="linespecific">user@desktop test $ find /etc -name "re*" -a -type d
/etc/apm/resume.d</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		  <listitem>
		    Вывод всех файлов в директории <filename moreinfo="none">/etc</filename>, изменённых
		    за последние сутки:
		    <para>
		      <informalexample>
			<screen format="linespecific">user@desktop test $ find /etc -mtime -1
/etc
/etc/mtab
/etc/env.d/01hostname
/etc/adjtime</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		  <listitem>
		    Вывод всех файлов в директории <filename moreinfo="none">/tmp</filename>, не
		    принадлежащих пользователю user:
		    <para>
		      <informalexample>
			<screen format="linespecific">user@desktop test $ find /tmp \! -user user
/tmp/.X11-unix
/tmp/.X11-unix/X0
/tmp/mc-root</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		  <listitem>
		    Удаление в текущей директории всех устаревших файлов (оканчивающихся
		    на <quote>~</quote>:
		    <para>
		      <informalexample>
			<screen format="linespecific">user@desktop test $ find -name "*~" -delete</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		  <listitem>
		    Вывод на экран имён всех текстовых файлов в домашней директории:
		    <para>
		      <informalexample>
			<screen format="linespecific">user@desktop test $ find ~ -name "*.txt" -exec echo {} \;
/home/user/a.txt
/home/user/unix_commands.txt</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		  <listitem>
		    Копирование всех текстовых файлов на дискету:
		    <para>
		      <informalexample>
			<screen format="linespecific">user@desktop test $ find ~ -name "*.txt" -exec cp {} /mnt/floppy/ \;</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		</itemizedlist>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-mkfifo" xreflabel="mkfifo">mkfifo</emphasis></term>
	    <listitem>
	      <para>
		Команда используется для создания специальных файлов: <emphasis>именовыных
		каналов</emphasis>. С помощью этих каналов можно осуществлять
		взаимодействие между процессами операционной системы.
	      </para>
	      <para>
		Для создания канала необходимо ввести команду <command moreinfo="none">mkfifo</command>,
		аргументом которой является имя файла канала:
		<informalexample>
		  <screen format="linespecific">user@desktop test $ mkfifo pipe</screen>
		</informalexample>
	      </para>
	      <para>
		Именованый канал аналогичен неименованному (который устанавливается с
		помощью символа <quote>|</quote>) – процессы могут писать в него
		и читать из него. При этом с каналом оперируют как с файлом:
		<informalexample>
		  <screen format="linespecific">user@desktop test $ echo "Hello, world." &gt; pipe
user@desktop test $ cat &lt; pipe
Hello, world.</screen>  
		</informalexample>
	      </para>
	      <para>
		Каналы, в отличие от файлов, только передают, но не сохраняют
		информацию. Например, последующие чтение канала приведёт к приостановке
		просматривающего процесса: пока не поступят новые данные.
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </para>
    </sect2> 
    <sect2 id="shell-maincmd-text">
      <title>Команды по работе с текстом</title>
      <para>
	В операционной системе UNIX большинство информации хранится в текстовом
	виде. Поэтому команды по обработке текстовой информации играют очень важную роль в
	этой операционной системе.
      </para>
      <para>
	<variablelist>
	  <varlistentry>
	    <term><emphasis id="def-cmd-echo" xreflabel="echo">echo</emphasis></term>
	    <listitem>
	      <para>
		Познакомимся еще с одной командой, аналог котоpой имеется в DOS-си-
		темах. Это команда <command moreinfo="none">echo</command> (эхо).
	      </para>
	      <para>
		Она имеет фоpмат:
                <synopsis format="linespecific">echo [-n] [arg ...] </synopsis>
	      </para>
	      <para>
		Команда <command moreinfo="none">echo</command> выводит на устройство стандартного вывода
		заданные ей аргументы, разделяя их пробелами и завершая их символом новой
		строки (\n).
	      </para>
	      <para>
		Эта команда удобна для формирования диагностических сообщений в командных
		файлах и для передачи известных данных в программном канале.
	      </para>
	      <para>
		С помощью следующей команды можно довольно пpосто создать пустой файл:
                <command moreinfo="none">echo &gt; имя_файла</command>.
	      </para>
	      <para>
		Возможен параметр <parameter class="command" moreinfo="none">-n</parameter> –
		не выводить завеpшaющий символ перевода строки.
	      </para>
	      <para>
		Интеpпpетатоp команд имеет встроенную команду <command moreinfo="none">echo</command>,
		которая имеет синтаксические различия с внешней
		командой <command moreinfo="none">echo</command>.  Следует знать, что пользователям,
		работающим с оболочкой, будет доступна встроенная
		команда <command moreinfo="none">echo</command>, если они не
		укажут <filename moreinfo="none">/bin/echo</filename>.
	      </para>
	      <para>
		Рассмотрим примеры использования этой команды:
		<itemizedlist>
		  <listitem>
		    <para>
		      Вывод сообщения <quote>Error reading sector</quote> на экpан:
		      <informalexample>
			<screen format="linespecific">user@desktop test $ echo "Error reading sector"
Error reading sector
user@desktop test $</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		  <listitem>
		    <para>
		      Вывод сообщения без завеpшающего символа новой стpоки:
		      <informalexample>
			<screen format="linespecific">user@desktop test $ echo -n "Error reading sector"
Error reading sectoruser@desktop test $</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		  <listitem>
		    <para>
		      Вывод сообщения в файл <filename moreinfo="none">file1</filename>:
		      <informalexample>
			<screen format="linespecific">user@desktop test $ echo "Error reading sector" &gt; file1</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		  <listitem>
		    <para>
		      Добавление сообщения к содеpжимому файла <filename moreinfo="none">file1</filename>:
		      <informalexample>
			<screen format="linespecific">user@desktop test $ echo "Error reading sector" &gt;&gt; file1</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		  <listitem>
		    <para>
		      Вывод имен файлов текущего каталога в алфавитном поpядке:
		      <informalexample>
			<screen format="linespecific">user@desktop test $ echo *</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		  <listitem>
		    <para>
		      Вывод списка файлов с именами, соответствующих шаблону.
		      Вывести имена файлов с pасшиpением .txt:
		      <informalexample>
			<screen format="linespecific">user@desktop test $ echo *.txt</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		</itemizedlist>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-cat" xreflabel="cat">cat</emphasis></term>
	    <listitem>
	      <para>
		Рассмотpим еще одну команду, котоpая может быть полезна пpи pаботе с
		файлами. Это команда <command moreinfo="none">cat</command> (аналог
		команды <command moreinfo="none">TYPE</command> для DOS-систем).
	      </para>		
	      <para>
		Команда <command moreinfo="none">cat</command> имеет следующий фоpмат:
                <synopsis format="linespecific">cat [-benstuv] [-] [file1 [file2 ...]]</synopsis>
	      </para>		
	      <para>
		Она по очеpеди читает указанные, как аpгументы файлы и выводит их
		содеpжимое на стандаpтное устpойство вывода.
	      </para>		
	      <para>
		Поименованный файл или файлы выводятся последовательно один за дpу- гим
		без пpомежутков. Если файл достаточно длинный, то можно пpиостано- вить
		вывод с помощью комбинации
		клавиш <keycombo moreinfo="none"><keycap moreinfo="none">Ctrl</keycap><keycap moreinfo="none">S</keycap></keycombo>. Для
		пpодолжения вывода нажмите любую клавишу. Окончание ввода производится
		комбинацией <keycombo moreinfo="none"><keycap moreinfo="none">Ctrl</keycap><keycap moreinfo="none">D</keycap></keycombo>.
	      </para>
	      <para>
		Операнды обрабатываются в порядке их pазмещения в командной строке. Если
		не указан ни один файл или указана опция (-), команда читает данные со
		стандаpтного устpойства ввода.
	      </para>
	      <para>
		Вы можете использовать следующие опции:
		<variablelist>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-n</parameter></term>
		    <listitem>
		      Нумеpовать стpоки начиная с 1.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-b</parameter></term>
		    <listitem>
		      Подразумевает опцию <parameter class="command" moreinfo="none">-n</parameter>, но не
		      нумеpует пустые стpоки.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-e</parameter></term>
		    <listitem>
		      Подразумевает опцию <parameter class="command" moreinfo="none">-v</parameter> и
		      отображает знак доллара ($) в конце каждой строки (визуализация
		      символа пеpевода стpоки).
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-s</parameter></term>
		    <listitem>
		      Пpи наличии идущих подpяд пустых стpок выводить  только
		      одну.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-t</parameter></term>
		    <listitem>
		      Подразумевает
		      опцию <parameter class="command" moreinfo="none">-v</parameter>. Выводит cимволы
		      табуляции как ^I.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-u</parameter></term>
		    <listitem>
		      Вывод не буферизуется, то есть символы из входного файла
		      записываются в стандаpтный вывод без задеpжки, как только они были
		      пpочитаны.  По умолчанию вывод буфеpизуется, то есть символы могут
		      накапливаться в пpомежуточном буфеpе.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-v</parameter></term>
		    <listitem>
		      Отображение непечатных символов.  Упpавляющие символы выводятся в
		      виде ^X (CRTL+X), символ DEL (восьмеричное 0177) как ^?.  Символы не
		      входящие в стандаpтный ASCII-набоp (напpимеp, символы киppилицы с
		      набоpом стаpших pазpядов) выводятся как <quote>M-x</quote>, где
		      x – опpеделяемый младшими семи битами символ.
		    </listitem>
		  </varlistentry>
		</variablelist>
	      </para>
	      <para>
		Рассмотрим примеры использования команды:
		<itemizedlist>
		  <listitem>
		    <para>
		      Файл <filename moreinfo="none">file</filename> выводится на устройство стандартного
		      вывода:
		      <informalexample>
			<screen format="linespecific">user@desktop test $ cat file</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		  <listitem>
		    <para>
		      Сцепление (слияние) файлов <filename moreinfo="none">file1</filename> и <filename moreinfo="none">file2</filename>, после чего они помещаются в файл <filename moreinfo="none">file3</filename>:
		      <informalexample>
			<screen format="linespecific">user@desktop test $ cat file1 file2 &gt; file3</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		  <listitem>
		    <para>
		      Пpисоединение файла <filename moreinfo="none">file1</filename> к концу
		      файла <filename moreinfo="none">file2</filename>:
		      <informalexample>
			<screen format="linespecific">user@desktop test $ cat file1 &gt;&gt; file2</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		  <listitem>
		    <para>
		      Вывод содеpжимого файла с нумеpацией  стpок,  но  без  нумеpации
		      пустых стpок:
		      <informalexample>
			<screen format="linespecific">user@desktop test $ cat -b file1
1  Number 1
2  Number 2
3  Number 3
4  Number 4


5  Number 5</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		  <listitem>
		    <para>
		      Нумеpация всех стpок:
		      <informalexample>
			<screen format="linespecific">user@desktop test $ cat -n file1
1  Number 1
2  Number 2
3  Number 3
4  Number 4
5
6
7  Number 5</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		</itemizedlist>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-less" xreflabel="less">less</emphasis></term>
	    <listitem>
	      <para>
		Команда <command moreinfo="none">less</command> используется для просмотра файлов, размер
		которых превышает размер экрана. Пользователю предоставляется
		интерактивынй интерфейс, в котором текст можно пролистывать, производить
		по нему поиск и т.п..
	      </para>
	      <para>
		Имя просматриваемого файла необходимо указать в качестве аргумента
		программы: 
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ less README.txt</screen>
		</informalexample>
	      </para>
	      <para>
		Управлять программой <command moreinfo="none">less</command> просто: страницы
		перелистываются пробелом, а когда читать надоест, надо нажать
		<keycap moreinfo="none">q</keycap> (Quit). Перелистывать страницы можно и клавишами
		<keycap moreinfo="none">Page Up</keycap>/<keycap moreinfo="none">Page Down</keycap>, для сдвига на одну
		строку вперед можно применять <keycap moreinfo="none">Enter</keycap> или стрелку вниз, а
		на одну строку назад – стрелку вверх. Переход на начало и конец
		текста выполняется по командам <keycap moreinfo="none">g</keycap> и <keycap moreinfo="none">G</keycap>
		соответственно (Go). Полный список того, что можно делать с текстом
		в <command moreinfo="none">less</command>, выводится по команде <keycap moreinfo="none">h</keycap>
		(help). Для поиска и подстветки интересующего понятия можно
		воспользоваться командой <keycap moreinfo="none">/</keycap>, после которой необходимо
		ввести интересующий Вас термин – по нажатию
		клавиши <keycap moreinfo="none">Enter</keycap>, курсор перейдёт к первому упоминанию
		термина, который будет выделен серым цветом. Последующие
		нажатия <keycap moreinfo="none">/</keycap> и <keycap moreinfo="none">Enter</keycap> приведут к продолжению
		поиска слова по документу.
	      </para>
	      <para>
		Программа <command moreinfo="none">less</command> используется в качестве основы 
		команды <command moreinfo="none">man</command> – при просмотре страниц руководств.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-head" xreflabel="head">head</emphasis></term>
	    <listitem>
	      <para>
		Команда выводит на экран первые несколько строк файла. По умолчанию
		выводится первые 10 строк. Имя выводимого файла указывается в качестве
		аргумента программы, и если оно не задано, производится чтение информации
		со стандартного входа.
	      </para>
	      <para>
		С помощью параметра <parameter class="command" moreinfo="none">-n</parameter> можно задать
		число строк от начала файлы, которые будут выведены на экран. Например:
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ head -n 3 /etc/inittab
#
# /etc/inittab:  This file describes how the INIT process should set up
#                the system in a certain run-level.</screen>
		</informalexample>
	      </para>		
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-tail" xreflabel="tail">tail</emphasis></term>
	    <listitem>
	      <para>
		Команда выводит на экран последние несколько строк файла. По умолчанию
		выводятся последние 10 строк. Имя выводимого файла указывается в качестве
		аргумента программы, и если оно не задано, производится чтение информации
		со стандартного входа.
	      </para>
	      <para>
		С помощью параметра <parameter class="command" moreinfo="none">-n</parameter> можно задать
		число строк от конца файла, которые будут выведены на экран. Например:
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ tail -n 5 /var/log/emerge.log
1130052968: Started emerge on: Oct 23, 2005 11:36:08
1130052968:  *** emerge --fetchonly samba
1130052969:  &gt;&gt;&gt; emerge (1 of 1) net-fs/samba-3.0.20b to /
1130052971:  *** Finished. Cleaning up...
1130052971:  *** terminating.</screen>
		</informalexample>
		Таким способом удобно просматривать последние записи системных журналов.
	      </para>
	      <para>
		Другим важным параметром команды
		является <parameter class="command" moreinfo="none">-f</parameter>: команда ожидает
		изменения в конце фала и отображает их на экране. Часто это используется
		при просмотре постоянно увеличивающихся файлов. Для завершения команды
		нажмите <keycombo moreinfo="none"><keycap moreinfo="none">Ctrl</keycap><keycap moreinfo="none">C</keycap></keycombo>.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-cut" xreflabel="cut">cut</emphasis></term>
	    <listitem>
	      <para>
		Команда позволяет выводить указанные столбцы или записи из одного или
		нескольких файлов. Столбцом называется именно столбец – символы
		с одной и той же позицией в строке, записи же разделяюся символами
		табуляции. И столбцы и записи задаются указанием их порядкового номера в
		строке. 
	      </para>
	      <para>
		Вы можете использовать следующие опции:
		<variablelist>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-c</parameter>список</term>
		    <listitem>
		      вывод столбцов, указанных агрументом <emphasis>список</emphasis>;
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-f</parameter>список</term>
		    <listitem>
		      вывод полей, указанных агрументом <emphasis>список</emphasis>;
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-d</parameter>символ</term>
		    <listitem>
		      устанавливает заданный символ в качестве разделителя полей при
		      использовании
		      параметра <parameter class="command" moreinfo="none">-f</parameter>. Если в качестве
		      разделителя используется небукверрый символ (например, пробел), он
		      должен быть заключён в кавычки. 
		    </listitem>
		  </varlistentry>
		</variablelist>
	      </para>
	      <para>
		Примеры работы программы:
		<itemizedlist>
		  <listitem>
		    <para>
		      Выделение первых семи столбцов файла:
		      <informalexample>
			<screen format="linespecific">user@desktop ~ $ cat phones.txt
1234567		Борис Петрович
5557845		Анна Иоановна
...
user@desktop ~ $ cut -c1-7 phones.txt
1234567
5557845
...</screen>
		      </informalexample>
		    </para>
		  </listitem>
		  <listitem>
		    <para>
		      Получение списка групп пользователей, зарегистрированных в системе:
		      <informalexample>
			<screen format="linespecific">user@desktop ~ $ cut -f1 -d: /etc/group
root
bin
daemon
sys
adm
...</screen>
		      </informalexample>
		    </para>
		  </listitem>
		</itemizedlist>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-paste" xreflabel="paste">paste</emphasis></term>
	    <listitem>
	      <para>
		Команда <command moreinfo="none">paste</command> объединяет два текстовых файла в один. В
		получившемся файле исходные строки располагаются в соседних столбцах,
		разделённые символом табуляции (или любым другим символом, указанным через
		параметр <parameter class="command" moreinfo="none">-d</parameter>). 
	      </para>
	      <para>
		Часто применяется совместно с программой <command moreinfo="none">cut</command>.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-sort" xreflabel="sort">sort</emphasis></term>
	    <listitem>
	      <para>
		Команда <command moreinfo="none">sort</command> сортирует строки, входящие во все исходные
		файлы, и выдает результат на стандартный вывод. Если имена файлов не
		указаны, или в качестве файла указан <quote>-</quote>, исходная информация
		поступает со стандартного ввода.  Команда имеет формат:
		<synopsis format="linespecific">sort  [-c] [-r] [файл ...]</synopsis>
	      </para>
	      <para>
		При упорядочении используется один или несколько ключей сортировки,
		выделяемых из каждой вводимой строки. По умолчанию ключ сортировки
		один – вся строка, а порядок является лексикографическим,
		соответствующим принятой кодировке символов.
	      </para>
	      <para>
		Вот отсновные опции команды:
		<variablelist>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-c</parameter></term>
		    <listitem>
		      Вместо сортировки файла проверяет, отсортирован ли он. Если файл не
		      отсортирован, команда возвращает <literal moreinfo="none">1</literal> и выводит
		      соответствующее сообщение.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-r</parameter></term>
		    <listitem>
		      Заменить результат сравнения на противоположный. 
		    </listitem>
		  </varlistentry>
		</variablelist>
	      </para>
	      <para>
		Рассмотрим примеры использования команды:
		<itemizedlist>
		  <listitem>
		    <para>
		      Отсортировать файл с фамилиями:
		      <informalexample>
			<screen format="linespecific">user@desktop test $ cat f.txt
Petrov
Ivanov
Sidorov
Abramov
user@desktop test $ sort f.txt
Abramov
Ivanov
Petrov
Sidorov</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		  <listitem>
		    <para>
		      Отсортировать список файлов в обратном порядке:
		      <informalexample>
			<screen format="linespecific">user@desktop test $ ls / | sort -r
var/
usr/
tmp/
sys/
sbin/
root/
...</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		</itemizedlist>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-uniq" xreflabel="uniq">uniq</emphasis></term>
	    <listitem>
	      <para>
		Команда <command moreinfo="none">uniq</command> построчно анализирует файл и в случее,
		если он содержит в себе повторяющиеся строки, выбрасывает
		дубликаты. Команда имеет следующий формат:
		<synopsis format="linespecific">uniq [-c] [исходный_файл]</synopsis>
	      </para>
	      <para>
		Если имя исходного файла не указано, команда читает данные со стандартного
		ввода.
	      </para>
	      <para>
		В качестве параметра может быть
		указано <parameter class="command" moreinfo="none">-c</parameter>, тогда рядом с каждой
		строкой будет выведено число повторений этой строки.
	      </para>
	      <para>
		Рассмотрим примеры использования команды:
		<itemizedlist>
		  <listitem>
		    <para>
		      Получим имена всех пользователей, работающих в системе в настоящий
		      момент: 
		      <informalexample>
			<screen format="linespecific">user@desktop test $ who | cut -f1 -d' '
root
root
murie
practica
user@desktop test $ who | cut -f1 -d' ' | uniq
root
murie
practica</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		  <listitem>
		    <para>
		      Однако такой результат будет не всегда:
		      <informalexample>
			<screen format="linespecific">user@desktop test $ who | cut -f1 -d' '
root
murie
root
practica
user@desktop test $ who | cut -f1 -d' ' | uniq
root
murie
root
practica</screen>
		      </informalexample>
		      Это происходит потому, что команда <command moreinfo="none">uniq</command>
		      сравнивает строки последовательно. Для того, чтобы избежать
		      дублирования, результат можно сперва сортировать:
		      <informalexample>
			<screen format="linespecific">user@desktop test $ who | cut -f1 -d' ' | sort | uniq
murie
practica
root</screen>
		      </informalexample>
		    </para>  
		  </listitem>
		</itemizedlist>
	      </para>     
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-iconv" xreflabel="iconv">iconv</emphasis></term>
	    <listitem>
	      <para>
		Команда <command moreinfo="none">iconv</command> не является оригинальной командой UNIX,
		она появилась в системах, разработанных в рамках
		проекта <acronym>GNU</acronym>. Однако большинство современных версий UNIX
		содержат эту команду.
	      </para>
	      <para>
		Команда предназначена для перекодирования текстовых файлов из одной
		кодировки в другую и имеет следующий формат:
		<synopsis format="linespecific">iconv [-l] -f исходная_кодировка -t конечная_кодировка [исходный_файл]</synopsis>
		
	      </para>
	      <para>
		Если имя исходного файла не указано, команда читает данные со стандартного
		ввода.
	      </para>
	      <para>
		Имя кодировки – исходной или конечной должно соответствовать
		кодировке в файле, список доступных кодировок можно получить, если
		запустить команду <command moreinfo="none">iconv</command> с
		параметром <parameter class="command" moreinfo="none">-l</parameter>. 
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-wc" xreflabel="wc">wc</emphasis></term>
	    <listitem>
	      <para>
		Эта команда предназначена для подсчёта количества строк, символов и слов в
		указанных файлах. Команда имеет слудующий формат:
		<synopsis format="linespecific">wc [-clmw] file ...</synopsis>
	      </para>
	      <para>
		Можно использовать следующие опции:
		<variablelist>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-c</parameter></term>
		    <listitem>
		      Вывод только количества байт.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-l</parameter></term>
		    <listitem>
		      Вывод только количества строк.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-m</parameter></term>
		    <listitem>
		      Вывод только количества символов. Отличается от числа байт при
		      многобайтной кодировке.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">-w</parameter></term>
		    <listitem>
		      Вывод только количества слов.
		    </listitem>
		  </varlistentry>
		</variablelist>
	      </para>
	      <para>
		Рассмотрим примеры использования команды:
		<itemizedlist>
		  <listitem>
		    <para>
		      Подсчёт числа слов в документе:
		      <informalexample>
			<screen format="linespecific">user@desktop test $ wc -w lectures.txt
568 lectures.txt</screen>
		      </informalexample>
		    </para>
		  </listitem>		      
		  <listitem>
		    <para>
		      Число файлов в директории:
		      <informalexample>
			<screen format="linespecific">user@desktop test $ ls / | wc -l
15</screen>
		      </informalexample>
		    </para>
		  </listitem>		      
		  <listitem>
		    <para>
		      Полная статистика по группе xml-файлов (число строк, число слов,
		      число байт):
		      <informalexample>
			<screen format="linespecific">user@desktop test $ cat *.xml | wc 
   3978   16138  253680</screen>
		      </informalexample>
		    </para>
		  </listitem>		      
		</itemizedlist>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-dd" xreflabel="dd">dd</emphasis></term>
	    <listitem>
	      <para>
		<command moreinfo="none">dd</command> – команда блочного копирования
		файлов. Она имеет следующий формат:
		<synopsis format="linespecific"> dd if=исходный_файл of=конечный_файл bs=размер_блока count=число_блоков skip=число_блолов seek=число_блоков</synopsis>
	      </para>
	      <para>
		Программа используется при копировании частей одного файла в другой, часто
		применяется при работе с устройствами. Рассмотрим параметры, принимаемые
		командой:
		<variablelist>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">if=</parameter></term>
		    <listitem>
		      Задаёт имя файла (или устройства), откуда будут копироваться данные.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">of=</parameter></term>
		    <listitem>
		      Задаёт имя файла (или устройства), куда будут копироваться данные.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">bs=</parameter></term>
		    <listitem>
		      Задаёт размер блока копирования в байтах. Можно применять модификаторы
		      размера: <quote>K</quote> –
		      килобайты, <quote>M</quote> – мегабайты и т.п.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">count=</parameter></term>
		    <listitem>
		      Задаёт число копируемых блоков. Если этот параметр не задан,
		      копируется всеь исходный файл.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">skip=</parameter></term>
		    <listitem>
		      Число блоков в исходном файле, которое будет пропущено до чтения.
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="command" moreinfo="none">seek=</parameter></term>
		    <listitem>
		      Число блоков в файле назначения, которое будет пропущено до записи.
		    </listitem>
		  </varlistentry>
		</variablelist>
	      </para>
	      <para>
		Рассмотрим примеры использования команды:
		<itemizedlist>
		  <listitem>
		    <para>
		      Копирование загрузочного сектора жёсткого диска в
		      файл <filename moreinfo="none">bootsect</filename>: 
		      <informalexample>
			<screen format="linespecific">user@desktop test $ dd if=/dev/hda of=bootsect bs=512 count=1
1+0 входных записей
1+0 выходных записей
512 bytes (512 B) copied, 9e-05 seconds, 5,7 MB/s</screen>
		      </informalexample>
		    </para>
		  </listitem>		      
		  <listitem>
		    <para>
		      Копирование файла размером до двух мегабайт на простой гибкий диск и
		      обратно:
		      <informalexample>
			<screen format="linespecific">user@desktop test $ dd if=arch.tar.bz2 of=/dev/fd0 bs=1
1788990+0 входных записей
1788990+0 выходных записей
user@desktop test $ dd if=/dev/fd0 of=arch2.tar.bz2 bs=1 count=1788990
1788990+0 входных записей
1788990+0 выходных записей</screen>
		      </informalexample>
		    </para>
		  </listitem>		      
		</itemizedlist>
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>		
      </para>
      <sect3 id="shell-maincmd-text-regexp">
	<title>Команды, использующие регулярные выражения</title>
	<para>
	  <variablelist>
	    <varlistentry>
	      <term><emphasis id="def-cmd-grep" xreflabel="grep">grep</emphasis></term>
	      <listitem>
		<para>
		  Часто пользователю нужно найти только упоминания чего-то конкретного в
		  файле или среди данных, выводимых программой. Обычно эта задача сводится
		  к поиску строк, в которых встречается определенное слово или комбинация
		  символов. Для этого подходит стандартная
		  утилита <command moreinfo="none">grep</command>. <command moreinfo="none">grep</command> может искать
		  строку в файлах, а может работать как фильтр: получив строки со
		  стандартного ввода, она выведет на стандартный вывод только те строки,
		  где встретилось искомое сочетание символов.
		</para>
		<para>
		  Простой пример: найти своего пользователя в
		  файле <filename moreinfo="none">/etc/passwd</filename>:
		  <informalexample>
		    <screen format="linespecific">user@desktop ~ $ grep user /etc/passwd
user:x:1000:100::/home/dralex:/bin/bash</screen>
		  </informalexample>
		  Первый аргумент команды <command moreinfo="none">grep</command> – та строка,
		  которую нужно искать в файле или стандартном вводе, в данном случае это
		  <quote>user</quote>, а поскольку файл <filename moreinfo="none">/etc/passwd</filename>
		  выводит сведения по строке на каждого пользователя, таким образом можно
		  получить информацию о пользвателе <quote>user</quote>.
		</para>
		<para>
		  В случае, если нужно искать не конкретное сочетание символов, а какую-то
		  их несложную комбинацию, используют <emphasis id="def-regexp" xreflabel="регулярное выражение">регулярные
		  выражения</emphasis> – способ специальной формулой задать
		  все допустимые последовательности символов (в дискретной математике это
		  понятие формулируется более строго).
		</para>
		<para>
		  В регулярном выражении большинство символов обозначают сами себя, как
		  если бы мы искали обыкновенную текстовую строку,
		  например, <quote>user</quote> и <quote>::</quote> в регулярном выражении
		  соответствуют строкам <quote>Note</quote> и <quote>::</quote> в
		  тексте. Однако некоторые символы обладают специальным значением, самый
		  главный из таких символов – звездочка (<quote>*</quote>),
		  поставленная после элемента регулярного выражения, обозначает, что могут
		  быть найдены тексты, где этот элемент повторен любое количество раз, в
		  том числе и ни одного, т.е. просто отсутствует.
		</para>
		<para>
		  С помощью следующей команды можно посмотреть все локальные сетевые
		  имена, зарегистрированные в системе:
		  <informalexample>
		    <screen format="linespecific">user@desktop ~ $ grep "^127.*" /etc/hosts
127.0.0.1       localhost</screen>
		  </informalexample>
		  Символ <quote>.</quote> означает <quote>любой символ</quote>, а вместе
		  с <quote>*</quote> означает 0 или более любых символов .
		  Символ <quote>^</quote> в начале регулярного выражения означает, что
		  необходимы строки, <emphasis>начинающиеся</emphasis> с данного шаблона
		  (для обозначения конца строки используют символ <quote>$</quote>).
		</para>	
		<para>
		  Существуют и другие способы группирования символов:
		  <itemizedlist>
		    <listitem>
		      <para>
			<quote>[</quote> и <quote>]</quote> задают <emphasis>класс
			символов</emphasis>, когда в выражении может встретиться любой из
			них. С помощью следующего регулярного выражения выводятся все
			строки, содержащие любые числа (знак <quote>+</quote> является
			аналогом <quote>*</quote>, только задаёю 1 и большее число
			упоминаний предыдущего символа):
			<informalexample>
			  <screen format="linespecific">user@desktop ~ $ grep "[0-9]\+" /etc/hosts
# Copyright 1999-2002 Gentoo Technologies, Inc.
# Distributed under the terms of the GNU General Public License, v2 or later
# $Header: /home/cvs/doc-admin/shell.xml,v 1.19 2006/02/07 21:46:15 dralex Exp $
127.0.0.1       localhost</screen>
			</informalexample>
		      </para>
		    </listitem>		      
		    <listitem>
		      <para>
			<quote>(</quote> и <quote>)</quote> позволяют группировать
			выражения. Например, следующая команда выводит все строки,
			содержащие IP-адрес:
			<informalexample>
			  <screen format="linespecific">user@desktop ~ $ grep "\([0-9]\+\.\)\{3\}[0-9]\+" /etc/hosts
127.0.0.1       localhost
</screen>
			</informalexample>
			Запись <quote>{3}</quote> означает, что предыдущий символ или
			выражение должно повторяться в точности 3 раза.
		      </para>
		    </listitem>
		  </itemizedlist>  
		</para>
		<para>
		  Регулярные выражения содержат множество <emphasis>управляющих</emphasis>
		  символов, каждый их которых наделён собственным смыслом. Для того, чтобы
		  воспользоваться непосредственным значением символа (для поиска его в
		  строке), необходимо поставить перед ним символ обратной
		  косой: <quote>\</quote>.
		</para>
		<para>
		  Команда <command moreinfo="none">grep</command> содержит множество удобных параметров,
		  например вывод номера найденной строки
		  (<parameter class="command" moreinfo="none">-n</parameter>) или вывод только подстроки,
		  соответствующей самому регулярному выражению
		  (<parameter class="command" moreinfo="none">-o</parameter>).
		</para>
		<para>
		  Благодаря регулярным выражениям можно автоматизировать очень многие
		  задачи, которые в противном случае потребовали бы огромной и кропотливой
		  работы человека. Более подробные сведения о возможностях языка
		  регулярных выражений можно получить из руководства
		  команды <command moreinfo="none">grep</command>. 
		</para>		
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis id="def-cmd-sed" xreflabel="sed">sed</emphasis></term>
	      <listitem>
		<para>
		  Регулярные выражения можно использовать не только для поиска по файлу,
		  но и для изменения информации. Для такого поиска с заменой можно
		  воспользоватья утилитой <command moreinfo="none">sed</command> (stream
		  editor – поточный редактор). <command moreinfo="none">sed</command> имеет
		  свой встроенный простой язык, с помощью которого можно задать правила
		  модифицирования файла. 
		</para>
		<para>
		  Все команды встроенного языка <command moreinfo="none">sed</command> состоят из одной
		  буквы. Например, ноиск с заменой выполняет команда <quote>s</quote>
		  (search). Синтаксис у нее следующий:
		  <synopsis format="linespecific">s/что_искать/на_что_заменять/</synopsis>
		  Например:
		  <informalexample>
		    <screen format="linespecific">user@desktop ~ $ ls -l / | sed 's/^d[^ ]\+/directory/'
итого 20
directory   2 root root  3640 Окт 17 09:12 bin/
directory   3 root root   472 Окт 17 12:27 boot/
directory  16 root root 13360 Окт 24 13:18 dev/
directory  61 root root  4040 Окт 24 13:18 etc/
...</screen>
		  </informalexample>
		  Эта команда заменяет в информации о корневой директории все строки,
		  начинающиеся с символа <literal moreinfo="none">d</literal> и все, следующие за ним
		  непробельные символы, на слово <literal moreinfo="none">directory</literal>.
		</para>
		<para>
		  Кроме команды поиска, <command moreinfo="none">sed</command> имеет команды удаления,
		  копирования и замены строк. Также команды могут иметь модификаторы,
		  например, символ <quote>g</quote> в конце команды поиска указывает
		  делять замену для всех найденных по регулярному шаблону подстрок, а не
		  только для первого.
		</para>
		<para>
		  Попробуем разобраться подробнее, как работает
		  редактор <command moreinfo="none">sed</command>. Входной текст <command moreinfo="none">sed</command>
		  считывает построчно. К считанной строке он по очереди пробует применить
		  каждую команду сценария. Применив все возможные команды к
		  строке, <command moreinfo="none">sed</command> выводит на стандартный вывод то, что от
		  нее осталось. Команда сценария может начинаться с т.н. контекстного
		  адреса, определяющего свойства строк, к которым эту команду можно
		  применять. Простой контекстный адрес – это номер строки
		  (команда применяется к единственной – совпадающей по
		  номеру – строке входного потока) или регулярное выражение
		  (команда применяется ко всем строкам, в которых найдено соответствие
		  этому РВ). Например, команда <command moreinfo="none">sed "1s/_/ /g"</command> заменит в
		  первой строке все подчеркивания на пробелы, а <command moreinfo="none">sed
		  "/^a/d"</command> удалит (delete) все строки, начинающиеся
		  с <quote>a</quote>.
		</para>
		<para>
		  У <command moreinfo="none">sed</command> очень широкие возможности, но довольно
		  непривычный синтаксис.  Чтобы в нем разобраться, нужно обязательно
		  прочесть руководство <command moreinfo="none">sed</command> и знать регулярные
		  выражения.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>    
      </sect3>
    </sect2>
    <sect2 id="shell-maincmd-summary">
      <title>Резюме</title>
      <para>
	В данном разделе рассматриваются основные команды по работе с файловой системой и
	текстами, а также примеры их комплексного использования.
      </para>
      <para><emphasis>Ключевые термины: </emphasis><xref linkend="def-cmd-pwd"/>, <xref linkend="def-cmd-cd"/>, <xref linkend="def-cmd-ls"/>, <xref linkend="def-cmd-mkdir"/>, <xref linkend="def-cmd-rmdir"/>, <xref linkend="def-cmd-touch"/>, <xref linkend="def-cmd-rm"/>, <xref linkend="def-cmd-cp"/>, <xref linkend="def-cmd-mv"/>, <xref linkend="def-cmd-ln"/>, <xref linkend="def-cmd-du"/>, <xref linkend="def-cmd-tar"/>, <xref linkend="def-cmd-find"/>, <xref linkend="def-cmd-mkfifo"/>, <xref linkend="def-cmd-echo"/>, <xref linkend="def-cmd-cat"/>, <xref linkend="def-cmd-less"/>, <xref linkend="def-cmd-head"/>, <xref linkend="def-cmd-tail"/>, <xref linkend="def-cmd-cut"/>, <xref linkend="def-cmd-paste"/>, <xref linkend="def-cmd-sort"/>, <xref linkend="def-cmd-uniq"/>, <xref linkend="def-cmd-iconv"/>, <xref linkend="def-cmd-wc"/>, <xref linkend="def-cmd-dd"/>, <xref linkend="def-cmd-grep"/>, <xref linkend="def-regexp"/>, <xref linkend="def-cmd-sed"/></para>
    </sect2>    
    <sect2 id="shell-maincmd-additional">
      <title>Дополнительные материалы</title>
      <para>
	<orderedlist inheritnum="ignore" continuation="restarts">
	  <listitem>
	    Курячий Г.В., Маслинский К.А. <emphasis>Операционная система
	      Linux</emphasis>. – М.: Интуит.Ру, 2005. – 392 с.: ил.
	  </listitem>
	  <listitem>
	    Курячий Г.В. <emphasis>Операционная система UNIX</emphasis>. –
	    М.: Интуит.Ру, 2004. – 292 с.: ил.
	  </listitem>
	  <listitem>
	    Рейчардс К., Фостер-Джонсон Э. <emphasis>UNIX:
	      справочник</emphasis>. – СПб.: Питер Ком, 1999. – 384 с.:
	    ил.
	  </listitem>
	</orderedlist>
      </para>
    </sect2>
  </sect1>
  <!-- занятие №4 (практическое занятие) -->
  <sect1 id="shell-maincmdexamples"><title>Практическое занятие. Работа с файлами в UNIX</title><para>
      <emphasis>Цель занятия:</emphasis> знакомство с командной строкой UNIX, командами по
      работе с файловой системой и командами обработки текстовых файлов.
    </para><para>
      <emphasis>Изучаемые команды:</emphasis> 
      <xref linkend="def-cmd-cat"/>,
      <xref linkend="def-cmd-cd"/>,
      <xref linkend="def-cmd-cp"/>,
      <xref linkend="def-cmd-cut"/>,
      <xref linkend="def-cmd-echo"/>,
      <xref linkend="def-cmd-find"/>,
      <xref linkend="def-cmd-grep"/>,
      <xref linkend="def-cmd-head"/>,
      <xref linkend="def-cmd-ln"/>,
      <xref linkend="def-cmd-ls"/>,
      <xref linkend="def-cmd-mkdir"/>,
      <xref linkend="def-cmd-mv"/>,
      <xref linkend="def-cmd-paste"/>,
      <xref linkend="def-cmd-pwd"/>,
      <xref linkend="def-cmd-sort"/>,
      <xref linkend="def-cmd-tail"/>,
      <xref linkend="def-cmd-tar"/>,
      <xref linkend="def-cmd-touch"/>,
      <xref linkend="def-cmd-uniq"/>,
      <xref linkend="def-cmd-wc"/>
    </para><sect2 id="shell-scenario-dirs"><title>Сценарий: Знакомство с каталогами UNIX</title><para>
	
	  В этом сценарии будет освещено знакомство с командами UNIX, изучение файловой
	  системы и базовых каталогов, создание рабочей среды в домашнем каталоге
	  пользователя для выполнения всех последующих команд.
	
      </para><para><emphasis>Начальные условия:</emphasis>
	Командная строка после входа в систему.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	  <para>
	    Получить имя текущего каталога с помощью команды <command moreinfo="none">pwd</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ pwd
/home/user/</screen>
	    </informalexample>		
	</para>
	</listitem>	
	<listitem>
	  <para>
	    Перейти в корневой каталог с помощью команды <command moreinfo="none">cd /</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ cd /
user@desktop / $ pwd
/</screen>
	    </informalexample>
	    Отметить, как изменилось строка приглашения.
	</para>
	</listitem>	
	<listitem>
	  <para>
	    Посмотреть содержимое корневого каталога с помощью
	    команды <command moreinfo="none">ls</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop / $ ls
bin   dev  home  mnt  proc  sbin  tmp  var
boot  etc  lib   opt  root  sys   usr</screen>
	    </informalexample>
	</para>
	</listitem>	
	<listitem>
	  <para>
	    Сравнить с использованием <quote>раскарашенного</quote> вывода
	    команды <command moreinfo="none">ls -F --color</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop / $ ls -F --color
bin/   dev/  home/  mnt/  proc/  sbin/  tmp/  var/
boot/  etc/  lib/   opt/  root/  sys/   usr/</screen>
	    </informalexample>
	    Диретории отмечаются синим цветом и знаком <quote>/</quote> после имени.
	</para>
	</listitem>	
	<listitem>
	  <para>
	    Посмотреть содержимое домашнего каталога с помощью команды <command moreinfo="none">ls
	    -F --color ~</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop / $ ls -F --color ~
user@desktop / $</screen>
	    </informalexample>
	    Возможно, домашний каталог пуст.
	</para>
	</listitem>
	<listitem>
	  <para> Вернуться в домашний каталог с
	    помощью <command moreinfo="none">cd</command> без параметров:
	    <informalexample>
	      <screen format="linespecific">user@desktop / $ cd
user@desktop ~ $</screen>
	    </informalexample>		
	</para>
	</listitem>	
	<listitem>
	  <para>
	    Создать директорию <filename moreinfo="none">test</filename> с помощью
	    команды <command moreinfo="none">mkdir test</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ mkdir test</screen>
	    </informalexample>		
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Посмотреть обновлённое содержимое домашнего каталога <command moreinfo="none">ls -F
	    --color</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ ls -F --color
test/</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Создать поддиректорию <filename moreinfo="none">subtest</filename> в
	    директории <filename moreinfo="none">test</filename> командой <command moreinfo="none">mkdir test/subtest</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ mkdir test/subtest</screen>
	    </informalexample>		
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Посмотреть содержимое домашнего каталога и его подкаталогов с помощью ключа
	    рекурсивного просмотра <parameter class="command" moreinfo="none">-R</parameter> в команде
	    <command moreinfo="none">ls -F --color -R</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ ls -F --color -R
.:
test/
test:
subtest/

test/subtest:</screen>
	    </informalexample>
	  </para>
	</listitem>
      </orderedlist></sect2><sect2 id="shell-scenario-filetypes"><title>Сценарий: Изучение типов файлов в UNIX</title><para>
	
	  В этом сценарии рассматриваются типы файлов в UNIX: простые файлы, директории,
	  ссылки. Изучаются команды создания и копирования файлов. Показывается разница
	  между жесткими и символическими ссылками, между копированием и переносом
	  файла.
	
      </para><para><emphasis>Начальные условия:</emphasis>
	Командная строка. Директория test после предыдущего сценария.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	  <para>
	    Cоздать пустой файл с помощью команды <command moreinfo="none">touch test/first.txt</command>: 
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ touch test/first.txt
user@desktop ~ $ ls -F --color test/		
first.txt  subtest/</screen>
	    </informalexample>
	  </para>	    
	</listitem>
	<listitem>
	  <para>
	    Добавить строку текста в конец файла с помощью
	    команды <command moreinfo="none">echo "Hello, world" &gt;&gt; test/first.txt</command> и перенаправления вывода:
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ echo "Hello, world" &gt;&gt; test/first.txt</screen>
	    </informalexample>
	  </para>	    
	</listitem>
	<listitem>
	  <para>
	   Посмотреть содержимое файла с помощью команды <command moreinfo="none">cat test/first.txt</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ cat test/first.txt
Hello, world
user@desktop ~ $</screen>
	    </informalexample>
	  </para>	    
	</listitem>
	<listitem>
	  <para>
	    Посмотреть расширенную информацию о каталоге, используя
	    ключ <parameter class="command" moreinfo="none">-l</parameter>
	    команды <command moreinfo="none">ls</command>. <command moreinfo="none">ls -F --color -l test</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ ls -F --color -l test
итого 4
-rw-r--r--  1 user users 13 Окт 15 20:48 first.txt
drwxr-xr-x  2 user users 48 Окт 13 21:33 subtest/</screen>
	    </informalexample>
	  </para>	    
	</listitem>
	<listitem>
	  <para>
	    Добавить псевдоним командной оболочки, чтобы сократить размер команды, с помощью команды
	    <command moreinfo="none">alias ls='ls -F --color -l'</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ alias ls='ls -F --color -l'
user@desktop ~ $ ls test
итого 4
-rw-r--r--  1 user users 13 Окт 15 20:48 first.txt
drwxr-xr-x  2 user users 48 Окт 13 21:33 subtest/</screen>
</informalexample>
	  </para>	    
	</listitem>
	<listitem>
	  <para>
	    Посмотреть глубже на директорию <filename moreinfo="none">test</filename>, используя ключи
	    <parameter class="command" moreinfo="none">-a</parameter> и <parameter class="command" moreinfo="none">-i</parameter>.
	    <command moreinfo="none">ls -a -i test</command>
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ ls -a -i test
итого 7
drwxr-xr-x   3 user users  104 Окт 15 20:49 ./
drwx------  67 user users 3352 Окт 15 20:42 ../
-rw-r--r--   1 user users   13 Окт 15 20:48 first.txt
drwxr-xr-x   2 user users   48 Окт 13 21:33 subtest/</screen>
	    </informalexample>
	    Первый столбец – номера индексных узлов файловой системы.
	    Третий столбец – число жёстких ссылок файла.
	  </para>
	</listitem>
	<listitem>
	  <para>
	   Перейти в каталог <filename moreinfo="none">test</filename> с помощью команды <command moreinfo="none">cd test</command>
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ cd test</screen>
	    </informalexample>			  
	  </para>	    
	</listitem>
	<listitem>
	  <para>
	   Скопировать файл с помощью команды <command moreinfo="none">cp first.txt copy1.txt</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop test $ cp first.txt copy1.txt
user@desktop test $ ls -a -i 
итого 11
5522107 drwxr-xr-x   3 user users  136 Окт 15 20:54 ./
384269 drwx------  67 user users 3352 Окт 15 20:42 ../
5938127 -rw-r--r--   1 user users   13 Окт 15 20:54 copy1.txt
5937954 -rw-r--r--   1 user users   13 Окт 15 20:48 first.txt
6292625 drwxr-xr-x   2 user users   48 Окт 13 21:33 subtest/</screen>
	    </informalexample>
	    Новый файл имеет свой собственный индексный узел.
	  </para>
	</listitem>
	<listitem>
	  <para>
	   Переименовать файл с помощью команды <command moreinfo="none">mv first.txt orig.txt</command>.
	    <command moreinfo="none">mv first.txt orig.txt</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop test $ mv first.txt orig.txt
user@desktop test $ ls -a -i
итого 11
5522107 drwxr-xr-x   3 user users  128 Окт 15 20:59 ./
384269 drwx------  67 user users 3352 Окт 15 20:42 ../
5938127 -rw-r--r--   1 user users   13 Окт 15 20:54 copy1.txt
5937954 -rw-r--r--   1 user users   13 Окт 15 20:48 orig.txt
6292625 drwxr-xr-x   2 user users   48 Окт 13 21:33 subtest/</screen>
	    </informalexample>
	    Отметим, что изменилось только имя файла, все остальные атрибуты
	    остались прежними.
	  </para>
	</listitem>
	<listitem>
	  <para>
	   Создать жёсткую ссылку командой <command moreinfo="none">ln orig.txt copy2.txt</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop test $ ln orig.txt copy2.txt
user@desktop test $ ls -a -i
итого 15
5522107 drwxr-xr-x   3 user users  160 Окт 15 21:00 ./
384269 drwx------  67 user users 3352 Окт 15 20:42 ../
5938127 -rw-r--r--   1 user users   13 Окт 15 20:54 copy1.txt
5937954 -rw-r--r--   2 user users   13 Окт 15 20:48 copy2.txt
5937954 -rw-r--r--   2 user users   13 Окт 15 20:48 orig.txt
6292625 drwxr-xr-x   2 user users   48 Окт 13 21:33 subtest/</screen>
	    </informalexample>
	    Добавилась ещё одна ссылка на тот же файл, число ссылок увеличилось
	    на 1.
	  </para>
	</listitem>
	<listitem>
	  <para>
	   Создать символическую ссылку командой <command moreinfo="none">ln -s orig.txt orig.lnk</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop test $ ln -s orig.txt orig.lnk
user@desktop test $ ls -a -i
итого 15
5522107 drwxr-xr-x   3 user users  184 Окт 15 21:18 ./
384269 drwx------  67 user users 3352 Окт 15 21:02 ../
5938127 -rw-r--r--   1 user users   13 Окт 15 20:54 copy1.txt
5937954 -rw-r--r--   2 user users   13 Окт 15 20:48 copy2.txt
5938189 lrwxrwxrwx   1 user users    8 Окт 15 21:18 orig.lnk -&gt; orig.txt
5937954 -rw-r--r--   2 user users   13 Окт 15 20:48 orig.txt
6292625 drwxr-xr-x   2 user users   48 Окт 13 21:33 subtest/</screen>
	    </informalexample>
	    Новый файл имеет новый индексный узел и размер, равный имени
	    файла <filename moreinfo="none">orig.txt</filename>.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Сравним содержимое файлов при обращении к ним по имени:
	    <informalexample>
	      <screen format="linespecific">user@desktop test $ cat orig.txt
Hello, world
user@desktop test $ cat copy2.txt
Hello, world
user@desktop test $ cat orig.lnk
Hello, world</screen>
	    </informalexample>
	  </para>
	  К одним и тем же данным можно обратиться через жесткую или символическую
	  ссылку.
	</listitem>
      </orderedlist></sect2><sect2 id="shell-scenario-find"><title>Сценарий: Поиск системных журналов</title><para>
	
	  В этом сценарии изучается команда поиска файлов и директорий.
  	
      </para><para><emphasis>Начальные условия:</emphasis>
	Командная строка, директория test после прошлого сценария.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	 <para>
	  Перейти в каталог <filename moreinfo="none">test</filename> с помощью команды <command moreinfo="none">cd test</command>:
	  <informalexample>
	    <screen format="linespecific">user@desktop ~ $ cd test</screen>
	  </informalexample>			  
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Вывести список всех файлов и директорий в текущей директории, включая содержимое
	  поддиректорий с помощью команды <command moreinfo="none">find</command>:
	  <informalexample>
	    <screen format="linespecific">user@desktop ~ $ find
.
./orig.lnk
./orig.txt
./subtest
./copy1.txt
./copy2.txt</screen>
	  </informalexample>
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Найти все файлы и дериктории в текущей директории и ее поддиректориях,
	  которые начиняются на <quote>o</quote> с помощью команды <command moreinfo="none">find -name "o*"</command>:
	  <informalexample>
	    <screen format="linespecific">user@desktop ~ $ find -name "o*"
./orig.lnk
./orig.txt</screen>
	  </informalexample>
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Найти все файлы и дериктории в директории <filename moreinfo="none">/etc</filename> и ее поддиректориях,
	  которые начиняются на <quote>o</quote> с помощью команды <command moreinfo="none">find /etc -name "o*"</command>:
	  <informalexample>
	    <screen format="linespecific">user@desktop ~ $ find /etc -name "o*"
/etc/apm/other.d
/etc/joe/syntax/ocaml.jsf
/etc/opt
/etc/ppp/options-pptp
/etc/ppp/options-pppoe
/etc/ppp/options
/etc/ssl/openssl.cnf
/etc/dpkg/origins
/etc/pam.d/other
/etc/texmf/tex/plain/config/omega.ini</screen>
	  </informalexample>
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Найти все обычные файлы в директории <filename moreinfo="none">/etc</filename> и ее поддиректориях, которые начинаются на <quote>o</quote>
	  с помощью команды <command moreinfo="none">find /etc -name "o*" -a -type f</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop ~ $ find /etc -name "o*" -a -type f
/etc/joe/syntax/ocaml.jsf
/etc/ppp/options-pptp
/etc/ppp/options-pppoe
/etc/ppp/options
/etc/ssl/openssl.cnf
/etc/pam.d/other
/etc/texmf/tex/plain/config/omega.ini</screen>
	  </informalexample>
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Найти все обычные файлы в директории <filename moreinfo="none">/var/</filename> и ее поддиректориях, заканчивающиеся
	  на <quote>log</quote>:
	   <informalexample> 
	     <screen format="linespecific">user@desktop ~ $ find /var -name "*log" -a -type f
find: /var/lib/mysql: Permission denied
find: /var/lib/samba/private: Permission denied
...
/var/log/emerge.log
/var/log/lastlog
/var/log/faillog
/var/log/Xorg.0.log</screen>
	   </informalexample>
	  Список найденных файлов может быть слишком большим и для его просмотра
	  можно воспользоваться <quote>прокруткой</quote> терминала с помощью
	  клавиш <keycombo moreinfo="none"><keycap moreinfo="none">Shift</keycap><keycap moreinfo="none">PgUp</keycap></keycombo>
	  и <keycombo moreinfo="none"><keycap moreinfo="none">Shift</keycap><keycap moreinfo="none">PgDn</keycap></keycombo>
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Исключить вывод сообщений об ошибках (например, <quote>Permission denied</quote>)
	  с помощью перенаправления вывода ошибок в специальное устройство <filename moreinfo="none">/dev/null</filename>.
	  Для этого ввести команду <command moreinfo="none">find /var -name "*log" -a -type f  2&gt;/dev/null</command>
	   <informalexample> 
	     <screen format="linespecific">user@desktop ~ $ find /var -name "*log" -a -type f  2&gt;/dev/null
/var/log/emerge.log
/var/log/lastlog
/var/log/faillog
/var/log/Xorg.0.log</screen>
	   </informalexample>
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Создать директорию <filename moreinfo="none">logs</filename> с помощью команды 
	  <command moreinfo="none">mkdir test/logs</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop ~ $ mkdir test/logs</screen>
	  </informalexample>
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Скопировать найденные файлы в локальную директорию с помощью параметра 
	  <parameter class="command" moreinfo="none">-exec</parameter>
	  команды <application moreinfo="none">find</application>. Для этого ввести команду
	  <command moreinfo="none">find /var -name "*log" -a -type f -exec cp {} test/logs/ 2&gt;/dev/null</command>:
	   <informalexample>
	     <screen format="linespecific">user@desktop ~ $ find /var -name "*log" -a -type f -exec cp {} test/logs/ 2&gt;/dev/null
user@desktop ~ $ ls test/logs
итого 789
-rw-r-----  1 user users 601033 Окт 16 18:37 emerge.log
-rw-r--r--  1 user users 292292 Окт 16 18:37 lastlog
-rw-r--r--  1 user users  37383 Окт 16 18:37 Xorg.0.log</screen>
	   </informalexample>
	  Были скопированы все файлы, права на чтение которых у нас есть.
	 </para>
	</listitem>
      </orderedlist></sect2><sect2 id="shell-scenario-arch"><title>Сценарий: Архивирование и деархивирование файлов и директорий</title><para>
	
	  В этом сценарии изучается команда архивирования файлов и директорий.
  	
	
	  Командная строка, директория test после прошлого сценария.
	
      </para><para><emphasis>Начальные условия:</emphasis></para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	 <para>
	  Перейти в домашнюю директорию с помощью команды <command moreinfo="none">cd</command>:
	  <informalexample> 
	      <screen format="linespecific">user@desktop test $ cd
user@desktop ~ $</screen>			
	  </informalexample>
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Создать архив с именем <filename moreinfo="none">test.tar.gz</filename> с применением
	  сжатия, содержащий директорию <filename moreinfo="none">test</filename> с помощью команды 
	  <command moreinfo="none">tar -czf test.tar.gz test</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop ~ $ tar -czf test.tar.gz test
user@desktop ~ $ ls
drwxr-xr-x   4 user users   208 Окт 16 18:36 test/
-rw-r--r--   1 user users 79173 Окт 16 18:49 test.tar.gz</screen>
	  </informalexample>
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Создать новую директорию для содержимого архива командой <command moreinfo="none">mkdir test2</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop ~ $ mkdir test2</screen>			
	  </informalexample>
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Перейти в новую директорию с помощью команды <command moreinfo="none">cd test2</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop ~ $ cd test2</screen>			
	  </informalexample>
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Развернуть содержимое архива в текущую директорию с помощью команды
	  <command moreinfo="none">tar -xzf ../test.tar.gz</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop test2 $ tar -xzf ../test.tar.gz</screen>
	  </informalexample>
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Убедиться, что содержимое распакованного архива совпадает с
	  оригинальной директорией. Ввести команду <command moreinfo="none">ls -l -F</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop test2 $ ls -l -F
итого 0
drwxr-xr-x  4 user users 208 Окт 16 18:36 test/
user@desktop test2 $ ls -l -F test
итого 12
-rw-r--r--  1 user users  13 Окт 15 20:54 copy1.txt
-rw-r--r--  2 user users  13 Окт 15 20:48 copy2.txt
drwxr-xr-x  2 user users 136 Окт 16 18:37 logs/
lrwxrwxrwx  1 user users   8 Окт 16 18:54 orig.lnk -&gt; orig.txt
-rw-r--r--  2 user users  13 Окт 15 20:48 orig.txt
drwxr-xr-x  2 user users  48 Окт 13 21:33 subtest/</screen>
	  </informalexample>
	 </para>
	</listitem>
      </orderedlist></sect2><sect2 id="shell-scenario-text"><title>Сценарий: Cоздание новых текстовых файлов</title><para>
	
	  В этом сценарии изучаются команды для создания и модифицирования текстовых файлов.
  	
	
	  Командная строка.
	
      </para><para><emphasis>Начальные условия:</emphasis></para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	 <para>
	  Ввести команду <command moreinfo="none">echo "One line"</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop test $ echo "One line"
One line</screen>
	  </informalexample>
	   Данная команда принимает строку в виде аргумента и выводит её на стандартный
	   вывод.
  	 </para>
	</listitem>
	<listitem>
	 <para>
	  Ввести ту же команду, но перенаправить вывод в
	  файл <filename moreinfo="none">second.txt</filename> с помощью <quote>&gt;</quote>. Ввести
	  команду <command moreinfo="none">echo "One line" &gt; second.txt</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop test $ echo "One line" &gt; second.txt</screen>
	  </informalexample>
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Добавить в конец файла <filename moreinfo="none">second.txt</filename> строку <quote>A
	  line</quote> с помощью другого перенаправления <command moreinfo="none">echo "A line" &gt;&gt;
	  second.txt</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop test $ echo "A line" &gt;&gt; second.txt</screen>
	  </informalexample>
	</para>
	</listitem>
	<listitem>
	 <para>
	  Вывести содержимое файла с помощью команды <command moreinfo="none">cat second.txt</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop test $ cat second.txt
One line
A line</screen>
	  </informalexample>
	 </para>
	</listitem>
	<listitem>
	 <para>
	  С помощью команды <application moreinfo="none">cat</application> можно создавать многострочные
	  файлы –, если переопределить вывод программы в файл и вводить текст
	  до нажатия <keycombo moreinfo="none"><keycap moreinfo="none">Ctrl</keycap> <keycap moreinfo="none">D</keycap></keycombo> (конец
	  ввода).  Ввести команду <command moreinfo="none">cat &gt;multiline.txt</command> и набрать текст
	  <informalexample> 
	    <screen format="linespecific">user@desktop test $ cat &gt;multiline.txt
Simple text:
blah-blah-blah
1 2 3 4 5 6 7 8 9 0

bye!

(Ctrl+D)
user@desktop test $</screen>
	  </informalexample>
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Убедиться, что содержимое файла совпадает с введённым текстом, включая все переводы строки.
	  Для этого ввести команду <command moreinfo="none">cat multiline.txt</command>
	  <informalexample> 
	    <screen format="linespecific">user@desktop test $ cat multiline.txt
Simple text:
blah-blah-blah
1 2 3 4 5 6 7 8 9 0

bye!

</screen>
	  </informalexample>
	 </para>
	</listitem>
	<listitem>
	  <para>
	   Основным назначением команды <application moreinfo="none">cat</application> является
	   объединение файлов, имена которых передаются как аргументы командной строки.
	   Объединить файлы с помощью команды <command moreinfo="none">cat orig.txt second.txt
	   multiline.txt &gt; big.txt</command>:
		  <informalexample> 
		    <screen format="linespecific">user@desktop test $ cat orig.txt second.txt multiline.txt &gt; big.txt</screen>
		  </informalexample>
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Убедиться,  что новый  файл содержит  строки из  перечисленных файлов  с помощью
	  команды <command moreinfo="none">cat big.txt</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop test $ cat big.txt
Hello, world
One line
A line
Simple text:
blah-blah-blah
1 2 3 4 5 6 7 8 9 0

bye!

</screen>
	  </informalexample>
	 </para>
	</listitem>
      </orderedlist></sect2><sect2 id="shell-scenario-cutpaste"><title>Сценарий: Разрезание и склеивание файлов</title><para>
	
	  В данном сценарии изучается, как выделять информацию, разбитую на части с
	  помощью специального символа-разделителя (например, прообела или
	  символа :), из файлов и создавать новые структурированные файлы.
	
      </para><para><emphasis>Начальные условия:</emphasis>
	Командная строка.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	 <para>
	  Посмотреть содержимое файла <filename moreinfo="none">/etc/passwd</filename>, в котором содержится информация о
	  пользователях системы, с помощью команды <command moreinfo="none">cat /etc/passwd</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop test $ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/bin/false
daemon:x:2:2:daemon:/sbin:/bin/false
adm:x:3:4:adm:/var/adm:/bin/false
lp:x:4:7:lp:/var/spool/lpd:/bin/false
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
...</screen>
	  </informalexample> 
	  Каждая строка хранит запись об отдельном пользователе. Запись состоит
	  из полей, разделённых символом <quote>:</quote>.
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Выделить первый столбец в каждой записи, установив разделитель в <quote>:</quote>, с потощью команды
	  <command moreinfo="none">cat /etc/passwd | cut -f1 -d:</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop test $ cat /etc/passwd | cut -f1 -d:
root
bin
daemon
adm
lp
sync
shutdown
...</screen>
	  </informalexample> 
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Отсортировать список пользователей по алфавиту с помощью
	  команды <command moreinfo="none">cat /etc/passwd | cut -f1 -d: | sort</command>: 
	  <informalexample> 
	    <screen format="linespecific">user@desktop test $ cat /etc/passwd | cut -f1 -d: | sort
adm
alias
apache
at
bin
cron
cyrus
...</screen>
	  </informalexample> 
	 </para>
	</listitem>
	<listitem>
	  <para>
	   Выделить седьмой столбец в каждой записи, соответствующий командной оболочке
	   пользователя, с помощью команды <command moreinfo="none">cat /etc/passwd | cut -f7 -d:</command>
	  <informalexample> 
	    <screen format="linespecific">user@desktop test $ cat /etc/passwd | cut -f7 -d:
/bin/bash
/bin/false
/bin/false
/bin/false
/bin/false
/bin/sync
...</screen>
	  </informalexample> 
	  Список содержит много повторяющихся строк.
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Удалить повторяющиеся строки командой <command moreinfo="none">cat /etc/passwd | cut -f7 -d: | uniq</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop test $ cat /etc/passwd | cut -f7 -d: | uniq
/bin/bash
/bin/false
/bin/sync
/sbin/shutdown
/sbin/halt
/bin/false
...</screen>
	  </informalexample> 
	  Некоторые повторяющиеся строки остались, так как сравниваются только
	  последовательные строки.
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Добиться полной уникальности, предварительно отсортировав строки с помощью команды
	  <application moreinfo="none">sort</application>. Ввести команду <command moreinfo="none">cat /etc/passwd | cut
	  -f7 -d: | sort | uniq</command>:
	  <informalexample>
	    <screen format="linespecific">user@desktop test $ cat /etc/passwd | cut -f7 -d: | sort | uniq
/bin/bash
/bin/false
/bin/sync
/dev/null
/sbin/halt
/sbin/shutdown</screen>
	  </informalexample> 
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Выделить первый и седьмой столбец файла <filename moreinfo="none">/etc/passwd</filename> в отдельные файлы. Для этого
	  ввести команды <command moreinfo="none">cat /etc/passwd | cut -f1 -d: &gt; users</command> и 
	  <command moreinfo="none">cat /etc/passwd | cut -f7 -d: &gt; shells</command>:
	  <informalexample> 
		    <screen format="linespecific">user@desktop test $ cat /etc/passwd | cut -f1 -d: &gt; users
user@desktop test $ cat /etc/passwd | cut -f7 -d: &gt; shells</screen>
	  </informalexample> 
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Объединить результаты с помощью команды <command moreinfo="none">paste users shells</command>:
	  <informalexample> 
		    <screen format="linespecific">user@desktop test $ paste users shells
root    /bin/bash
bin     /bin/false
daemon  /bin/false
adm     /bin/false
lp      /bin/false
sync    /bin/sync
...</screen>
	  </informalexample> 
	 </para>
	</listitem>
      </orderedlist></sect2><sect2 id="shell-scenario-analysis"><title>Сценарий: Быстрый анализ текстов</title><para>
	
	  В данном сценарии изучаются команды, которые позволяют провести первичный анализ
	  файла: с чего он начинается, как заканчивается и каков его размер.
	
      </para><para><emphasis>Начальные условия:</emphasis>
	Командная строка.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	  <para>
	   Получить число строк в файле <filename moreinfo="none">/etc/passwd</filename> 
	   с пломощью команды <command moreinfo="none">wc -l /etc/passwd</command> :
	  <informalexample> 
		    <screen format="linespecific">user@desktop test $ wc -l /etc/passwd
44 /etc/passwd</screen>
	  </informalexample> 
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Или другим способом: посчитав число слов в созданном ранее
	  файле <filename moreinfo="none">users</filename> с помощью команды <command moreinfo="none">cat users | wc -w</command>: 
	  <informalexample> 
		    <screen format="linespecific">user@desktop test $ cat users | wc -w
44</screen>
	  </informalexample> 
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Посмотеть первые несколько строк длинного файла с помощью команды 
	  <command moreinfo="none">head logs/Xorg.0.log</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop test $ head logs/Xorg.0.log
X Window System Version 6.8.2
Release Date: 9 February 2005
X Protocol Version 11, Revision 0, Release 6.8.2
Build Operating System: Linux 2.6.13-gentoo i686 [ELF]
Current Operating System: Linux thinkpad 2.6.13-gentoo #1 Wed Sep 7 01:03:14 MSD 2005 i686
Build Date: 08 October 2005
Before reporting problems, check http://wiki.X.Org
to make sure that you have the latest version.
Module Loader present</screen>
	  </informalexample> 		    
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Аналогично, посмотеть последние несколько строк с помощью команды 
	  <command moreinfo="none">tail logs/Xorg.0.log</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop test $ tail logs/Xorg.0.log
(II) RADEON(0): [RESUME] Attempting to re-init Radeon hardware.
(II) RADEON(0): [agp] Mode 0x1f000201 [AGP 0x8086/0x3340; Card 0x1002/0x4c66]
(II) Mouse1: ps2EnableDataReporting: succeeded
SetClientVersion: 0 8
SetGrabKeysState - disabled
SetGrabKeysState - enabled
(II) 3rd Button detected: disabling emulate3Button
SetClientVersion: 0 8
SetGrabKeysState - disabled
SetGrabKeysState - enabled</screen>
	  </informalexample> 		    
	  Это бывает полезно при просмотре системных журналов – в
	  них самые последние события содержатся в конце файлов.
	 </para>
	</listitem>
      </orderedlist></sect2><sect2 id="shell-scenario-regexp"><title>Сценарий: Поиск строк по регулярным выражениям</title><para>
	
	  В данном сценарии рассматривается практическое использование регулярных выражений
	  для поиска по текстовым файлам.
	
      </para><para><emphasis>Начальные условия:</emphasis>
	Командная строка. Директория test/log с найденными системными
	журналами.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	 <para>
	  Среди найденных системных журналов посмотреть файл журнала загрузки
	  графичской системы <filename moreinfo="none">XFree86.0.log</filename> с помощью команды
	  <command moreinfo="none">less test/log/XFree86.0.log</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop ~ $ less test/log/XFree86.0.log</screen>
	  </informalexample>
	  Выйти из просмоторщика можно нажатием клавиши <keycap moreinfo="none">q</keycap>.
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Найти все предупреждения в журнале: строка, начинающаяся
	  с <quote>(WW)</quote>. Для этого ввести команду <command moreinfo="none">grep "^(WW)" test/log/XFree86.0.log</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop ~ $ grep "^(WW)" test/log/XFree86.0.log
(WW) The directory "/usr/share/fonts/freefonts/" does not exist.
(WW) The directory "/usr/share/fonts/unifont/" does not exist.
(WW) The directory "/usr/share/fonts/artwiz/" does not exist.
...</screen>
	  </informalexample>
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Получить все строки, содержащие следующий шаблон: последовательность из
	  1 или более цифры или буквы, затем символ собаки, затем еще одна
	  последовательность 1 или более цифры или буквы или точки, затем символ
	  точки, затем от двух до четырёх букв (имя домена первого
	  уровня). Также служебный вывод ошибок удаляется (перенаправляется в
	  нулевое устройство). Для этого ввести команду 
	  <command moreinfo="none">grep "[a-zA-z0-9]\+@[a-zA-z0-9\.]\+\.[a-z]\{2,4\}" /etc/* 2&gt;/dev/null</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop ~ $ grep "[a-zA-z0-9]\+@[a-zA-z0-9\.]\+\.[a-z]\{2,4\}" /etc/* 2&gt;/dev/null
/etc/devfsd.conf:# Richard Gooch  &lt;rgooch@atnf.csiro.au&gt;                3-JUL-2000
/etc/inittab:# Author:  Miquel van Smoorenburg, &lt;miquels@cistron.nl&gt;
/etc/inittab:# Modified by:  Patrick J. Volkerding, &lt;volkerdi@ftp.cdrom.com&gt;
...</screen>
	  </informalexample> При работе с несколькими
	  файлами <application moreinfo="none">grep</application> по умолчанию использует вывод имени
	  файла перед найденной стокой.
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Избавиться от имени файла в начале строки с помощью ключа
	  <parameter class="command" moreinfo="none">-h</parameter>. Ввести команду
	  <command moreinfo="none">grep -h "[a-zA-z0-9]\+@[a-zA-z0-9\.]\+\.[a-z]\{2,4\}" /etc/*
	  2&gt;/dev/null</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop ~ $ grep -h "[a-zA-z0-9]\+@[a-zA-z0-9\.]\+\.[a-z]\{2,4\}" /etc/* 2&gt;/dev/null
		      # Richard Gooch  &lt;rgooch@atnf.csiro.au&gt;                3-JUL-2000
		      # Author:  Miquel van Smoorenburg, &lt;miquels@cistron.nl&gt;
		      # Modified by:  Patrick J. Volkerding, &lt;volkerdi@ftp.cdrom.com&gt;
		      ...</screen>
	  </informalexample>     
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Для вывода только найденной подстроки используется
	  ключ <parameter class="command" moreinfo="none">-o</parameter>.  Ввести команду <command moreinfo="none">grep
	  -ho "[a-zA-Z0-9]\+@[a-zA-Z0-9\.]\+\.[a-z]\{2,4\}" /etc/* 2&gt;/dev/null</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop ~ $ grep -ho "[a-zA-Z0-9]\+@[a-zA-Z0-9\.]\+\.[a-z]\{2,4\}" /etc/* 2&gt;/dev/null
rgooch@atnf.csiro.au
miquels@cistron.nl
volkerdi@ftp.cdrom.com
...</screen>
	  </informalexample>     
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Получить все файлы директории <filename moreinfo="none">/etc/</filename> с помощью
	  команды <command moreinfo="none">find /etc -type f 2&gt;/dev/null</command>, игнорируя ошибки:
	  <informalexample> 
	    <screen format="linespecific">user@desktop ~ $ find /etc -type f 2&gt;/dev/null
/etc/X11/xorg.conf.example
/etc/X11/Sessions/kde-3.4
/etc/X11/Sessions/Xsession
/etc/X11/chooser.sh
...</screen>
	  </informalexample>     
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Для каждого из найденных файлов произвести поиск
	  подстроки <quote>nameserver</quote>.  Для этого ввести команду <command moreinfo="none">find
	  /etc -type f -exec grep "nameserver" {} \; 2&gt;/dev/null</command>:
	  <informalexample>
	    <screen format="linespecific">user@desktop ~ $ find /etc -type f -exec grep "nameserver" {} \; 2&gt;/dev/null
# merge the new nameservers with the other options from the old ...
grep --invert-match '^nameserver[[:space:]]' $REALRESOLVCONF
nameserver 10.22.10.20
...</screen>
	  </informalexample>     
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Для большего удобства добавить вывод имени файла
	  (ключ <parameter class="command" moreinfo="none">-H</parameter>) и номера строки
	  (ключ <parameter class="command" moreinfo="none">-n</parameter>), на которой было найдено
	  совпадение, с помощью команды <command moreinfo="none">find /etc -type f -exec grep -Hn
	  "nameserver" {} \; 2&gt;/dev/null</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop ~ $ find /etc -type f -exec grep -Hn "nameserver" {} \; 2&gt;/dev/null
/etc/ppp/ip-up:24:              # merge the new nameservers with the other optio...
/etc/ppp/ip-up:26:                      grep --invert-match '^nameserver[[:space...
/etc/ppp/resolv.conf:1:nameserver 10.22.10.20
...</screen>
	  </informalexample> Таким образом, команда <application moreinfo="none">grep</application> может
	  эффективно использоваться вместе с командой <application moreinfo="none">find</application> для
	  нахождения информации в файлах.
	 </para>
	</listitem>
      </orderedlist></sect2><sect2><title>Задания для самоподготовки</title><orderedlist><listitem>
	Создайте каталог test1 в домашней директории. Сравните время
	создания системных каталогов /bin, /tmp
	с каталогом test1.
      </listitem><listitem>
	Скопируйте файл /bin/ls в локальную директорию. Посмотрите
	атрибуты этого файла. Попробуйте запустить его.
      </listitem><listitem>
	Создайте в локальной директории символическую ссылку tmplnk
	на директорию /tmp. Скопируйте несколько файлов в
	директрию tmplnk.
      </listitem><listitem>
	Сравните файлы /dev/tty1
	и /dev/hda1. Какой тип они имеют? Чем они отличаются?
      </listitem><listitem>
	Найдите все файлы в системе, которые были модифицированы не более суток назад.
      </listitem><listitem>
	С помощью одной команды найдите все файлы с расширением .html в
	директории /usr и скопируйте их в локальную
	папку htmls.
      </listitem><listitem>
	Создайте архив директории /etc и узнайте его
	размер. Попробуйте создать сжатый архив той же папки. Сравните степень
	сжатия gzip и bzip2 на этом
	примере.
      </listitem><listitem>
	Создайте текстовый файл a.txt из десяти строк. Узнайте его
	размер. Создайте новый файл, содержащий в себе файл a.txt
	четыре раза.
      </listitem><listitem>
	С помощью одной команды найдите все файлы с расширением .txt в
	директории /usr и объедините их в один большой
	файл big.txt.
      </listitem><listitem>
	Получите с помощью одной команды файл, содержащий все числовые идентификаторы
	пользователей, зарегистрированных в ситсеме.
      </listitem><listitem>
	Получите с помощью одной команды строки с 5-ой по 8-ю в
	файле /proc/cpuinfo, содержащем информацию о процессоре.
      </listitem><listitem>
	Придумайте регулярное выражение, соответствующее URL с использованием
	протокола http. Найдите все строки, содержащие такие URL в
	файлах директории /etc.
      </listitem><listitem>
	С помощью одной команды найдите все файлы с расширениями .txt
	или .html в директории /usr, в которых
	содержится слово user.
      </listitem></orderedlist></sect2></sect1><sect1 id="shell-maincmdexamples-scenarios"><title>Сценарии практического занятия на тему: Работа с файлами в UNIX</title><para><xref linkend="shell-scenario-dirs"/><orderedlist><listitem>pwd</listitem><listitem>cd /</listitem><listitem>ls</listitem><listitem>ls -F --color</listitem><listitem>ls
	    -F --color ~</listitem><listitem>cd</listitem><listitem>mkdir test</listitem><listitem>ls -F
	    --color</listitem><listitem>mkdir test/subtest</listitem><listitem>ls -F --color -R</listitem></orderedlist></para><para><xref linkend="shell-scenario-filetypes"/><orderedlist><listitem>touch test/first.txt</listitem><listitem>echo "Hello, world" &gt;&gt; test/first.txt</listitem><listitem>cat test/first.txt</listitem><listitem>ls</listitem><listitem>ls -F --color -l test</listitem><listitem>alias ls='ls -F --color -l'</listitem><listitem>ls -a -i test</listitem><listitem>cd test</listitem><listitem>cp first.txt copy1.txt</listitem><listitem>mv first.txt orig.txt</listitem><listitem>mv first.txt orig.txt</listitem><listitem>ln orig.txt copy2.txt</listitem><listitem>ln -s orig.txt orig.lnk</listitem></orderedlist></para><para><xref linkend="shell-scenario-find"/><orderedlist><listitem>cd test</listitem><listitem>find</listitem><listitem>find -name "o*"</listitem><listitem>find /etc -name "o*"</listitem><listitem>find /etc -name "o*" -a -type f</listitem><listitem>find /var -name "*log" -a -type f  2&gt;/dev/null</listitem><listitem>mkdir test/logs</listitem><listitem>find /var -name "*log" -a -type f -exec cp {} test/logs/ 2&gt;/dev/null</listitem></orderedlist></para><para><xref linkend="shell-scenario-arch"/><orderedlist><listitem>cd</listitem><listitem>tar -czf test.tar.gz test</listitem><listitem>mkdir test2</listitem><listitem>cd test2</listitem><listitem>tar -xzf ../test.tar.gz</listitem><listitem>ls -l -F</listitem></orderedlist></para><para><xref linkend="shell-scenario-text"/><orderedlist><listitem>echo "One line"</listitem><listitem>echo "One line" &gt; second.txt</listitem><listitem>echo "A line" &gt;&gt;
	  second.txt</listitem><listitem>cat second.txt</listitem><listitem>cat &gt;multiline.txt</listitem><listitem>cat multiline.txt</listitem><listitem>cat orig.txt second.txt
	   multiline.txt &gt; big.txt</listitem><listitem>cat big.txt</listitem></orderedlist></para><para><xref linkend="shell-scenario-cutpaste"/><orderedlist><listitem>cat /etc/passwd</listitem><listitem>cat /etc/passwd | cut -f1 -d:</listitem><listitem>cat /etc/passwd | cut -f1 -d: | sort</listitem><listitem>cat /etc/passwd | cut -f7 -d:</listitem><listitem>cat /etc/passwd | cut -f7 -d: | uniq</listitem><listitem>cat /etc/passwd | cut
	  -f7 -d: | sort | uniq</listitem><listitem>cat /etc/passwd | cut -f1 -d: &gt; users</listitem><listitem>cat /etc/passwd | cut -f7 -d: &gt; shells</listitem><listitem>paste users shells</listitem></orderedlist></para><para><xref linkend="shell-scenario-analysis"/><orderedlist><listitem>wc -l /etc/passwd</listitem><listitem>cat users | wc -w</listitem><listitem>head logs/Xorg.0.log</listitem><listitem>tail logs/Xorg.0.log</listitem></orderedlist></para><para><xref linkend="shell-scenario-regexp"/><orderedlist><listitem>less test/log/XFree86.0.log</listitem><listitem>grep "^(WW)" test/log/XFree86.0.log</listitem><listitem>grep "[a-zA-z0-9]\+@[a-zA-z0-9\.]\+\.[a-z]\{2,4\}" /etc/* 2&gt;/dev/null</listitem><listitem>grep -h "[a-zA-z0-9]\+@[a-zA-z0-9\.]\+\.[a-z]\{2,4\}" /etc/*
	  2&gt;/dev/null</listitem><listitem>grep
	  -ho "[a-zA-Z0-9]\+@[a-zA-Z0-9\.]\+\.[a-z]\{2,4\}" /etc/* 2&gt;/dev/null</listitem><listitem>find /etc -type f 2&gt;/dev/null</listitem><listitem>find
	  /etc -type f -exec grep "nameserver" {} \; 2&gt;/dev/null</listitem><listitem>find /etc -type f -exec grep -Hn
	  "nameserver" {} \; 2&gt;/dev/null</listitem></orderedlist></para></sect1>
<!--
  <sect1 id="shell-examples-shorts-1">
    <title>Сценарии практического занятия на тему <quote>Работа с файлами в
	UNIX</quote></title>
    <scenario-summary scenario-id="shell-scenario-dirs"/>
    <scenario-summary scenario-id="shell-scenario-filetypes"/>
    <scenario-summary scenario-id="shell-scenario-find"/>
    <scenario-summary scenario-id="shell-scenario-arch"/>
    <scenario-summary scenario-id="shell-scenario-text"/>
    <scenario-summary scenario-id="shell-scenario-cutpaste"/>
    <scenario-summary scenario-id="shell-scenario-analysis"/>
    <scenario-summary scenario-id="shell-scenario-regexp"/>
  </sect1>-->
  <sect1 id="shell-syscmd">
    <title>Методические указания по командам управления системой в UNIX</title>
    <sect2 id="shell-syscmd-info">
      <title>Команды получения сведений о системе</title>
      <para>
	<variablelist>
	  <varlistentry>
	    <term><emphasis id="def-cmd-date" xreflabel="date">date</emphasis></term>
	    <listitem>
	      <para>
		Программа позволяет посмотреть текущую дату и время в одном из множества
		форматов. Суперпользователь также может использовать эту программу для
		установки текущей даты и времени.
	      </para>
	      <para>
		По умолчанию программа выводит время в формате заданной временной
		зоны. Для получения времени по Гринвичу используется
		параметр <parameter class="command" moreinfo="none">-u</parameter>.
	      </para>
	      <para>
		При выводе даты и времени используется формат вывода, принятый для данной
		страны и задаваемый переменными окружения <envar>LC_TIME</envar> и т.п..
	      </para>
	      <para>
		Рассмотрим примеры использования команды:
		<itemizedlist>
		  <listitem>
		    <para>
		      Текущее время:
		      <informalexample>
			<screen format="linespecific">user@desktop test $ date
Срд Окт 19 08:21:38 MSD 2005</screen>
		      </informalexample>
		    </para>
		  </listitem>
		  <listitem>
		    <para>
		      Текущее время по Гринвичу:
		      <informalexample>
			<screen format="linespecific">user@desktop test $ date -u
Срд Окт 19 04:21:39 UTC 2005</screen>
		      </informalexample>
		    </para>
		  </listitem>
		</itemizedlist>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-cal" xreflabel="cal">cal</emphasis></term>
	    <listitem>
	      <para>	
		Команда предназначена для вывода календаря на месяц или на год.
		По умолчанию, выводит календарь текущего месяца.
	      </para>
	      <para>
		В качестве параметра можно указать год или месяци год. Обратим внимание,
		что команда <command moreinfo="none">cal 05</command> выведет календарь на 5-й год, а не
		на 2005-й.
	      </para>
	      <para>
		При выводе календаря используется формат вывода, принятый для данной
		страны и задаваемый переменными окружения <envar>LC_TIME</envar> и т.п..
	      </para>
	      <para>
		Рассмотрим примеры использования команды:
		<itemizedlist>
		  <listitem>
		    <para>
		      Календарь на текущий месяц
		      <informalexample>
			<screen format="linespecific">user@desktop test $ cal
    Октября 2005
Вс Пн Вт Ср Чт Пт Сб
                   1
 2  3  4  5  6  7  8
 9 10 11 12 13 14 15
16 17 18 19 20 21 22
23 24 25 26 27 28 29
30 31</screen>
		      </informalexample>
		    </para>
		  </listitem>
		  <listitem>
		    <para>
		      Календарь на 2005 год.
		      <informalexample>
			<screen format="linespecific">user@desktop test $ cal 2005
                               2005

       Января                 Февраля                 Марта
Вс Пн Вт Ср Чт Пт Сб   Вс Пн Вт Ср Чт Пт Сб   Вс Пн Вт Ср Чт Пт Сб
                   1          1  2  3  4  5          1  2  3  4  5
 2  3  4  5  6  7  8    6  7  8  9 10 11 12    6  7  8  9 10 11 12
 9 10 11 12 13 14 15   13 14 15 16 17 18 19   13 14 15 16 17 18 19
16 17 18 19 20 21 22   20 21 22 23 24 25 26   20 21 22 23 24 25 26
23 24 25 26 27 28 29   27 28                  27 28 29 30 31
30 31
...</screen>
		      </informalexample>
		    </para>
		  </listitem>
		</itemizedlist>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-ps" xreflabel="ps">ps</emphasis></term>
	    <listitem>
	      <para>
		Команда выводит список всех запущенных процессов. Когда эта команда
		выполняется без параметров, то выводимый список содержит информацию о
		номере процесса, связанном с ним терминале, времени работы
		процесса <command moreinfo="none">ps</command> и командной оболочки, в которой он был
		запущен. Однако, эта команда имеет множество опций, позволяющих проследить
		многие параметры исполняющихся в системе процессов.
	      </para>
	      <para>
		Команда <command moreinfo="none">ps</command> обладает несколькими видами записи
		параметров, что может в вести в заблуждение: например, список всех
		исполняющихся процессов можно получить как с помощью команды <command moreinfo="none">ps
		ax</command> или <command moreinfo="none">ps -ef</command>, а также с помощью <command moreinfo="none">ps
		-A</command>. На все возможные опции можно взгялнуть,
		запустив <command moreinfo="none">ps --help</command>.  Таким разнородным параметрам
		команда обязана своей долгой истории использования во всех версиях UNIX
		(например, ключи без знака <quote>-</quote> достались в наследство от BSD
		UNIX).
	      </para>
	      <para>
		Для просмотра всех процессов можно воспользуемся следующей командой:
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ ps aux
USER     PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root       1  0.0  0.0   1432   480 ?        S    13:16   0:01 init [3]
root       2  0.0  0.0      0     0 ?        SN   13:16   0:00 [ksoftirqd/0]
root       3  0.0  0.0      0     0 ?        S&lt;   13:16   0:00 [events/0]
..
user    8456  0.3  4.4  34932 22944 ?        S    13:24   2:15 emacs
user   22537  0.0  0.3   3720  1560 pts/3    Ss   22:37   0:00 /bin/bash
user    8839  0.0  0.1   2644   932 pts/3    R+   23:01   0:00 ps aux</screen>
		</informalexample>
		Вывод этой команды ориентирован на пользователя (ключ 
		<parameter class="command" moreinfo="none">u</parameter>), но отсортирован по времени
		запуска процесса.
		Здесь можно увидеть следующие параметры процесса: пользователь,
		идентификатор, уровень использования процессора, уровень использования
		памяти, объём используемой виртуальной памяти, объём используемой реальной
		памяти, терминал, с которым связан процесс, состояние выполнения, время
		старта, время исполнения (на процессоре), имя программы и аргументы
		запуска. Отметим, что сам процесс <command moreinfo="none">ps</command> всегда находится в
		конце таблицы, так как сам выполнялся в момент сбора состояния процессов.
	      </para>
	      <para>
		При добавлении параметра <parameter class="command" moreinfo="none">-H</parameter> можно
		посмотреть процессы, выстроенные в иерархию:
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ ps u -H
USER   PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
user 22537  0.0  0.3   3720  1560 pts/3    Ss   22:37   0:00 /bin/bash
user  8890  0.0  0.1   2644   876 pts/3    R+   23:13   0:00   ps u -H
user  9243  0.0  0.2   3724  1368 pts/1    Ss+  17:15   0:00 /bin/bash --noediting -i
user  8033  0.0  0.3   3720  1568 tty1     S    13:17   0:00 -bash
user  8168  0.0  0.2   3260  1120 tty1     S+   13:18   0:00   /bin/sh /usr/bin/startx
user  8179  0.0  0.1   2240   636 tty1     S+   13:18   0:00     xinit .xinitrc --
user  8186  0.0  0.2   3516  1080 tty1     S    13:18   0:00       sh /home/user/.xinitrc
...</screen>
		</informalexample>
		В данном случае выводятся все процессы текущего пользователя.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-pstree" xreflabel="pstree">pstree</emphasis></term>
	    <listitem>
	      <para>
		Для иерархического отображения запущеных процессов больше подходит
		программа <command moreinfo="none">pstree</command>, отображающая дерево запущенных
		процессов:
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ pstree
init─┬─acpid
     ├─5*[agetty]
     ├─2*[artsd]
     ├─cpufreqd
     ├─dcopserver
     ├─events/0
     ├─fcron
     ├─gconfd-2
     ├─hcid
     ├─kaccess
     ├─kded───kded───kded
     ├─kdeinit─┬─artsd───artsd───artsd
     │         ├─kio_file
     │         ├─kio_imap4───kio_imap4
...</screen>
		</informalexample>
	      </para>
	      <para>
		Видно, что в вершине дерева находится специальный
		процесс <emphasis>init</emphasis>, который в UNIX является самым первым
		процессом, запускаемым операционной системой.
	      </para>
	      <para>
		Эта команда также имеет множество ключей, настраивающих формат вывода
		информации о процессах. 
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-top" xreflabel="top">top</emphasis></term>
	    <listitem>
	      <para>
		Для вывода динамически изменяющейся информации о процессах и используемых
		ресурсах системы используется программа <command moreinfo="none">top</command>. После
		запуска программы пользователь попадает в интерактивный интерфейс:
		<informalexample>
		  <screen format="linespecific">Tasks:  86 total,   2 running,  84 sleeping,   0 stopped,   0 zombie
Cpu(s):  6.2% us,  0.8% sy,  0.0% ni, 92.0% id,  0.6% wa,  0.3% hi,  0.0% si
Mem:    512480k total,   428352k used,    84128k free,    44848k buffers
Swap:   529160k total,    12312k used,   516848k free,   210444k cached

  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
 8239 dralex    15   0 26856 8860 6512 S  7.9  1.7   5:39.31 artsd
    1 root      16   0  1432  480  420 S  0.0  0.1   0:01.22 init
    2 root      34  19     0    0    0 S  0.0  0.0   0:00.01 ksoftirqd/0
    3 root      10  -5     0    0    0 S  0.0  0.0   0:00.54 events/0
    4 root      10  -5     0    0    0 S  0.0  0.0   0:00.00 khelper
    5 root      10  -5     0    0    0 S  0.0  0.0   0:00.00 kthread
    8 root      10  -5     0    0    0 S  0.0  0.0   0:00.59 kacpid
    7 root       7 -10     0    0    0 S  0.0  0.0   0:00.10 vesafb
...</screen>
		</informalexample>
		Для выхода используется клавиша <keycap moreinfo="none">q</keycap>. Программа имеет много
		управляющих клавиш, которые можно узнать, нажав на <keycap moreinfo="none">h</keycap>
		(help).
	      </para>
	      <para>
		Вверху экрана расположена общая информация о системе: число запущенных
		процессов, уровень использования процессора и памяти. Далее следует
		обновляемый список процессов в стиле <command moreinfo="none">ps</command>,
		отсортированный по уменьшению процессорной активности.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-free" xreflabel="free">free</emphasis></term>
	    <listitem>
	      <para>
		Небольшая команда, предоставляющая информацию об использовании памяти. Она
		представлена не во всех современных версиях UNIX.
	      </para>
	      <para>
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ free
             total       used       free     shared    buffers     cached
Mem:        512480     476256      36224          0      51216     251712
-/+ buffers/cache:     173328     339152
Swap:       529160      11500     517660</screen>
		</informalexample>
		Команда выводит объём оперативной памяти (в килобайтах) и устройства
		своппинга: общий, свободный, занятый, используемый для системных нужд.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-df" xreflabel="df">df</emphasis></term>
	    <listitem>
	      <para>
		Существует команда и для простотра заполненности дисков. 
	      </para>
	      <para>
		Команда <command moreinfo="none">df</command> выводит сведения обо всех примонтированных
		файловых системах:
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ df
Файловая система     1K-блоков      Исп  Доступно  Исп% смонтирована на
/dev/hda6             24697672  21164336   3533336  86% /
udev                    256240       180    256060   1% /dev
/dev/hda1              9827968   8073084   1754884  83% /mnt/win
none                    256240         0    256240   0% /dev/shm
server:/home/shared    8194752   5368992   2416032  69% /mnt/shared</screen>
		</informalexample>
	      </para>
	      <para>
		Для более <quote>человеческого</quote> представления объёма диска
		используется  ключ <parameter class="command" moreinfo="none">-h</parameter>:
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ df -h
Файловая система      Разм  Исп  Дост  Исп% смонтирована на
/dev/hda6              24G   21G  3,4G  86% /
udev                  251M  180K  251M   1% /dev
/dev/hda1             9,4G  7,7G  1,7G  83% /mnt/win
none                  251M     0  251M   0% /dev/shm
server:/home/shared   7,9G  5,2G  2,4G  69% /mnt/shared</screen>
		</informalexample>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-who" xreflabel="who">who</emphasis></term>
	    <listitem>
	      <para>
		Команда выводит список пользователей, работающих в настоящий момент в
		системе. 
	      </para>
	      <para>
		При запуске без параметров для каждого сеанса пользователя выводится
		терминал и время входа в систему:
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ who
user   tty1         2005-10-24 13:17
user   pts/0        2005-10-24 13:19
user   pts/2        2005-10-24 23:59</screen>
		</informalexample>
	      </para>	
	      <para>
		При указании параметра <parameter class="command" moreinfo="none">-u</parameter> выводится
		время неактивности для каждого терминала и идентификатор соответствующего
		ему процесса:
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ who
user   tty1         2005-10-24 13:17 11:41        7992
user   pts/0        2005-10-24 13:19 11:41        8228
user   pts/2        2005-10-24 23:59   .          9280</screen>
		</informalexample>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-mount" xreflabel="mount">mount</emphasis></term>
	    <listitem>
	      <para>
		Эта команда используется для <emphasis>монтирования</emphasis> новых файловых
		систем (подробнее об этом сказано в разделе
		<xref linkend="intro-unix-files-processors"/>). В общем случае
		команда <command moreinfo="none">mount</command> имеет следующий формат:
		<synopsis format="linespecific">mount [-t тип_ФС] имя_устройства точка_монтирования [опции]</synopsis>
	      </para>
	      <para>
		Рассмотрим пример монтирования гибкого диска:
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ mount -t vfat /dev/fd0 /mnt/floppy -o rw
user@desktop ~ $ ls /mnt/floppy
document.tex files/</screen>
		</informalexample>
		В качестве файловой системы указан FAT, опции содержат флаг разрешения
		чтения и записи содержимого диска. После монтирования файлы доступны в
		директории <filename moreinfo="none">/mnt/floppy</filename>.
	      </para>
	      <para>
		Для размонтирования применяется команда <command moreinfo="none">umount</command>.
	      </para>
	      <para>
		При запуске <command moreinfo="none">mount</command> без параметров выводится список всех
		примонтированных локальных и сетевых файловых систем:
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ mount
/dev/hda6 on / type reiserfs (rw,noatime)
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
udev on /dev type tmpfs (rw,nosuid)
devpts on /dev/pts type devpts (rw)
/dev/hda1 on /mnt/win type ntfs (ro,uid=1000,gid=100,nls=utf8)
none on /dev/shm type tmpfs (rw)
usbfs on /proc/bus/usb type usbfs (rw,devmode=0664,devgid=85)
server:/home/shared on /mnt/shared type nfs (rw,rsize=32768,wsize=32768,intr,...</screen>
		</informalexample>
		Можно увидеть ряд служебных файловых систем (proc, udev, sysfs, т.п.).
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-uname" xreflabel="uname">uname</emphasis></term>
	    <listitem>
	      <para>
		Вывод имени запущенной UNIX-системы.
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ uname
Linux</screen>
		</informalexample>
	      </para>
	      <para>
		Для вывода полного имени используется
		параметр <parameter class="command" moreinfo="none">-a</parameter>:
		<informalexample>
		  <screen format="linespecific">user@desktop ~ $ uname -a
Linux thinkpad 2.6.13-gentoo-r4 #1 Mon Oct 17 12:09:36 MSD 2005 i686 Intel(R)...</screen>
		</informalexample>
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>		
      </para>
    </sect2>   
    <sect2 id="shell-syscmd-proc">
      <title>Команды по работе с процессами</title>
      <para>
	<variablelist>
	  <varlistentry>
	    <term><emphasis id="def-cmd-kill" xreflabel="kill">kill</emphasis></term>
	    <listitem>
	      <para>
		Команда используется для отправки сигнала процессу.
	      </para>
	      <para>
	       Команда <command moreinfo="none">kill</command> имеет один из следующих форматов:
	       <synopsis format="linespecific">kill [-s название_сигнала] идентификатор_процесса</synopsis>
	       <synopsis format="linespecific">kill -название_сигнала идентификатор_процесса</synopsis>
	       <synopsis format="linespecific">kill -код_сигнала идентификатор_процесса</synopsis>
	       </para>
	       <para>
		 Для того, чтобы отправить сигнал, необходимо знать идентификатор процесса-получателя. Узнать идентификатор можно с помощью команды <command moreinfo="none">ps</command>. Если при вызове команды <command moreinfo="none">kill</command> сигнал не указан, то посылается сигнал <emphasis>TERM</emphasis>. Обычный пользователь может посылать сигналы только своим процессам. Посылать сигналы процессам других пользователей может только суперпользователь. Рассмотрим пример уничтожения процесса:
		<informalexample>
		 <screen format="linespecific">user@desktop ~ $ ps
PID  TT  STAT      TIME COMMAND
3800  p3  S      0:00,03 su (bash)
3822  p3  T      0:00,08 mplayer /home/guest/music/U96/Das\ Boot.mp3
3824  p3  R+     0:00,00 ps
user@desktop ~ $ kill 3822</screen>
		</informalexample>
		После вызова команды <command moreinfo="none">kill 3822</command> процесс <emphasis>mplayer</emphasis> будет уничтожен.
	       </para>
	       <para>
		Для вывода списка всех сигналов используется команда <command moreinfo="none">kill -l</command>:
		<informalexample>
			<screen format="linespecific">user@desktop ~ $ kill -l
1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL
5) SIGTRAP      6) SIGABRT      7) SIGEMT       8) SIGFPE
9) SIGKILL     10) SIGBUS      11) SIGSEGV     12) SIGSYS
13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGURG
17) SIGSTOP     18) SIGTSTP     19) SIGCONT     20) SIGCHLD
21) SIGTTIN     22) SIGTTOU     23) SIGIO       24) SIGXCPU
25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH
29) SIGINFO     30) SIGUSR1     31) SIGUSR2</screen>
		</informalexample>
	       </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-exec" xreflabel="exec">exec</emphasis></term>
	    <listitem>
	      <para>
	       Является встроенной командой оболочки. Используется для замены процесса shell другим процессом.
	      </para>
	      <para>
	       Команда <command moreinfo="none">exec</command> имеет следующий синтаксис:
	       <synopsis format="linespecific">exec -lc -a имя исполняемый файл [перенаправление ...]</synopsis>
              </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-fork" xreflabel="fork (&amp;)">fork (&amp;)</emphasis></term>
	    <listitem>
	      <para>
	       Символ <quote>&amp;</quote> используется для запуска программ в фоновом режиме. Пример:
	       <informalexample>
		<screen format="linespecific">user@desktop ~ $ mplayer /home/guest/music/U96/Das\ Boot.mp3&amp;
[1] 1558</screen>
	       </informalexample>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-jobs" xreflabel="bg, fg и jobs">bg, fg и jobs</emphasis></term>
	    <listitem>
	      <para>
	       Являются встроенными командами оболочки. Команды используются для работы с заданиями – процессами, запущенными из  командного интерпретатора.
	      </para>
	      <para>
	       Команда <command moreinfo="none">jobs</command> имеет следующий синтаксис:
	       <synopsis format="linespecific">jobs [-lnprs] [jobspec ...]</synopsis>
	       <synopsis format="linespecific">jobs -x команда [аргументы]</synopsis>
	      </para>
	      <para>
	       Для вывода всех заданий используется команда <command moreinfo="none">jobs</command>:
	       <informalexample>
		       <screen format="linespecific">user@desktop ~ $ jobs
[1]+  Running                 nice -n 20 tar -cyf test.tar.bz2 /home/guest/data/* &amp;
[2]+  Stopped                 nice -n 20 tar -cyf test.tar.bz2 /home/guest/texts/*
[3]-  Exit 127                nice 20 tar -cyf /abcdefg/texts ./test.tar.bz2
[4]+  Done                    tar -cyf test.tar.bz2 text.txt</screen>
	       </informalexample>
	       Напротив идентификатора задания указано состояние процесса.
	      </para>
	      <para>
	       Для вывода, кроме основной информации, идентификаторов запущенных процессов 
	       используется флаг <parameter class="command" moreinfo="none">-l</parameter>.
	       Для вывода только идентификаторов запущенных процессов используется флаг <parameter class="command" moreinfo="none">-p</parameter>.
	       Для вывода информации о процессах, у которых изменилось состояние с момента последнего вызова
	       команды <command moreinfo="none">jobs</command> используется флаг <parameter class="command" moreinfo="none">-n</parameter>.
	      </para>
	      <para>
	       Команда <command moreinfo="none">bg</command> используется для перевода задачи в фоновый режим.
	      </para>
	      <para>
	       Команда имеет следующий синтаксис:
	       <synopsis format="linespecific">bg [идентификатор_задачи]</synopsis>
	      </para>
	      <para>
	       Запуск команды без параметров приводит к запуску в фоновом режиме текущей задачи.
	       Если указан параметр <parameter class="command" moreinfo="none">идентификатор_задачи</parameter>, то в фоновом 
	       режиме будет запущена указанная задача.
	       Пример:
	       <informalexample>
		       <screen format="linespecific">user@desktop ~ $ bg
[1]+ nice -n 20 tar -cyf test.tar.bz2 /home/guest/texts/* &amp;</screen>
	       </informalexample>
	      </para>
	      <para>
	       Команда <command moreinfo="none">fg</command> используется для перевода задачи на передний план.
	      </para>
	      <para>
	       Команда имеет следующий синтаксис:
	       <synopsis format="linespecific">fg [идентификатор_задачи]</synopsis>
	      </para>
	      <para>
	       Запуск команды без параметров переводит к переводу текущей задачи на передний план. Если указан параметр
	       <parameter class="command" moreinfo="none">идентификатор_задачи</parameter>, то задача с указанным 
	       идентификатором станет текущей и будет переведена на передний план.
	       Пример:
	       <informalexample>
	        <screen format="linespecific">user@desktop ~ $fg
nice -n 20 tar -cyf test.tar.bz2 /home/guest/texts/*</screen>
	        </informalexample>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-nohup" xreflabel="nohup">nohup</emphasis></term>
	    <listitem>
	      <para>
	       Команда позволяет запустить процесс, отключив его от управляющего терминала.
	      </para>
	      <para>
	       Команда <command moreinfo="none">nohup</command> имеет следующий синтаксис:
	       <synopsis format="linespecific">nohup [--] запускаемая_программа [аргументы]</synopsis>
	       <command moreinfo="none">nohup</command> запускает указанную программу с игнорированием сигналов <emphasis>HUP</emphasis> и увеличением приоритета для планировщика задач на 5. Таким образом, команда может продолжать выполняться в фоновом режиме и после того, как пользователь выйдет из системы. Если стандартным выводом <emphasis>stdout</emphasis> команды является терминал, то он и стандартный поток ошибок <emphasis>stderr</emphasis> перенаправляются в файл <filename moreinfo="none">nohup.out</filename> в текущей директории. Если это невозможно, то перенаправление происходит в файл <filename moreinfo="none">$HOME/nohup.out</filename>. Если и это невозможно сделать, то команда не запускается.
	       Команда <command moreinfo="none">nohup</command> не переводит автоматически запускаемый процесс в фоновый режим. Чтобы это сделать, необходимо завершить команду символом &amp;.
              </para>
	      <para>
	       Пример использования:
	       <informalexample>
		       <screen format="linespecific">user@desktop ~ $ nohup mplayer /home/guest/music/U96/Das\ Boot.mp3
appending output to /home/guest/nohup.out</screen>
		</informalexample>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-nice" xreflabel="nice">nice</emphasis></term>
	    <listitem>
	      <para>
		Команда используется для запуска процесса с измененным приоритетом для планировщика задач.
	      </para>
	      <para>
	       Команда <command moreinfo="none">nice</command> имеет следующий формат:
       	       <synopsis format="linespecific">nice [-n смещение_приоритета] запускаемая_программа [аргументы]</synopsis>
       	      </para>
	      <para>
	       Команда <command moreinfo="none">nice</command> позволяет изменять приоритет от -20 (наивысший) до 20 (самый низкий) от текущего. По умолчанию, процессы имеют приоритет командного интерпретатора, из которого они запускаются. Повышать приоритет может только суперпользователь (т.е. задавать отрицательное значение параметра <parameter class="command" moreinfo="none">-n смещение_приоритета</parameter>).
	       Пример использования команды:
	       <informalexample>
		       <screen format="linespecific">user@desktop ~ $ nice -n 15 mplayer /home/guest/music/U96/Das\ Boot.mp3 &amp;
[1] 895
uest@premudrij-peskar$ ps -l
UID   PID  PPID CPU PRI NI   VSZ   RSS MWCHAN STAT  TT       TIME COMMAND
1002   890   889   0   8  0  3112  1660 wait   S     p2    0:00,02 su (bash)
1002   895   890   0 111 15 23000 13200 -      TN    p2    0:00,08 mplayer /home/guest/music/U96/Das\ Boot.mp3
1002   896   890   0  96  0  1392   768 -      R+    p2    0:00,00 ps -l</screen>
		</informalexample>
		Значение <emphasis>NI</emphasis> процесса <emphasis>mplayer</emphasis> равно 15, для всех остальных процессов равно 0 по умолчанию.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><emphasis id="def-cmd-renice" xreflabel="renice">renice</emphasis></term>
	    <listitem>
	      <para>
	       Команда используется для изменения приоритета запущенных процессов.
	      </para>
	      <para>
	       Команда <command moreinfo="none">renice</command> имеет следующий формат:
	       <synopsis format="linespecific">renice новое_значение_приоритета список_идентификаторов</synopsis>
	       <synopsis format="linespecific">renice -n смещение_приоритета список_идентификаторов</synopsis>
	       Для изменения значения приоритета отдельных процессов достаточно перечислить их идентификаторы:
	       <informalexample>
		       <screen format="linespecific">user@desktop ~ $ ps -l
UID   PID  PPID CPU PRI NI   VSZ   RSS MWCHAN STAT  TT       TIME COMMAND
1002   890   889   0  96  0  3112  1600 -      R     p2    0:00,06 su (bash)
1002   895   890   0 111 17 23000 11224 -      TN    p2    0:00,08 mplayer Boot.mp3
1002   900   890   0 101  5 23000 11224 -      TN    p2    0:00,08 mplayer Boot.mp3
1002  1084   890   1  96  0  1392   760 -      R+    p2    0:00,00 ps -l
user@desktop ~ $ renice +18 895 900
895: old priority 17, new priority 18
900: old priority 5, new priority 18
user@desktop ~ $ ps -l
UID   PID  PPID CPU PRI NI   VSZ   RSS MWCHAN STAT  TT       TIME COMMAND
1002   890   889   0   8  0  3112  1600 wait   S     p2    0:00,06 su (bash)
1002   895   890   0 111 18 23000 11224 -      TN    p2    0:00,08 mplayer Boot.mp3
1002   900   890   0 101 18 23000 11224 -      TN    p2    0:00,08 mplayer Boot.mp3
1002  1086   890   0  96  0  1392   760 -      R+    p2    0:00,00 ps -l</screen>
		</informalexample>
	       </para>
       	       <para>
		Для изменения приоритета всех процесов какого-либо пользователя необходимо указать флаг <parameter class="command" moreinfo="none">-u</parameter>. В этом случае значения идентификаторов после флага <parameter class="command" moreinfo="none">-u</parameter> будут интерпретироваться как идентификаторы пользователей. Можно задавать как числовые, так и символьные идентификаторы пользователей.
		<informalexample>
			<screen format="linespecific">user@desktop ~ $ renice -n 1 -u guest
1002: old priority 0, new priority 1
user@desktop ~ $ ps -l
UID   PID  PPID CPU PRI NI   VSZ   RSS MWCHAN STAT  TT       TIME COMMAND
1002   890   889   0   8  1  3112  1600 wait   SN    p2    0:00,07 su (bash)
1002   895   890   0 111 18 23000 11224 -      TN    p2    0:00,08 mplayer Boot.mp3
1002   900   890   0 101 18 23000 11224 -      TN    p2    0:00,08 mplayer Boot.mp3
1002  1110   890   0  97  1  1392   760 -      RN+   p2    0:00,00 ps -l</screen>
		</informalexample>
		Из данного примера видно, что значения <emphasis>NI</emphasis> для
		процессов <emphasis>mplayer</emphasis> не изменились. Вызов
		команды <command moreinfo="none">renice</command> с
		флагом <parameter class="command" moreinfo="none">-n</parameter> изменяет только
		минимальные приоритеты (в данном случае, нули).
	       </para>
	    </listitem>
	  </varlistentry>
	</variablelist>		
      </para>
    </sect2>
    <sect2 id="shell-syscmd-summary">
      <title>Резюме</title>
      <para>
	В данном разделе рассматриваются команды управления процессами и сбора сведений о
	системе. 
      </para>
      <para><emphasis>Ключевые термины: </emphasis><xref linkend="def-cmd-date"/>, <xref linkend="def-cmd-cal"/>, <xref linkend="def-cmd-ps"/>, <xref linkend="def-cmd-pstree"/>, <xref linkend="def-cmd-top"/>, <xref linkend="def-cmd-free"/>, <xref linkend="def-cmd-df"/>, <xref linkend="def-cmd-who"/>, <xref linkend="def-cmd-mount"/>, <xref linkend="def-cmd-uname"/>, <xref linkend="def-cmd-kill"/>, <xref linkend="def-cmd-exec"/>, <xref linkend="def-cmd-fork"/>, <xref linkend="def-cmd-jobs"/>, <xref linkend="def-cmd-nohup"/>, <xref linkend="def-cmd-nice"/>, <xref linkend="def-cmd-renice"/></para>
    </sect2>    
    <sect2 id="shell-syscmd-additional">
      <title>Дополнительные материалы</title>
      <para>
	<orderedlist inheritnum="ignore" continuation="restarts">
	  <listitem>
	    Курячий Г.В., Маслинский К.А. <emphasis>Операционная система
	    Linux</emphasis>. – М.: Интуит.Ру, 2005. – 392 с.: ил.
	  </listitem>
	  <listitem>
	    Курячий Г.В. <emphasis>Операционная система UNIX</emphasis>. –
	    М.: Интуит.Ру, 2004. – 292 с.: ил.
	  </listitem>
	  <listitem>
	    Рейчардс К., Фостер-Джонсон Э. <emphasis>UNIX:
	    справочник</emphasis>. – СПб.: Питер Ком, 1999. – 384 с.:
	    ил.
	  </listitem>
	</orderedlist>
      </para>
    </sect2>
  </sect1>
  <!-- занятие №5 (практическое занятие) -->
  <sect1 id="shell-syscmdexamples"><title>Практическое занятие. Сбор сведений о системе и управление процессами</title><para>
      <emphasis>Цель занятия:</emphasis> знакомство с командами по работе с процессами и
      командами, предоставляющимиприменение предоставляющими сведения о системе.
    </para><para>
      <emphasis>Изучаемые команды:</emphasis> 
      <xref linkend="def-cmd-mount"/>,
      <xref linkend="def-cmd-ps"/>,
      <xref linkend="def-cmd-pstree"/>,
      <xref linkend="def-cmd-top"/>,
      <xref linkend="def-cmd-uname"/>,
      <xref linkend="def-cmd-who"/>,
      <xref linkend="def-cmd-jobs"/>,
      <xref linkend="def-cmd-grep"/>,
      <xref linkend="def-cmd-pstree"/>,
      <xref linkend="def-cmd-kill"/>,
      <xref linkend="def-cmd-mkfifo"/>,
      <xref linkend="def-cmd-nohup"/>,
      <xref linkend="def-cmd-nice"/>,
      <xref linkend="def-cmd-renice"/>
    </para><sect2 id="shell-scenario-sysinfo"><title>Сценарий: Сбор сведений о системе</title><para>
	
	  В данном сценарии изучаются команды, предоставляющие сведения
	  о системе.
  	
      </para><para><emphasis>Начальные условия:</emphasis>
	 Командная строка после входа в систему.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	  <para>
	    Определить имя текущей UNIX-системы с помощью команды <command moreinfo="none">uname -a</command>
	    <informalexample> 
	    <screen format="linespecific">user@desktop ~ $ uname -a
Linux thinkpad 2.6.13-gentoo-r4 #1 Mon Oct 17 12:09:36 MSD 2005 i686 Intel(R)...</screen>
	    </informalexample>
	    Здесь выводится полная версия системы, дата компиляции ядра и тип процессора.
	  </para>
	</listitem>	      
	<listitem>
	 <para>
	  Вывести содержимое директории <filename moreinfo="none">proc</filename> с помощью команды <command moreinfo="none">ls /proc</command>:
	  <informalexample>
	    <screen format="linespecific">user@desktop ~ $ ls /proc
1/     7/     8113/  8209/  9073/       dri/         modules
103/   7060/  8124/  8211/  9324/       driver/      mounts@
106/   7128/  8125/  8213/  9325/       execdomains  mtrr
185/   7693/  8131/  8215/  937/        fb           net/
186/   7770/  8135/  8319/  9376/       fb1/         partitions
...</screen>
	  </informalexample>
	  Признаком операционной системы Linux является наличие
	  директории <filename moreinfo="none">/proc</filename>, которая содержит псевдофайлы,
	  предоставляющие системную информацию и позволяющие настраивать ядро.
	 </para>
        </listitem>
	<listitem>
	  <para>
	   Вывести текущие пользовательские сеансы с помощью команды <command moreinfo="none">who</command>:
	  <informalexample>
	    <screen format="linespecific">user@desktop ~ $ who
user   tty1         2005-10-24 13:17
user   pts/0        2005-10-24 13:19
user   pts/2        2005-10-24 23:59</screen>
	  </informalexample>
	 </para>
	</listitem>	      
	<listitem>
	 <para>
	  Вывести список всех примонтированных устройств с помощью команды <command moreinfo="none">mount</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop ~ $ mount
/dev/hda6 on / type reiserfs (rw,noatime)
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
udev on /dev type tmpfs (rw,nosuid)
devpts on /dev/pts type devpts (rw)
/dev/hda1 on /mnt/win type ntfs (ro,uid=1000,gid=100,nls=utf8)</screen>
	  </informalexample>
	  Первый столбец – имя устройства, второй – точка
	  монтирования, далее следует тип файловой системы и опции монтирования.
	 </para>
        </listitem>	      
	<listitem>
	 <para>
	  Вывести загруженность примонтированных дисков с помощью команды <command moreinfo="none">df -h</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop ~ $ df -h
Файловая система      Разм  Исп  Дост  Исп% смонтирована на
/dev/hda6              24G   21G  3,4G  86% /
udev                  251M  180K  251M   1% /dev
/dev/hda1             9,4G  7,7G  1,7G  83% /mnt/win
none                  251M     0  251M   0% /dev/shm</screen>
	  </informalexample>
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Вывести информацию о всех выполняющихся процессах с помощью команды <command moreinfo="none">ps aux</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop ~ $ ps aux
USER     PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root       1  0.0  0.0   1432   480 ?        S    13:16   0:01 init [3]
root       2  0.0  0.0      0     0 ?        SN   13:16   0:00 [ksoftirqd/0]
root       3  0.0  0.0      0     0 ?        S&lt;   13:16   0:00 [events/0]
..
user    8456  0.3  4.4  34932 22944 ?        S    13:24   2:15 emacs
user   22537  0.0  0.3   3720  1560 pts/3    Ss   22:37   0:00 /bin/bash
user    8839  0.0  0.1   2644   932 pts/3    R+   23:01   0:00 ps aux</screen>
	  </informalexample>
	 </para>
	</listitem>	      
	<listitem>	      
	 <para>
	  Оставить в выводе предыдущей команды только системные процессы с помощью команды 
	  <command moreinfo="none">ps aux | grep -v user</command>:
	  <informalexample> 
	    <screen format="linespecific">user@desktop ~ $ ps aux | grep -v user
USER     PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root       1  0.0  0.0   1432   480 ?        S    13:16   0:01 init [3]
root       2  0.0  0.0      0     0 ?        SN   13:16   0:00 [ksoftirqd/0]
root       3  0.0  0.0      0     0 ?        S&lt;   13:16   0:00 [events/0]
...
root      6989  0.0  0.1   1672   704 ?        Ss   Oct25   0:00 /usr/sbin/syslog
root      7128  0.0  0.1   2020   716 ?        Ss   Oct25   0:00 /usr/sbin/fcron
	    </screen>
	  </informalexample>
	  Часть процессов, показанные в квадратных скобках, – это
	  потоки ядра, исполняющие специальные функции. Можно выделить
	  демонов – в столбце терминала они имеют
	  символ <quote>?</quote>. Например, системный журнал
	  (<application moreinfo="none">syslog</application>) или планировщик задач
	  (<application moreinfo="none">cron</application>).
	 </para>
	</listitem>
	<listitem>
	 <para>
	  Вывести иерархию процессов с помощью команды <command moreinfo="none">pstree</command>:
	  <informalexample>
	    <screen format="linespecific">user@desktop ~ $ pstree
init─┬─acpid
     ├─5*[agetty]
     ├─2*[artsd]
     ├─cpufreqd
     ├─dcopserver
     ├─events/0
     ├─fcron
     ├─gconfd-2
     ├─hcid
     ├─kaccess
     ├─kded───kded───kded
     ├─kdeinit─┬─artsd───artsd───artsd
     │         ├─kio_file
     │         ├─kio_imap4───kio_imap4
...</screen>
	  </informalexample>
	  В вершине дерева стоит процесс <application moreinfo="none">init</application>.
	 </para>
	</listitem>
	<listitem>	      
	 <para>
	  Рассмотреть поведение процессов интерактивно с помощью
	  команды <command moreinfo="none">top</command>.
	 </para>
	</listitem>
      </orderedlist></sect2><sect2 id="shell-scenario-signals"><title>Сценарий: Управление процессами с помощью сигналов</title><para>
	
	  В данном сценарии изучаются сигналы, управляющие клавиши для передачи процессам
	  сигналов, команды для управления процессами.
	
      </para><para><emphasis>Начальные условия:</emphasis>
	  Командная строка после входа в систему.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	  <para>
	    Запустите команду <command moreinfo="none">yes</command>, производящую бесконечный вывод
	    символа <literal moreinfo="none">y</literal> на экран. Прервите её
	    нажатием <keycombo moreinfo="none"><keycap moreinfo="none">Ctrl</keycap> <keycap moreinfo="none">C</keycap></keycombo>.
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ yes
y
y
y
y
...
y

user@desktop ~ $</screen>
	    </informalexample>
	    При этом запущенному процессу был отправлен сигнал SIGTERM –
	    завершения программы.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Запустим сбор информации обо всех файлах системы с помощью
	    команды <command moreinfo="none">find / &gt; files.txt</command>.
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ find / &gt; files.txt</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Найдем идентификатор запущенного только что процесса с помощью
	    команды <command moreinfo="none">ps aux | grep find</command>, запущенной в другом терминале.
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ ps aux | grep find
user    8178  9.7  0.1   2844  1020 pts/1    R+   23:45   0:00 find /
user    8230  0.0  0.1   2708   736 pts/2    R+   23:45   0:00 grep find</screen>
	    </informalexample>
	    Первая строка содержит необходимый PID.
	  </para>
	</listitem>	
	<listitem>
	  <para>
	    Отправим сигнал завершения этому процессу с помощью команды <command moreinfo="none">kill
	    8178</command>, указав в качестве параметара идентификатор процесса.
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ kill 8178</screen>
	    </informalexample>
	    Можно убедиться, что на терминале с запущенной командой появились
	    строка <quote>Terminated</quote> и приглашение.
	  </para>
	</listitem>	
	<listitem>
	  <para>
	    Если попытаться завершить системный процесс, например командой <command moreinfo="none">kill
	    1</command>, появится сообщение об ошибке доступа:
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ kill 1
bash: kill: (1) - Operation not permitted</screen>
	    </informalexample>	    
	    Отправление сигналов системным процессам может производить только
	    суперпользователь. 
	  </para>
	</listitem>	
	<listitem>
	  <para>
	    Альтернативным способом отправления сигналов процессам – по имени
	    процесса, а не по PID – является
	    команда <application moreinfo="none">killall</application>. Выполнив команду <command moreinfo="none">killall
	    bash</command>, мы завершим все командные оболочки, а тем самым и сеансы
	    пользователей.
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ killall bash</screen>
	    </informalexample>	    
	  </para>
	</listitem>	
	<listitem>
	  <para>
	    До этого мы отправляли только сигнал завершения процесса. Он может
	    перехватываться и игнорироваться программами. Неперехватываемым является
	    сигнал SIGKILL, который может быть отправлен, например, следующей командой:
	    <command moreinfo="none">killall -SIGKILL find</command>
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ killall -SIGKILL find</screen>
	    </informalexample>	    
	  </para>
	</listitem>	
      </orderedlist></sect2><sect2 id="shell-scenario-fgbg"><title>Сценарий: Выполнение задач в фоновом режиме</title><para>
	
	  В данном сценарии изучается работа с заданиями командной оболочки, запуск
	  заданий в фоновом режиме.
  	
      </para><para><emphasis>Начальные условия:</emphasis>
	  Командная строка после входа в систему.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	  <para>
	    Запустим длительную команду, например <command moreinfo="none">find / &gt; files.txt</command> и
	    приостановим её выполнение с помощью
	    нажатия <keycombo moreinfo="none"><keycap moreinfo="none">Ctrl</keycap> <keycap moreinfo="none">Z</keycap></keycombo>. При
	    этом процессу посылается сигнал SIGSTOP.
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ find / &gt; files.txt

[1]+  Stopped                 find / &gt; files.txt
user@desktop ~ $ </screen>
	    </informalexample>
	    Команда приостановлена и запомнена как задача 1 (номер в квадратных скобках).
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Текущий список запущенных задач командной оболочки можно посмотреть
	    командой <command moreinfo="none">jobs</command>. 
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ jobs
[1]+  Stopped                 find / &gt; files.txt
</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Возобновить исполнение задания можно командой <command moreinfo="none">fg 1</command>,
	    аргументом которой является номер задания. 
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ fg 1
find / &gt; files.txt
</screen>
	    </informalexample>	    
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Если еще раз приостановить процесс, можно запустить задачу в фоновом
	    режиме: <command moreinfo="none">bg 1</command>. 
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ fg 1
[1]+ find / &gt; files.txt &amp;
user@desktop ~ $</screen>
	    </informalexample>	    
	    Тогда можно будет продолжать работу в командной строке.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Команды можно сразу запускать в фоновом режиме. При этом необходимо добавить
	    символ <quote>&amp;</quote> (амперсанд) в конец строки команды: <command moreinfo="none">find
	    / -name "*.xml" &gt; xml-list &amp;</command>
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ find / -name "*.xml" &gt; xml-list &amp;
[1] 9413
user@desktop ~ $</screen>
	    </informalexample>	    
	    При этом командная оболочка выводит номер задания и PID созданного процесса.
	  </para>
	</listitem>
      </orderedlist></sect2><sect2 id="shell-scenario-daemons"><title>Сценарий: Запуск демонов</title><para>
	
	  В данном сценарии рассматриваются демоны как процессы, не связанные ни с одним
	  терминалом.
  	
      </para><para><emphasis>Начальные условия:</emphasis>
	 Командная строка после входа в систему.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	  <para>
	    Если запустить команду в фоновом режиме и выйти из командной оболочки:
	    например, <command moreinfo="none">find / -name "*.html" -exec grep -Hn "linux loader" \{}
	      \; &amp;</command> и <command moreinfo="none">exit</command>, то запущенная команда завершится
	    по сигналу SIGHUP.
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ find / -name "*.html" -exec grep -Hn "linux loader"
	    \{} \; &amp;
[1] 9555
user@desktop ~ $ exit</screen>
	    </informalexample>	    	    
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Для того, чтобы программы не получали сигнал SIGHUP, используется специальная
	    команда <application moreinfo="none">nohup</application>: <command moreinfo="none">nohup find / -name "*.txt" -exec grep -Hn "linux loader" \{} \; &amp;</command>
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ nohup find / -name "*.html" -exec grep -Hn "linux loader" \{} &gt;&gt; result\; &amp;
[1] 9783
user@desktop ~ $ exit</screen>
	    </informalexample>
	    Эта программа завершится корректно после окончания поиска.
	  </para>
	</listitem>
      </orderedlist></sect2><sect2 id="shell-scenario-renice"><title>Сценарий: Изменение приоритетов выполняющихся программ</title><para>
	
	  В данном сценарии изучается механизм приоритетов UNIX и команды для изменения
	  приоритетов запускаемых процессов.
  	
      </para><para><emphasis>Начальные условия:</emphasis>
	Командная строка после входа в систему.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	  <para>
	    Каждый процесс в системе имеет свой уровень приоритета (в UNIX он
	    называется <quote>nice</quote>), который можно увидеть с помощью
	    команды <command moreinfo="none">ps -l</command> – в столбце <quote>NI</quote>.
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1000 17223 17222  0  75   0 -   994 wait   pts/1    00:00:00 bash
0 R  1000 17485 17223  0  75   0 -   612 -      pts/1    00:00:00 ps</screen>
	    </informalexample>	
	    По умолчанию, приоритет процессов простого пользователя равен нулю.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Для запуска процесса с заданным приоритетом воспользуемся
	    командой <application moreinfo="none">nice</application>. Напрмер, запустим создание архива с
	    пониженным приоритетом: <command moreinfo="none">nice -n 10 tar -cjf libraries.tar.bz2
	    /usr/lib/</command>. 
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ nice -n 10 tar -cjf libraries.tar.bz2 /usr/lib/</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Чтобы изменить приоритет уже запущенной программы используется
	    команда <application moreinfo="none">renice</application>. Например, для понижения приоритета
	    заранее запущенного процесса архивации <command moreinfo="none">tar -cjf libraries.tar.bz2
	    /usr/lib &amp;</command> воспользуемся командой <command moreinfo="none">renice +10 -p
	    3442</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ tar -cjf libraries.tar.bz2 /usr/lib &amp;
[1] 3442
user@desktop ~ $ renice +10 -p 3442</screen>
	    </informalexample>	    
	    Простые пользователи не могут повышать приоритет процессов, только понижать.
	  </para>
	</listitem>
      </orderedlist></sect2><sect2><title>Задания для самоподготовки</title><orderedlist><listitem>
	Сравните время создания корневой директории с текущим временем системы.
      </listitem><listitem>
	Получите список всех типов файловых систем, примонтированных в настоящий
	момент. Какой тип имеет корневая файловая система?
      </listitem><listitem>
	Найдите три процесса, использующих самый большой объём памяти. Какой процент
	памят они потребляют от общего объёма?
      </listitem><listitem>
	Получите иерархию родительских процессов для текущей командной оболочки.
      </listitem><listitem>
	Найдите, в каком файле в директории /proc хранится информация
	о системной памяти.
      </listitem><listitem>
	С помощью сигнала остановки процесса и команды bg
	запустите три параллелльных процесса архивации
	директории /etc, /home
	и /tmp.
      </listitem></orderedlist></sect2></sect1><sect1 id="shell-syscmdexamples-scenarios"><title>Сценарии практического занятия на тему: Сбор сведений о системе и управление процессами</title><para><xref linkend="shell-scenario-sysinfo"/><orderedlist><listitem>uname -a</listitem><listitem>ls /proc</listitem><listitem>who</listitem><listitem>mount</listitem><listitem>df -h</listitem><listitem>ps aux</listitem><listitem>ps aux | grep -v user</listitem><listitem>pstree</listitem><listitem>top</listitem></orderedlist></para><para><xref linkend="shell-scenario-signals"/><orderedlist><listitem>yes</listitem><listitem>find / &gt; files.txt</listitem><listitem>ps aux | grep find</listitem><listitem>kill
	    8178</listitem><listitem>kill
	    1</listitem><listitem>killall
	    bash</listitem><listitem>killall -SIGKILL find</listitem></orderedlist></para><para><xref linkend="shell-scenario-fgbg"/><orderedlist><listitem>find / &gt; files.txt</listitem><listitem>jobs</listitem><listitem>fg 1</listitem><listitem>bg 1</listitem><listitem>find
	    / -name "*.xml" &gt; xml-list &amp;</listitem></orderedlist></para><para><xref linkend="shell-scenario-daemons"/><orderedlist><listitem>find / -name "*.html" -exec grep -Hn "linux loader" \{}
	      \; &amp;</listitem><listitem>exit</listitem><listitem>nohup find / -name "*.txt" -exec grep -Hn "linux loader" \{} \; &amp;</listitem></orderedlist></para><para><xref linkend="shell-scenario-renice"/><orderedlist><listitem>ps -l</listitem><listitem>nice -n 10 tar -cjf libraries.tar.bz2
	    /usr/lib/</listitem><listitem>tar -cjf libraries.tar.bz2
	    /usr/lib &amp;</listitem><listitem>renice +10 -p
	    3442</listitem></orderedlist></para></sect1> 
</chapter>

  
<chapter id="chapter-security">
  <title>Безопасность операционной системы UNIX</title>
  <para>
    Поскольку ОС UNIX с самого своего рождения задумывалась как многопользовательская
    операционная система, в ней всегда была актуальна проблема разделения доступа
    различных пользователей к файлам файловой системы. Схема безопасности,
    примененная в ОС UNIX, проста и удобна и одновременно достаточно мощна, что
    стала фактическим стандартом современных многопользовательских операционных систем.
  </para>
  <!-- занятие №6 (лекция) -->
  <sect1 id="security-lect">
    <title>Введение в безопасность UNIX</title>
    <sect2 id="security-lect-basis">
      <title>Основы информационной безопасности</title>
      <para><link linkend="small-pres-4-01">Презентация 4-01: информационная безопасность</link></para>
      <para>
	<emphasis id="def-inf-security" xreflabel="информационная  безопасность">Информационная безопасность</emphasis> – меры по защите
	информации от неавторизованного доступа, разрушения, модификации, раскрытия и
	задержек в доступе. Основой информационной безопасности любой организации является
	<emphasis>политика безопасности</emphasis>.
      </para>
      <sect3 id="security-lect-basis-secpol">
	<title>Политика безопасности</title>
	<para>
	  <emphasis id="def-security-policy" xreflabel="политика безопасности">Политика
	    безопасности</emphasis> – это набор законов, правил и норм
	    поведения, определяющих, как организация обрабатывает, защищает и
	    распространяет информацию. Это активный компонент защиты, который включает в
	    себя анализ возможных угроз и выбор мер противойдействия.
	</para>
	<phrase id="quest-4-1" xreflabel="Чем отличаются номинальный и действительный субект? Как&#10;&#9;они соотносятся с объектом безопасности? Что представляют собой субъект и объект&#10;&#9;безопасности в UNIX?"/>	
	<para>
	  Важным элементом политики безопасности является управление доступом: ограничение
	  или исключение несканкционированного доступа к информации и программным
	  средствам. При этом используются два основных
	  понятия: <emphasis>объект</emphasis> и <emphasis>субъект</emphasis>
	  системы. <emphasis id="def-sec-object" xreflabel="объект">Объектом</emphasis>
	  системы мы будем называть любой её идентифицируемый ресурс (например, файл или
	  устройство). <emphasis id="def-access" xreflabel="доступ">Доступом</emphasis> к
	  объекту системы – некоторую заданную в ней операцию над этим объектом
	  (скажем, чтение или запись). <emphasis id="def-real-subject" xreflabel="действительный субъект">Действительным субъектом</emphasis> системы
	  назовем любую сущность, способную выполнять действия над объектами (имеющую к
	  ним доступ). Действительному субъекту системы соответствует некоторая
	  абстракция, на основании которой принимается решение о предоставлении доступа к
	  объекту или об отказе в доступе. Такая абстракция
	  называется <emphasis id="def-nominal-subject" xreflabel="номинальный    субъект">номинальным субъектом</emphasis>. Например, студент МГТУ –
	  действительный субъект, его пропуск в МГТУ – номинальный. Другим
	  примером может служить злоумышленник, прокравшийся в секретную лабораторию с
	  украденной картой доступа – он является действительным субъектом, а
	  карта – номинальным (см. <xref linkend="img-object-subject"/>).
	</para>
	<para>
	  <figure id="img-object-subject" float="0">
	    <title>Объект и субъект безопасности</title>
	    <graphic fileref="images/object-subject.png"/>
	  </figure>	
	</para>
	<para><link linkend="small-pres-4-02">Презентация 4-02: политика безопасности</link></para>
	<phrase id="quest-4-2" xreflabel="Что такое политика безопасности? Какие требования&#10;&#9;выдвигаются по отношению к ней?"/>
	<para>
	  <emphasis>Политика безопасности</emphasis> должна
	  быть <emphasis>полной</emphasis>, <emphasis>непротиворечивой</emphasis> и
	  рассматривать <emphasis>все возможности</emphasis> доступа субъектов системы к
	  её объектам. Только соблюдение всех трех принципов гарантирует, что нарушить
	  установленные правила (например, получить несанкционированный доступ к объекту)
	  системными средствами невозможно. Если же предполагаемый злоумышленник
	  воспользовался каким-нибудь внесистемным средством и смог получить статус
	  номинального субъекта, к которому он не имеет отношения (например, подглядел
	  чужой пароль и работает под чужим именем), никаких гарантий быть не может.
	</para>
	<para>
	  Полнота политики безопасности означает, что в ней должны быть отражены все
	  существующие ограничения доступа. Непротиворечивость заключается в том, что
	  решение об отказе или предоставлении доступа конкретного субъекта к конкретному
	  объекту не должно зависеть от того, какими путями система к нему
	  приходит. Третье требование, называемое также <emphasis>отсутствием
	  недокументированных возможностей</emphasis>, должно гарантировать нам, что
	  доступ не может быть осуществлен иначе как описанным в политике безопасности
	  способом.
	</para>
	<para>
	  Политика безопасности включает в себя технические, организационные и правовые
	  аспекты, в рамках этих лекций рассматривается только технический аспект.
	</para>
      </sect3>
      <sect3 id="security-lect-basis-access">
	<title>Управление доступом</title>
	<para><link linkend="small-pres-4-03">Презентация 4-03: управление доступом</link></para>
	<phrase id="quest-4-3" xreflabel="Какие существуют наиболее распространённые схемы доступа?&#10;&#9;В чём заключаются основные отличия между ними? Какая схема доступа используется в&#10;&#9;UNIX?"/>
	<para>
	  Существует несколько схем управления доступом,
	  называемых <emphasis id="def-access-model" xreflabel="модель доступа">моделями
	  доступа</emphasis>. Рассмотрим самые известные из них:
	  <variablelist>
	    <varlistentry>
	      <term><emphasis id="def-am-marker" xreflabel="мандатная модель">Мандатная
	      модель доступа</emphasis></term>
	      <listitem>
		<para>
		  Объектам и субъектам системы ставится в соответствие <emphasis>метка
		    безопасности</emphasis> или <emphasis>мандат</emphasis> (например,
		    гриф секретности). При этом метка безопасности субъекта описывает его
		    благонадёжность, а метка безопасность объекта – степень
		    закрытости информации. Доступ к объекту разрешён только субъектам с
		    соответствующей или более сильной меткой.
		</para>
		<para>
		  Недостатком такой схемы можно считать слишком грубое деление прав,
		  необходимость введения категорий доступа и т.п.. Также для данной модели
		  доступа очень важно разработать механизм понижения секретности теряющих
		  важность документов.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis id="def-am-acl" xreflabel="модель списков доступа">Списки доступа
	      (Accecc Control Lists, ACL)</emphasis></term>
	      <listitem>
		<para>
		  Все субъекты и объекты системы объединяются в таблицу, в строках которой
		  находятся субъекты (активные сущности), а в столбцах –
		  объекты (пассивные сущности), элементы же такой таблицы содержат
		  перечисление прав, которыми субъект обладает в отношении данного
		  объекта. Такая схема называется <emphasis>субъект-объектная
		  модель</emphasis>.
		</para>
		<para>
		  Недостатками можно считать огромный размер таблицы и сложность
		  администрирования в случае большого числа объектов и субъектов в системе.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis id="def-am-uac" xreflabel="произвольное управление        доступом">Произвольное управление доступом</emphasis></term>
	      <listitem>
		<para>
		  Каждому объекту сопоставляется один субъект – владелец
		  объекта. Владелец может по своему усмотрению давать другим субъектам или
		  отнимать у них права на доступ к объекту. Если объект имеет несколько
		  хозяев, они могут быть объединены общим субъектом – группой.
		  Такая схема позволяет значительно сократить размер таблицы прав
		  субъектов по отношению к объектам.  Эта схема также
		  называется <emphasis>субъект-субъектная модель</emphasis>.
		</para>
		<para>
		  Недостатком этой схемы является значительное облегчение управления
		  доступом, что не позволяет простроить сложные отношения между субъектами
		  и объектами.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
      </sect3>
      <sect3 id="security-lect-basis-auth">
	<title>Аутентификация и авторизация</title>
	<para><link linkend="small-pres-4-04">Презентация 4-04: аутентификация и авторизация</link></para>
	<para>
	  <emphasis id="def-authorization" xreflabel="авторизация">Авторизация</emphasis> – это процесс определения
	  того, имеет или не имеет некоторый субъект доступ к некоторому
	  объекту. Авторизация может быть:
	  <variablelist>
	    <varlistentry>
	      <term>статической</term>
	      <listitem>
		<para>
		  вопрос о доступе к объекту решается один раз, когда права задаются или
		  изменяются, при этом пользователю ставится в соответствие некоторый
		  номинальный субъект системы;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>динамической</term>
	      <listitem>
		<para>
		  принятие решения о доступе производится при каждом обращении к объекту,
		  часто это носит характер ограничения возможностей пользователя по объёму
		  памяти и дискового пространства, времени работы и т.п..
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
	<para>
	  Процессу <emphasis>авторизации</emphasis> всегда должен предшествовать процесс
	  <emphasis>аутентификации</emphasis>. <emphasis id="def-authentication" xreflabel="аутентификация">Аутентификация</emphasis> – это механизм
	  сопоставления работающего пользователя системы некоторому номинальному субъекту.
	  Как правило, при этом пользователю необходимо ввести пароль или предоставить
	  секретный ключ.
	</para>
      </sect3>
    </sect2>
    <sect2 id="security-lect-unix">
      <title>Концепции безопасности UNIX</title>
      <para><link linkend="small-pres-4-05">Презентация 4-05: концепции безопасности UNIX</link></para>
      <para>
	В операционной системе UNIX используется достаточно постая модель доступа,
	основанная на <emphasis>субъект-субъектной модели</emphasis>. В современных
	версиях UNIX помимо общей схемы можно использовать <emphasis>списки
	  доступа</emphasis>. При этом реализуется статическая авторизация множественного
	доступа к объекту.
	</para>
      <sect3 id="security-lect-unix-users">
	<title>Пользователи и группы</title>
	<para>
	  В UNIX роль <emphasis>номинального</emphasis> субъекта безопасности
	  играет <emphasis id="def-user" xreflabel="пользователь">пользователь</emphasis>. Каждому пользователю
	  выдается (обычно – одно) входное имя (login). Каждому входному имени
	  соответствует единственное число, идентификатор пользователя (User
	  IDentifier, <acronym>UID</acronym>). Это число и есть ярлык субъекта, которым
	  система пользуется для определения прав доступа.
	</para>
	<para>
	  Каждый пользователь входит в одну или более групп. <emphasis id="def-group" xreflabel="группа">Группа</emphasis> – это образование, которое имеет
	  собственный идентификатор группы (Group IDentifier, <acronym>GID</acronym>),
	  объединяет нескольких пользователей системы, а стало быть, соответствует понятию
	  множественный субъект. Значит, GID – это ярлык множественного
	  субъекта, каковых у действительного субъекта может быть более одного. Таким
	  образом, одному UID соответствует список GID.
	</para>	  
	<para>
	  Роль <emphasis>действительного</emphasis> (работающего с объектами) субъекта
	  играет <emphasis>процесс</emphasis>. Каждый процесс снабжен единственным UID:
	  это идентификатор запустившего процесс пользователя. Любой процесс, порожденный
	  некоторым процессом, наследует его UID. Таким образом, все процессы, запускаемые
	  по желанию пользователя, будут иметь его идентификатор. UID учитываются,
	  например, когда один процесс посылает другому сигнал. В общем случае разрешается
	  посылать сигналы <quote>своим</quote> процессам (тем, что имеют такой же
	  UID).
	</para>
      </sect3>
      <sect3 id="security-lect-unix-rights">
	<title>Права доступа</title>
	<phrase id="quest-4-4" xreflabel="Какие существуют права доступа в UNIX? Какие из них&#10;&#9;являются специфичными для простах файлов, а какие для директорий?"/>
	<para>
	  Роль <emphasis>объекта</emphasis> в UNIX играют многие реальные объекты, в
	  частности представленные в файловой системе: файлы, каталоги, устройства, каналы
	  и т. п.. Каждый файл снабжён UID – идентификатором
	  пользователя-владельца. Вдобавок у файла есть единственный GID, определяющий
	  группу, которой он принадлежит.
	</para>
	<para><link linkend="small-pres-4-06">Презентация 4-06: права доступа</link></para>
	<para>
	  На уровне файловой системы в UNIX определяется
	  <emphasis id="def-unix-rights" xreflabel="права доступа в UNIX"> три вида
	  доступа</emphasis>: чтение (read,
	  <emphasis>r</emphasis>), запись (write, <emphasis>w</emphasis>) и использование
	  (execution, <emphasis>x</emphasis>). Право на чтение из файла дает доступ к
	  содержащейся в нем информации, а право записи – возможность ее
	  изменять. При каждом файле имеется список того, что с ним может делать владелец
	  (если совпадает UID процесса и файла), член группы владельцев (если совпадает
	  GID) и кто угодно (если ничего не совпадает)
	  (см. <xref linkend="img-unix-rights"/>). Такой список для каждого объекта
	  системы занимает всего несколько байт.
	</para>
	<para>
	  <figure id="img-unix-rights" float="0">
	    <title>Базовые права доступа в UNIX</title>
	    <graphic fileref="images/unix_rights.png"/>
	  </figure>	
	</para>
	<para>
	  Флаг <emphasis>использования</emphasis> трактуется по-разному в зависимости от
	  типа файла. В случает простого файла он задаёт
	  возможность <emphasis>исполнения</emphasis> файла, т.е. запуска программы,
	  содержащейся в этом файле. Для директории – это возможность доступа к
	  файлам в этой директории (точнее говоря, к атрибутам этих файлов –
	  имени, правам доступа и т.п..).
	</para>
	<para>
	  Рассмотрим последовательность проверки прав на примере
	  (см. <xref linkend="img-unix-checking-rights"/>). Пусть файл имеет следующие
	  атрибуты:
	  <informalexample>
	    <screen format="linespecific">file.txt   alice:users   rw- r-- ---</screen>
	  </informalexample>
	  Т.е. файл принадлежит пользователю <quote>alice</quote>,
	  группе <quote>users</quote> и имеет права на чтение и запись для владельца и
	  только чтение для группы.
	</para>
	<para><link linkend="small-pres-4-07">Презентация 4-07: последовательность проверки</link></para>
	<para>
	  Пусть файл пытается прочитать пользователь <quote>bob</quote>. Он не является
	  владельцем, однако он является членом группы <quote>users</quote>. Значит, он
	  имеет права на чтение этого файла.
	</para>
	<para>
	  <figure id="img-unix-checking-rights" float="0">
	    <title>Последовательнось проверки прав доступа в UNIX</title>
	    <graphic fileref="images/checking_rights.png"/>
	  </figure>	
	</para>
	<sect4 id="security-lect-unix-dirs">
	  <title>Разделяемые каталоги</title>
	  <para>
	    Права записи в директорию трактуются как возможность создания и удаления файлов,
	    а также измеение атрибутов файлов (например, переименование). При этом субъекту
	    не обязательно иметь права на запись в эти удаляемые файлы.
	  </para>
	  <para>
	    Таким образом, из своего каталога пользователь может удалить любой файл. А если
	    запись в каталог разрешена всем, то любой пользователь сможет удалить в нём
	    любой файл. Для избежания этой проблемы был добавлен ещё один бит в права
	    доступа каталога: <emphasis id="def-sticky-bit" xreflabel="sticky-бит">бит
	      навязчивости</emphasis> (sticky, <emphasis>t</emphasis>-бит). При его
	    установке пользователь, имеющий доступ на запись в этот каталог, может изменять
	    только <emphasis>собственные</emphasis> файлы.
	  </para>
	</sect4>
	<sect4 id="security-lect-unix-suid">
	  <title>Подмена идентификатора субъекта</title>
	  <para><link linkend="small-pres-4-08">Презентация 4-08: подмена идентификатора субъекта</link></para>
	  <phrase id="quest-4-5" xreflabel="Что такое подмена идентификатора субъекта? Как такое&#10;&#9;  право устанавливается и где применяется?"/>
	  <para>
	    В UNIX существует механизм, позволяющий пользователям запускать процессы от
	    имени других пользователей. Это может быть полезным, если одному
	    пользователю необходимо <emphasis>на время</emphasis> предоставлять права
	    другого (например, суперпользователя).
	  </para>
	  <para>
	    Для разрешение подмены идентификатора пользователя
	    применяется <emphasis id="def-suid-bit" xreflabel="suid-бит">бит подмены
	    идентификатора пользователя</emphasis> (set user id,
	    suid-бит, <emphasis>s</emphasis>). Этот бит применяется совместно с битом
	    исполнения (<emphasis>x</emphasis>) для обычных файлов. При установке этого
	    бита на исполняемый файл процесс запускается от имени владельца, а не от имени
	    запускаеющего пользователя (см. <xref linkend="img-suid"/>). 
	  </para>
	<para>
	  <figure id="img-suid" float="0">
	    <title>Подмена идентификатора пользователя</title>
	    <graphic fileref="images/suid.png"/>
	  </figure>
	</para>	  
	<para>
	  Подмена идентификатора пользователя является потенциальной угрозой безопасности
	  сиситемы и должена использоваться осторожно.
	</para>
	</sect4>
	<sect4 id="security-lect-unix-fails">
	  <title>Недостатки базовой модели доступа и её расширения</title>
	  <para>
	    Ограниченность системы прав UNIX приводит к тому, что, к
	    примеру, <emphasis>невозможно</emphasis> создать такое положение вещей, когда
	    одна группа пользователей могла бы только читать из файла, другая –
	    только запускать его, а всем остальным файл вообще не был бы доступен. Другое
	    дело, что такое положение вещей встречается нечасто.
	  </para>
	  <para>
	    Со временем в различных версиях UNIX стали появляться расширения прав доступа,
	    позволяющие устанавливать права на отдельные объекты системы. Поначалу это
	    были так называемые флаги – дополнительные атрибуты файла, не
	    позволяющие, например, переименовывать его или удалять из него информацию при
	    записи (можно только дописывать). Флаги не устраняют главного недостатка, зато
	    их легко организовать без изменения файловой системы: каждый флаг занимает
	    ровно один бит.
	  </para>
	  <para>
	    Многие современные файловые системы UNIX поддерживают также <emphasis>списки
	    доступа</emphasis> (<acronym>ACL</acronym>), с помощью которых можно для
	    каждого объекта задавать права всех субъектов на доступ к нему.
	  </para>
	  <para>
	    На практике флаги или управление доступом использовать приходится нечасто. В
	    большинстве случаев такая необходимость возникает в виде
	    исключения – например, для временного уменьшения прав или для
	    временного предоставления доступа (легко сделать с
	    помощью <acronym>ACL</acronym>), а также при работе с очень важными файлами.
	  </para>
	</sect4>
      </sect3>
      <sect3 id="security-lect-unix-root">
	<title>Суперпользователь</title>
	<para><link linkend="small-pres-4-09">Презентация 4-09: суперпользователь</link></para>
	<para>
	  Пользователь root (он
	  же <emphasis id="def-root" xreflabel="суперпользователь">суперпользователь</emphasis>) имеет нулевые UID и
	  GID и играет роль <emphasis>доверенного субъекта UNIX</emphasis>. Это значит,
	  что он не подчиняется законам, которые управляют правами доступа, и может по
	  своему усмотрению эти права изменять. Большинство настроек системы доступны для
	  записи только суперпользователю.
	</para>
	<para>
	  Как было сказано ранее (см. раздел <xref linkend="intro-unix-concepts-arch"/>),
	  в UNIX существует уровень доступа ядра и уровень доступа
	  системы. Суперпользователь работает на уровне доступа ядра, так что является по
	  сути продолжением самой системы.
	</para>
	<para>
	  Многие команды должны исполняться только от имени суперпользователя, так как в
	  них производится взяимодействие с частями ядра, отвечающими за взаимодействие с
	  аппаратурой, права доступа и т.п.. Если же такие команды разрешается запускать
	  простым пользователям, применяется рассмотренный выше механизм подмены
	  идентификатора пользователя.
	</para>
	<para>
	  Системное администрирование в UNIX производится от имени
	  пользователя <emphasis>root</emphasis>. При работе от этого имени следует быть
	  очень осторожным: выполнение неверной команды может привести к краху системы и
	  уничтожению информации. Поэтому даже администраторы никогда не работают в сеансе
	  суперпользователя всё время, а переходят в режим суперпользователя только
	  тогда, когда это действительно необходимо (например, с помощью
	  команды <command moreinfo="none">su</command>).
	</para>
      </sect3>
      <sect3 id="security-lect-unix-auth">
	<title>Аутентификация пользователей</title>
	<para><link linkend="small-pres-4-10">Презентация 4-10: вход пользователя в систему</link></para>
	<phrase id="quest-4-6" xreflabel="Из чего состоит процесс аутентификации пользователя в&#10;&#9;UNIX?"/>
	<para>
	  В UNIX <emphasis id="def-session" xreflabel="сеанс работы">сеанс работы</emphasis> пользователя
	  начинается с его аутентификации и заканчивается его выходом из системы. При
	  входе в систему выполняется следующая последовательность действий
	  (см. <xref linkend="img-login"/>):
	  <orderedlist inheritnum="ignore" continuation="restarts">
	    <listitem>
	      процесс <command moreinfo="none">getty</command> ожидает реакции пользователя на одной из
	      терминальных линий, в случае активности пользователя выводит приглашение;
	    </listitem>
	    <listitem>
	      после ввода имени пользователя запускается
	      программа <command moreinfo="none">login</command>, которая проверяет подлинность
	      пользователя. Стандартным механизмом является
	      проверка <emphasis>пароля</emphasis>, заданного для данного пользователя;
	    </listitem>
	    <listitem>
	      убедившись, что пароль введён правильно, <emphasis>login</emphasis>
	      запускает командный интерпретатор с установленными UID и GID данного
	      пользователя. Таким образом, права доступа любой программы (действительного
	      субъекта), запущенной пользователем в этом сеансе работы, будут определяться
	      правами номинального субъекта UID+GID.
	    </listitem>
	  </orderedlist>
	</para>
	<para>
	  <figure id="img-login" float="0">
	    <title>Процесс входа в систему</title>
	    <graphic fileref="images/login.png"/>
	  </figure>
	</para>	  
	<para>
	  При работе по сети роль <command moreinfo="none">getty</command> исполняет сетевой демон,
	  например <command moreinfo="none">ssh</command>.
	</para>
	<para>
	  В некоторых современных UNIX-системах существуют расширения систем авторизации и
	  аутентификации. Например, в Linux-системах этот механизм
	  называется <emphasis>подключаемые модули аутентификации</emphasis> (Pluggable
	  Authentication Modules, <acronym>PAM</acronym>). Эти средства выходят за рамки
	  данных лекций.
	</para>
      </sect3>
    </sect2>
    <sect2 id="security-lect-config">
      <title>Настройка системы безопасности</title>
      <sect3 id="security-lect-config-passwd">
	<title>База данных пользователей системы</title>
	<para><link linkend="small-pres-4-11">Презентация 4-11: база данных пользователей</link></para>
	<phrase id="quest-4-7" xreflabel="Каким образом хранится информация обо всех пользователях&#10;&#9;системы?"/>
	<para>
	  Все <emphasis id="def-usersdb" xreflabel="база данных пользователей">данные о
	  пользователях</emphasis> UNIX хранит в файле <filename moreinfo="none">/etc/passwd</filename>
	  в текстовом виде. Каждому пользователю соответствует одна строка, поля которой
	  разделяются двоеточиями:
	  <synopsis format="linespecific">входное имя:x:UID:GID:полное имя:домашний каталог:стартовый shell</synopsis>
	</para>
	<para>
	  <example>
	    <title>Пример файла <filename moreinfo="none">/etc/passwd</filename></title>
	    <programlisting format="linespecific">
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/bin/false
daemon:x:2:2:daemon:/sbin:/bin/false
adm:x:3:4:adm:/var/adm:/bin/false
...</programlisting>
	  </example>
	</para>
	<para>
	  Каждый пользователь явно связан с одной из групп – это
	  <emphasis id="def-main-group" xreflabel="основная группа">основная группа</emphasis> пользователя. Это
	  сделано для того, чтобы каждый пользователь состоял хотя бы в одной группе. Все
	  новые файлы, создаваемые этим пользователем, в качестве группы владельцев будут
	  иметь его основную группу.
	</para>
	<para>
	  Из примера видно, что некоторые пользователи имеют <quote>неправильные</quote>
	  командные оболочки, работа в которых невозможна. Это сделано специально для
	  того, чтобы исключить возможность входа таких пользователей в систему.
	</para>
	<para>
	  Пароли на вход в систему пользователей в UNIX не хранятся в открытом виде,
	  хранятся только их хэши (набор байт, получаемый из пароля с помощью
	  односторонней функции). Даже если злоумышленник получит значение этого хэша, ему
	  придется <emphasis>подбирать</emphasis> пароль, применяя данную одностороннюю
	  функцию к различным словам и сравнивая со значением хэша. Часто хэши хранятся в
	  спациальном файле (например, <filename moreinfo="none">/etc/shadow</filename>), доступ к
	  которому разрешен только системе, так что перебор вообще не возможен.
	</para>
	<para>
	  Аналогичным образом информация о группах хранится в
	  файле <filename moreinfo="none">/etc/group</filename>. Каждой строке файла соответствует
	  информация о группе: её имя, числовой идентификатор и список пользователей,
	  входящих в эту группу.
	</para>
	<para>
	  Изменение информации о пользователях, также как и добавление новых
	  пользователей, может производиться простым редактированием этого файла, однако
	  более корректным способом является использование <emphasis>специальных
	  утилит</emphasis>, которые рассматриваются далее.
	</para>
      </sect3>
      <sect3 id="security-lect-config-users">
	<title>Изменение базы данных пользователей</title>
	<para>
	  Для добавления и удаления пользователей и групп существует набор команд:
	  <command moreinfo="none">useradd</command>, <command moreinfo="none">userdel</command>,
	  <command moreinfo="none">groupadd</command>, <command moreinfo="none">groupdel</command>.
	  Эти команды доступны только суперпользователю и имеют единственный обязательный
	  параметр: имя пользователя или группы.
	</para>
	<para>
	  С помощью команд <command moreinfo="none">usermod</command> и <command moreinfo="none">groupmod</command> можно
	  изменять информацию в базах данных пользователей и групп. Эти команды также
	  может выполнять только администратор системы.
	</para>
	<para>
	  Команда <command moreinfo="none">passwd</command> позволяет простым пользователям изменять свой
	  системный пароль, а суперпользователю – изменять пароль любого из
	  пользователей системы.
	</para>
      </sect3>
      <sect3 id="security-lect-config-rights">
	<title>Изменение прав доступа</title>
	<para>
	  Для изменения владельца файла или группы владельцев используются
	  команды <command moreinfo="none">chown</command> и <command moreinfo="none">chgrp</command>. Из соображений
	  безопасности спользовать эти команды может только суперпользователь.
	</para>
	<para>
	  Пользователь может изменять права доступа к своим файлам с помощью
	  команды <command moreinfo="none">chmod</command>. 
	</para>
      </sect3>
      <sect3 id="security-lect-config-session">
	<title>Ограничения сеанса пользователя</title>
	<para><link linkend="small-pres-4-12">Презентация 4-12: ограничения сеанса пользователя</link></para>
	<para>
	  В UNIX существует ряд динамических ограничений, накладываемых на процесс
	  аутентификации пользователя и запущенные им программы. Ограничения можно
	  разделить на следующие группы:
	  <variablelist>
	    <varlistentry>
	      <term>ограничения входа в систему</term>
	      <listitem>
		<para>
		  Вход пользователя в систему может быть ограничен видом терминала,
		  удалённым адресом (в случае сетевого входа в систему), временем работы.
		  Для задания этих ограничений
		  в некоторых UNIX-системах используется
		  файл  <filename moreinfo="none">/etc/login.access</filename>
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>ограничения запускаемых процессов</term>
	      <listitem>
		<para>
		  Процессы пользователей могут быть ограничены по одному из следующих
		  параметром: объём используемой памяти, число одновременно открытых
		  файлов, число запускаемых процессов и т.п.. Для задания этих ограничений
		  в некоторых UNIX-системах используется
		  файл <filename moreinfo="none">/etc/limits</filename>. 
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>ограничения использования диска</term>
	      <listitem>
		<para>
		  <emphasis id="def-quotes" xreflabel="дисковые квоты">Дисковые
		  квоты</emphasis> позволяют ограничить объём используемого пространства
		  жёсткого диска для каждого из пользователей системы. Для настройки
		  данного ограничения необходима утилита <command moreinfo="none">quote</command>, а
		  также поддержка в выбранной файловой системе.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>	  
	  Ограничения действуют на протяжении всего сеанса работы пользователя.
	</para>
      </sect3>
    </sect2>
    <sect2 id="security-lect-summary">
      <title>Резюме</title>
      <para><link linkend="small-pres-4-13">Презентация 4-13: резюме</link></para>
      <para>
	Основой информационной безопасности любого предприятия является политика
	безопасности, которая включает в себя технические, организационные и правовые
	аспекты.
      </para>
      <para>
	Основными элементами политики безопасности являются субъект, объект и отношения
	между ними. Выделяют ряд моделей доступа, среди которых маркерный доступ,
	списки пользователя (субъект-объектный доступ) и произвольное управление доступом
	(субъект-субъектный доступ). 
      </para>
      <para>
	В операционной системе UNIX субъектом является процесс пользователя, а объектом
	файл. Права группируются по владельцу объекта, группе владельцев и остальным и
	состоят из базовых прав: чтение, запись и исполнение, а также дополнительных прав
	(подмены субъекта и разделяемости каталога).
      </para>
      <para>
	Аутентификация пользователя при входе в систему состоит в проверке пароля,
	соответствующего имени пользователя.
      </para>
      <para>
	Информация о пользователях системы хранится в специальном
	файле <filename moreinfo="none">/etc/passwd</filename>. Существует набор системных команд по
	изменению базы данных пользователей и групп.
      </para>
      <para>
	В UNIX можно устанавливать динамические ограничения на сеанс пользователя.
      </para>
      <para><emphasis>Ключевые термины: </emphasis><xref linkend="def-inf-security"/>, <xref linkend="def-security-policy"/>, <xref linkend="def-sec-object"/>, <xref linkend="def-access"/>, <xref linkend="def-real-subject"/>, <xref linkend="def-nominal-subject"/>, <xref linkend="def-access-model"/>, <xref linkend="def-am-marker"/>, <xref linkend="def-am-acl"/>, <xref linkend="def-am-uac"/>, <xref linkend="def-authorization"/>, <xref linkend="def-authentication"/>, <xref linkend="def-user"/>, <xref linkend="def-group"/>, <xref linkend="def-unix-rights"/>, <xref linkend="def-sticky-bit"/>, <xref linkend="def-suid-bit"/>, <xref linkend="def-root"/>, <xref linkend="def-session"/>, <xref linkend="def-usersdb"/>, <xref linkend="def-main-group"/>, <xref linkend="def-quotes"/></para>
    </sect2>    
    <sect2 id="security-lect-additional">
      <title>Дополнительные материалы</title>
      <para>
	<orderedlist inheritnum="ignore" continuation="restarts">
	  <listitem>
	    Скотт Манн, Эленн Митчелл, Митчелл Крелл <emphasis>Безопасность
	    Linux</emphasis>. – М.: Вильямс, 2003. – 624 с.: ил.
	  </listitem>
	  <listitem>
	    Курячий Г.В. <emphasis>Операционная система UNIX</emphasis>. –
	    М.: Интуит.Ру, 2004. – 292 с.: ил.
	  </listitem>
	</orderedlist>
      </para>
    </sect2>    
    <sect2 id="security-lect-questions"><title>Вопросы</title><para><orderedlist><listitem><xref linkend="quest-4-1"/></listitem><listitem><xref linkend="quest-4-2"/></listitem><listitem><xref linkend="quest-4-3"/></listitem><listitem><xref linkend="quest-4-4"/></listitem><listitem><xref linkend="quest-4-5"/></listitem><listitem><xref linkend="quest-4-6"/></listitem><listitem><xref linkend="quest-4-7"/></listitem></orderedlist></para></sect2>
    <sect2 id="security-lect-presentaion"><title>Презентация</title><para><figure id="small-pres-4-01" float="0"><title>Презентация 4-01: информационная безопасность</title><graphic fileref="pres/small-lect4-01.png"/></figure></para><para><figure id="small-pres-4-02" float="0"><title>Презентация 4-02: политика безопасности</title><graphic fileref="pres/small-lect4-02.png"/></figure></para><para><figure id="small-pres-4-03" float="0"><title>Презентация 4-03: управление доступом</title><graphic fileref="pres/small-lect4-03.png"/></figure></para><para><figure id="small-pres-4-04" float="0"><title>Презентация 4-04: аутентификация и авторизация</title><graphic fileref="pres/small-lect4-04.png"/></figure></para><para><figure id="small-pres-4-05" float="0"><title>Презентация 4-05: концепции безопасности UNIX</title><graphic fileref="pres/small-lect4-05.png"/></figure></para><para><figure id="small-pres-4-06" float="0"><title>Презентация 4-06: права доступа</title><graphic fileref="pres/small-lect4-06.png"/></figure></para><para><figure id="small-pres-4-07" float="0"><title>Презентация 4-07: последовательность проверки</title><graphic fileref="pres/small-lect4-07.png"/></figure></para><para><figure id="small-pres-4-08" float="0"><title>Презентация 4-08: подмена идентификатора субъекта</title><graphic fileref="pres/small-lect4-08.png"/></figure></para><para><figure id="small-pres-4-09" float="0"><title>Презентация 4-09: суперпользователь</title><graphic fileref="pres/small-lect4-09.png"/></figure></para><para><figure id="small-pres-4-10" float="0"><title>Презентация 4-10: вход пользователя в систему</title><graphic fileref="pres/small-lect4-10.png"/></figure></para><para><figure id="small-pres-4-11" float="0"><title>Презентация 4-11: база данных пользователей</title><graphic fileref="pres/small-lect4-11.png"/></figure></para><para><figure id="small-pres-4-12" float="0"><title>Презентация 4-12: ограничения сеанса пользователя</title><graphic fileref="pres/small-lect4-12.png"/></figure></para><para><figure id="small-pres-4-13" float="0"><title>Презентация 4-13: резюме</title><graphic fileref="pres/small-lect4-13.png"/></figure></para></sect2>
  </sect1>
  <sect1 id="security-cmd">
    <title>Методические указания по командам управления безопасностью в UNIX</title>
    <sect2 id="security-cmd-rights">
      <title>Команды по управлению правами</title>
      <variablelist>
	<varlistentry>
	  <term><emphasis id="def-cmd-chmod" xreflabel="chmod">chmod</emphasis></term>
	  <listitem>
	   <para>
	    Команда используется для изменения прав доступа к файлам.
	   </para>
	   <para>
	    Команда <command moreinfo="none">chmod</command> имеет следующий синтаксис:
	    <synopsis format="linespecific">chmod [-fhv] [-R [-H | -L | -P]] права_доступа файл ...</synopsis>
	   </para>
	   <para>
	    Права доступа к файлу могут изменить только владелец файла и суперпользователь.
	    Параметр <parameter class="command" moreinfo="none">права_доступа</parameter> задается в числовой форме, либо в символьной.
	   </para>
	   <para>
	    Права доступа в числовой форме задаются в виде восьмеричного числа  – битовой маски, являющегося суммой
	    одного или нескольких следующих значений:
	    <simplelist type="horiz" columns="2">
	     <member><emphasis>4000</emphasis></member>
	     <member> – установка бита <emphasis>SUID</emphasis></member>
	     <member><emphasis>2000</emphasis></member>
	     <member> – установка бита <emphasis>SUID</emphasis></member>
	     <member><emphasis>1000</emphasis></member>
	     <member> – установка <emphasis>sticky</emphasis>-бита</member>
	     <member><emphasis>0400</emphasis></member>
	     <member> – право на чтение для владельца</member>
	     <member><emphasis>0200</emphasis></member>
	     <member> – право на запись для владельца</member>
	     <member><emphasis>0100</emphasis></member>
	     <member> – право на выполнение для владельца</member>
	     <member><emphasis>0040</emphasis></member>
	     <member> – право на чтение для группы владельца</member>
	     <member><emphasis>0020</emphasis></member>
	     <member> – право на запись для группы владельца</member>
	     <member><emphasis>0010</emphasis></member>
	     <member> – право на выполнение для группы владельца</member>
	     <member><emphasis>0004</emphasis></member>
	     <member> – право на чтение для остальных пользователей</member>
	     <member><emphasis>0002</emphasis></member>
	     <member> – право на запись для остальных пользователей</member>
	     <member><emphasis>0001</emphasis></member>
	     <member> – право на выполнение для остальных пользователей</member>
	    </simplelist>
	   </para>
	   <para>
	    Права доступа в символьном виде задаются с помощью следующей грамматики:
	    <simplelist type="horiz" columns="2">
	     <member><emphasis>права_доступа</emphasis></member>
	     <member>::=<emphasis>выражение</emphasis> [, <emphasis>выражение</emphasis> ...]</member>
	     <member><emphasis>выражение</emphasis></member>
	     <member>::=[<emphasis>субъект</emphasis> ...] [<emphasis>действие</emphasis> ...] <emphasis>действие</emphasis></member>
	     <member><emphasis>действие</emphasis></member>
	     <member>::=<emphasis>операция</emphasis> [<emphasis>права</emphasis> ...]</member>
	     <member><emphasis>субъект</emphasis></member>
	     <member>::=a | u | g | o</member>
	     <member><emphasis>операция</emphasis></member>
	     <member>::=+ | - | =</member>
	     <member><emphasis>права</emphasis></member>
	     <member>::=r | s | t | w | x | X | u | g | o</member>
	    </simplelist>
	   </para>
	   <para>
	    Пример использования. Для того, чтобы для файла <filename moreinfo="none">test.txt</filename>
	    сбросить все права для группы владельца и остальных пользователей, а для
	    владельца установить права на чтение и запись, можно использовать следующие
	    команды (они эквивалентны):
	    <command moreinfo="none">chmod u=rw,go= test.txt</command>, 
	    <command moreinfo="none">chmod a=,u=rw test.txt</command>, 
	    <command moreinfo="none">chmod 600 test.txt</command>.
	    Результат:
	    <informalexample>
	     <screen format="linespecific">user@desktop$ ls -l test.txt
-rw-r--r--  1 pp  ppgroup  0  7 дек 00:34 test.txt
user@desktop$ chmod a=,u=rw test.txt
user@desktop$ ls -l test.txt
-rw-------  1 pp  ppgroup  0  7 дек 00:34 test.txt</screen>
	    </informalexample>
	    Для добавления группе владельца права на запись и отмена для остальных
	    пользователей права на чтение можно использовать следующую
	    команду: <command moreinfo="none">chmod g+w,o-r test.txt</command>.  Результат:
	    <informalexample>
		    <screen format="linespecific">user@desktop$ ls -l test.txt
-rw-r--r--  1 pp  ppgroup  0  7 дек 00:34 test.txt
user@desktop$ chmod g+w,o-r test.txt
user@desktop$ ls -l test.txt
-rw-rw----  1 pp  ppgroup  0  7 дек 00:34 test.txt</screen>
	    </informalexample>
	   </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><emphasis id="def-cmd-chown" xreflabel="chown">chown</emphasis></term>
	  <listitem>
	   <para>
	    Команда используется для смены владельца/группы файлов.
	   </para>
	   <para>
	    Команда имеет следующий синтаксис:
	    <synopsis format="linespecific">chown [-fhv] [-R [-H | -L | -P]] владелец[:группа] файл ...</synopsis>
	    <synopsis format="linespecific">chown [-fhv] [-R [-H | -L | -P]] :группа файл ...</synopsis>
	   </para>
	   <para>
	    Владельца файла может изменить только суперпользователь. Группу может изменить
	    владелец и суперпользователь.  В качестве имени владельца/группы берется
	    первый аргумент, не являющийся опцией. Если задано только имя пользователя
	    (или числовой идентификатор пользователя), то данный пользователь становится
	    владельцем каждого из указанных файлов, а группа этих файлов не
	    изменяется. Если за именем пользователя через двоеточие следует имя группы
	    (или числовой идентификатор группы), без пробелов между ними, то изменяется
	    также и группа файла.
	   </para>
	   <para>
	    Для изменения группы-владельца
	    файла <filename moreinfo="none">test.txt</filename>на <emphasis>guest</emphasis> необходимо
	    ввести следующую команду: <command moreinfo="none">chown :guest test.txt</command>. Результат:
	    <informalexample>
	     <screen format="linespecific">user@desktop$ ls -l test.txt
-rw-------  1 pp  ppgroup  0  7 дек 00:34 test.txt
user@desktop$ chown :wheel test.txt
user@desktop$ ls -l test.txt
-rw-------  1 pp  wheel  0  7 дек 00:34 test.txt</screen>
	    </informalexample>
	   </para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
    <sect2 id="security-cmd-users">
      <title>Команды по управлению пользователями</title>
      <variablelist>
	<varlistentry>
	  <term><emphasis id="def-cmd-su" xreflabel="su">su</emphasis></term>
	    <listitem>
	     <para>
	      Команда используется для временной подмены идентификатора пользователя.
	     </para>
	     <para>
	      Команда имеет следующий синтаксис:
	      <synopsis format="linespecific">su [-] [-flms] [-c класс] [пользователь [аргументы]]</synopsis>
	     </para>
	     <para>
	      Команда <command moreinfo="none">su</command> позволяет пользователю временно стать другим
	      пользователем.  Если не указан
	      параметр <parameter class="command" moreinfo="none">пользователь</parameter>, то
	      используется значение по умолчанию - суперпользователь. Если указанному
	      пользователю назначен пароль, то потребуется его ввести, прежде чем стать
	      другим пользователем.
	     </para>
	     <para>
	      Для того, чтобы стать суперпользователем, нужно ввести
	      команду <command moreinfo="none">su</command> без параметров:
	      <informalexample>
	       <screen format="linespecific">user@desktop$ su
Password:
desktop#</screen>
	      </informalexample>
	     </para> 
	    </listitem>
	</varlistentry>
	<varlistentry>
	  <term><emphasis id="def-cmd-sudo" xreflabel="sudo">sudo</emphasis></term>
	  <listitem>
	    <para>
	      Программа <application moreinfo="none">sudo</application> является логическим развитием
	      программы <application moreinfo="none">su</application> и позволяет как переходить в сеанс
	      суперпользователя, так и запускать отдельные программы от имени
	      суперпользователя.
	    </para>
	    <para>
	      Программа <application moreinfo="none">sudo</application> имеет синтаксис:
	      <synopsis format="linespecific">sudo [-HSb] [-u пользователь] {-s | команда}</synopsis>.
	      Можно использовать следующие опции:
	      <variablelist>
		<varlistentry>
		  <term><parameter class="command" moreinfo="none">-H</parameter></term>
		  <listitem>
		    переменная окружения <envar>HOME</envar> изменяется в соответствии с
		    выбранным пользователем;
		  </listitem>
		</varlistentry>
		<varlistentry>
		  <term><parameter class="command" moreinfo="none">-b</parameter></term>
		  <listitem>
		    команда исполняется на заднем фоне;
		  </listitem>
		</varlistentry>
		<varlistentry>
		  <term><parameter class="command" moreinfo="none">-s</parameter></term>
		  <listitem>
		    вместо команды запускается командная оболочка данного пользователя.
		  </listitem>
		</varlistentry>
	      </variablelist>
	    </para>
	    <para>
	      Главным достоинством команды <application moreinfo="none">sudo</application> является
	      возможность гибкого конфигурирования – на какие программы
	      каким пользователям разрешено повышение превилений. Конфигурация хранится в
	      файле <filename moreinfo="none">/etc/sudoers</filename>, рассмотрение формата которого
	      выходит за рамки этих лекций.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><emphasis id="def-cmd-passwd" xreflabel="passwd">passwd</emphasis></term>
	    <listitem>
	     <para>
	      Команда используется для изменения пароля.
	     </para>
	     <para>
	      Команда имеет следующий синтаксис:
	      <synopsis format="linespecific">passwd [-l] [пользователь]</synopsis>
	     </para>
	     <para>
	      Обычные пользователи могут сменить только собственные
	      пароли. Суперпользователь может менять пароли любых пользователей.  При
	      вызове команды сначала необходимо ввести старый пароль, если он был
	      установлен. Затем предлагается дважды ввести новый пароль. Если указанные
	      операции были сделаны без ошибок, то пароль пользователя будет изменен.
	     </para>
	    </listitem>
	</varlistentry>
	<varlistentry>
	  <term><emphasis id="def-cmd-useradd" xreflabel="useradd">useradd</emphasis></term>
	    <listitem>
	     <para>
	      Команда предназначена для добавления нового регистрационного имени
	      пользователя в системе.
	     </para>
	     <para>
	      Команда имеет следующий синтаксис:
	      <synopsis format="linespecific">useradd [-u идентификатор [-o] [-i]] [-g группа] [-G
	      группа[[,группа] . . .]] [-d каталог] [-s shell] [-c комментарий] [-m [-k
	      skel_dir]] [-f inactive] [-e expire] [-p passgen] [-a событие[, . . .]]
	      регистрационное_имя</synopsis>
	     </para>
	    </listitem>
	</varlistentry>
	<varlistentry>
	  <term><emphasis id="def-cmd-userdel" xreflabel="userdel">userdel</emphasis></term>
	    <listitem>
	     <para>
	      Команда предназначена для удаления регистрационных имен пользователей из системы.
	     </para>
	     <para>
	      Команда имеет следующий синтаксис:
	      <synopsis format="linespecific">userdel [-r] [-n месяцев] регистрационное_имя</synopsis>
	     </para>
	     <para>
	      Команда <command moreinfo="none">userdel</command> удаляет определение регистрационного
	      имени пользователя из системы. Она удаляет определение указанного
	      регистрационного имени и выполняет соответствующие изменения в
	      регистрационных файлах и файловой системе. Команда также запоминает
	      идентификационный номер удаляемого пользователя (UID) в
	      файле <filename moreinfo="none">/etc/security/ia/ageduid</filename>, так что этот
	      идентификатор не будет повторно использован на протяжении определенного
	      периода времени. Эта практика не использования идентификатора пользователя
	      называется устареванием идентификатора (UID aging).  Для удаления домашней
	      директории пользователя необходимо указать
	      флаг <parameter class="command" moreinfo="none">-r</parameter>.
	      Параметр <parameter class="command" moreinfo="none">месяцев</parameter> задает, сколько
	      месяцев будет запрещено использовать удаляемый идентификатор.
	     </para>
	    </listitem>
	</varlistentry>
	<varlistentry>
	  <term><emphasis id="def-cmd-usermod" xreflabel="usermod">usermod</emphasis></term>
	    <listitem>
	     <para>
	      Команда предназначена для изменения регистрационной информации о пользователе в системе.
	     </para>
	     <para>
	      Команда имеет следующий синтаксис:
	      <synopsis format="linespecific">usermod [-u идентификатор [-U] [-o]] [-g группа] [-G
	      группа[[,группа] . . .]] [-d каталог [-m]] [-s shell] [-c комментарий] [-l
	      новое_рег_имя] [-f inactive] [-e expire] [-p passgen] [-a
	      [оператор]событие[, . . .]] регистрационное_имя</synopsis>
	     </para>
	     <para>
	      Команда предназначена для изменения регистрационной информации о
	      пользователе в системе.
	     </para>
	    </listitem>
	</varlistentry>
	<varlistentry>
	  <term><emphasis id="def-cmd-groupadd" xreflabel="groupadd">groupadd</emphasis></term>
	  <listitem>
	   <para>
	    Команда используется для создания новой группы в системе.
	   </para>	   
	   <para>
	    Команда имеет следующий синтаксис:
	    <synopsis format="linespecific">groupadd [-g идентификатор [-o]] группа</synopsis>
	   </para>
	   <para>
	    Новую группу может добавить только администратор.
	    Команда <command moreinfo="none">groupadd</command> создает новое определение группы в системе
	    путем добавления соответствующей записи в файл /etc/group.
	   </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><emphasis id="def-cmd-groupdel" xreflabel="groupdel">groupdel</emphasis></term>
	    <listitem>
	     <para>
	      Команда используется для удаления определения группы из системы.
	     </para>
	     <para>
	      Команда имеет следующий синтаксис:
	      <synopsis format="linespecific">groupdel группа</synopsis>
	     </para>
	     <para>
	      Команда <command moreinfo="none">groupdel</command> удаляет определение группы из системы
	      путем удаления записи о соответствующей группе из
	      файла <filename moreinfo="none">/etc/group</filename>. Она, однако, не удаляет
	      идентификаторо группы (GID) из файла паролей; удаленный GID действует для
	      всех файлов и каталогов, которые его имели.
	     </para>
	    </listitem>
	</varlistentry>
	<varlistentry>
	  <term><emphasis id="def-cmd-groupmod" xreflabel="groupmod">groupmod</emphasis></term>
	    <listitem>
	     <para>
	      Команда предназначена для изменения определения группы в системе.
	     </para>
	     <para>
	      Команда имеет следующий синтаксис:
	      <synopsis format="linespecific">groupmod [-g идентификатор [-o]] [-n имя] группа</synopsis>
	     </para>
	     <para>
	      Команда <command moreinfo="none">groupmod</command> изменяет определение указанной группы
	      путем изменения соответствующей записи в
	      файле <filename moreinfo="none">/etc/group</filename>. Новое имя группы задается в
	      параметре <parameter class="command" moreinfo="none">группа</parameter>, новый идентификатор
	      группы задается в
	      параметре <parameter class="command" moreinfo="none">идентификатор</parameter>. Опция <parameter class="command" moreinfo="none">-o</parameter> позволяет задать дублирующийся идентификатор
	      группы.  Если перед группой стоит символ <quote>+</quote>,
	      (например, <emphasis>+student</emphasis>), определение группы
	      администрируется сетевой информационной службой (<emphasis>Network
	      Information Service</emphasis> - <acronym>NIS</acronym>). В этом случае,
	      значение идентификатора группы берется из базы
	      данных <acronym>NIS</acronym>. Для таких групп использование
	      опций <parameter class="command" moreinfo="none">-g</parameter>
	      или <parameter class="command" moreinfo="none">-o</parameter> вызовет выдачу сообщения о
	      синтаксической ошибке.
	     </para>
	    </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
    <sect2 id="security-cmd-summary">
      <title>Резюме</title>
      <para>
	В данном разделе рассматриваются команды изменения прав доступа, аутентификации и
	управления базой данных пользователей системы.
      </para>
      <para><emphasis>Ключевые термины: </emphasis><xref linkend="def-cmd-chmod"/>, <xref linkend="def-cmd-chown"/>, <xref linkend="def-cmd-su"/>, <xref linkend="def-cmd-sudo"/>, <xref linkend="def-cmd-passwd"/>, <xref linkend="def-cmd-useradd"/>, <xref linkend="def-cmd-userdel"/>, <xref linkend="def-cmd-usermod"/>, <xref linkend="def-cmd-groupadd"/>, <xref linkend="def-cmd-groupdel"/>, <xref linkend="def-cmd-groupmod"/></para>
    </sect2>    
    <sect2 id="security-cmd-additional">
      <title>Дополнительные материалы</title>
      <para>
	<orderedlist inheritnum="ignore" continuation="restarts">
	  <listitem>
	    Скотт Манн, Эленн Митчелл, Митчелл Крелл <emphasis>Безопасность
	    Linux</emphasis>. – М.: Вильямс, 2003. – 624 с.: ил.
	  </listitem>
	  <listitem>
	    Курячий Г.В. <emphasis>Операционная система UNIX</emphasis>. –
	    М.:Интуит.Ру, 2004. – 292 с.: ил.
	  </listitem>
	</orderedlist>
      </para>
    </sect2>    
  </sect1>
  <!-- занятие №7 (практическое занятие) -->
  <sect1 id="security-cmdexamples"><title>Практическое занятие. Управление доступом. Управление пользователями</title><sect2 id="security-scenario-login"><title>Сценарий: Вход в систему и завершение сеанса</title><para>
	
	  Сценарий посвящен изучению процесса аутентификации в UNIX.
	
      </para><para><emphasis>Начальные условия:</emphasis>
	Приглашение входа в систему.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	  <para>
	    Для входа в систему необходимо ввести логин и пароль пользователя. При этом
	    символы вводимого пароля не отображаются.
	    <informalexample>
	      <screen format="linespecific">Welcome to desktop / tty1
desktop login: user
Password:
Last login: Wed Dec 07 00:20:09 2006 from tty1
user@desktop ~ $</screen>
	    </informalexample>	    
	    При входе в систему в графическом режиме (через X11), пользователю вместо
	    командной строки предоставляется графический десктоп.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Для завершения сеанса работы в командной строке необходимо ввести
	    команду <command moreinfo="none">exit</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ exit</screen>
	    </informalexample>	    
	  </para>
	</listitem>
      </orderedlist></sect2><sect2 id="security-scenario-rights"><title>Сценарий: Изучение базовых прав доступа</title><para>
	
	  Сценарий рассматривает базовые права доступа в UNIX, их просмотр и изменения.
	
      </para><para><emphasis>Начальные условия:</emphasis>
	Командная строка после входа в систему.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	  <para>
	    Для просмотра прав доступа можно использовать
	    команду <application moreinfo="none">ls</application> с ключом вывода расширенной информации:
	    <command moreinfo="none">ls -l</command>. 
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ ls -l
drwxr-xr-x   1 user users   22 Дек 19 11:18 test/
-rw-r--r--   1 user users   90 Сен 19 00:20 test.txt</screen>
	    </informalexample>
	    Особый интерес представляют: первая колонка (права доступа), третья и
	    четвётрая – владелец и группа владельцев соответственно.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Рассмотрим исполняемый файл <command moreinfo="none">ls -l /bin/bash</command>. 
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ ls -l /bin/bash
-rwxr-xr-x  1 root root 746544 Дек 21 13:40 /bin/bash*</screen>
	    </informalexample>
	    Исполняемые файлы в UNIX определяются наличием специального бита прав доступа.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Для директории права на исполнения трактуются по-другому. Рассмотрим права
	    директории <filename moreinfo="none">/tmp</filename> <command moreinfo="none">ls -ld /tmp</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ ls -ld /tmp
drwxrwxrwt  26 root root 5168 Дек 22 20:04 /tmp/</screen>
	    </informalexample>
	    Директория имеет дополнительный sticky-bit, определающий права на создание и
	    удаление файлов в директории.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Изменение файла с недостатком прав приводит к ошибке доступа. Например,
	    команда: <command moreinfo="none">rm /bin/bash</command>. 
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ rm /bin/bash
rm: удалить защищенный от записи обычный файл `/bin/bash'? y
rm: невозможно удалить `/bin/bash': Permission denied</screen>
	    </informalexample>
	    Для всех файлов, на которые данный пользователь не имеет прав записи
	    команда <application moreinfo="none">rm</application> может выводить предупреждение об
	    удалении.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Изменение прав доступа производится с помощью
	    команды <application moreinfo="none">chmod</application>. Для задания файлу прав только для
	    чтения воспользуемся командой: <command moreinfo="none">chmod a=r test.txt</command>. 
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ chmod a=r test.txt</screen>
	    </informalexample>	    
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Для лишения всех прав группы владельцев и остальных пользователей
	    воспользуемся командой: <command moreinfo="none">chmod go-rwx test.txt</command>. 
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ chmod go-rwx test.txt</screen>
	    </informalexample>	    
	  </para>
	</listitem>
      </orderedlist></sect2><sect2 id="security-scenario-su"><title>Сценарий: Переход в режим суперпользователя</title><para>
	
	  Сценарий рассмартривает процесс повышения превилегий пользователя и переход в
	  режим суперпользователя.
	
      </para><para><emphasis>Начальные условия:</emphasis>
	Командная строка после входа в систему простого пользователя.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	  <para>
	    Некоторые исполняемые программы обладают специальным suid-битом, например,
	    программа <application moreinfo="none">passwd</application>, рассмотрим права доступа к этому
	    исполняемому файлу: <command moreinfo="none">ls -l /bin/passwd</command>.
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ ls -l /bin/passwd
-rws--x--x  1 root root 28660 Янв  8 13:05 /bin/passwd*</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Запускаются suid-программы от имени владельца файла. В этом можно убедиться,
	    если запустить команду <command moreinfo="none">passwd</command>, а затем на другом терминале
	    сделать <command moreinfo="none">ps aux | grep passwd</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ passwd
Changing password for user
(current) UNIX password:		
...
user@desktop ~ $ ps aux | grep passwd
root     12937  0.0  0.1   3228  1012 pts/2    S+   23:28   0:00 passwd
user     12989  0.0  0.1   2740   748 pts/3    R+   23:28   0:00 grep passwd</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Для длительной работы в режиме суперпользователя обычно используют
	    команду <application moreinfo="none">su</application>. Используем
	    параметр <parameter class="command" moreinfo="none">-</parameter>, чтобы проинициализировать
	    окружение суперпользователя: <command moreinfo="none">su -</command>. Для того, чтобы перейти
	    в режим суперпользователя, необходимо знать его пароль.
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ su -
Password:
desktop ~ #</screen>
	    </informalexample>	    
	    При этом запускается новая командная оболочка, уже с новыми привелегиями.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Для завершения сеанса суперпользователя необходимо воспользоваться
	    командой <command moreinfo="none">exit</command>:
	    <informalexample>
	      <screen format="linespecific">desktop ~ # exit
logout
user@desktop ~ $</screen>
	    </informalexample>	    
	  </para>
	</listitem>
      </orderedlist></sect2><sect2 id="security-scenario-usersdb"><title>Сценарий: Изучение базы данных пользователей</title><para>
	
	  В сценарии показано, где и каким образом хранится информация о пользователях
	  системы.
	
      </para><para><emphasis>Начальные условия:</emphasis>
	Командная строка после входа в систему.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	  <para>
	    Данные о зарегистрированных в системе пользователях хранятся в
	    файле <filename moreinfo="none">/etc/passwd</filename>. Рассмотрим его содержимое <command moreinfo="none">cat
	    /etc/passwd</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/bin/false
daemon:x:2:2:daemon:/sbin:/bin/false
adm:x:3:4:adm:/var/adm:/bin/false
...</screen>
	    </informalexample>
	    Подробную информацию о формате этого файла можно получить на соответствующей
	    странице руководств: <command moreinfo="none">man 5 passwd</command>.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Аналогичным образом данные о группах хранятся в
	    файле <filename moreinfo="none">/etc/group</filename>. Рассмотрим его содержимое <command moreinfo="none">cat
	    /etc/group</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ cat /etc/group
root:x:0:root
bin:x:1:root,bin,daemon
daemon:x:2:root,bin,daemon
sys:x:3:root,bin,adm
...</screen>
	    </informalexample>
	  </para>
	</listitem>
      </orderedlist></sect2><sect2 id="security-scenario-users"><title>Сценарий: Добавление и удаление пользователей</title><para>
	
	  Сценарий описывает администрирование пользователей системы: добавление новых
	  пользователей, удаление существущих, изменение параметров пользователей. Такие
	  изменения учётных записей пользователей доступны только суперпользователю.
	
      </para><para><emphasis>Начальные условия:</emphasis>
	Командная строка после входа в систему суперпользователя.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	  <para>
	    Для добавления новых пользователей используется
	    команда <application moreinfo="none">useradd</application>. При этом в качестве параметров
	    можно указать домашнюю директорию и командную оболочку пользователя: 
	    <command moreinfo="none">useradd testuser -d /home/users/testuser -s /bin/sh</command>,
	    результат можно увидеть следующим образом: <command moreinfo="none">cat /etc/passwd | grep
	    testuser</command>.
	    <informalexample>
	      <screen format="linespecific">desktop ~ # cat /etc/passwd
testuser:x:1003:1003::/home/users/testuser:/bin/sh</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    С помощью команды <application moreinfo="none">passwd</application> можно задать пароль для
	    нового пользователя: <command moreinfo="none">passwd testuser</command>.
	    <informalexample>
	      <screen format="linespecific">desktop ~ # passwd testuser
New UNIX password:
Retype new UNIX password:
passwd: пароль успешно обновлён</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Для изменения параметров учётной записи можно отредактировать
	    файл <filename moreinfo="none">/etc/passwd</filename>, однако более корректным способом
	    является использование команды <application moreinfo="none">usermod</application>. Например,
	    для изменение командной оболочки пользователя
	    на <filename moreinfo="none">/bin/false</filename> приведёт к невозможности его входа в
	    систему: <command moreinfo="none">usermod -s /bin/false testuser</command>.
	    <informalexample>
	      <screen format="linespecific">desktop ~ # usermod -s /bin/false testuser</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Удаление пользователя производится с помощью
	    команды <application moreinfo="none">userdel</application>: <command moreinfo="none">userdel
	    testuser</command>.
	    <informalexample>
	      <screen format="linespecific">desktop ~ # userdel testuser</screen>
	    </informalexample>
	  </para>
	</listitem>
      </orderedlist></sect2><sect2><title>Задания для самоподготовки</title><orderedlist><listitem>
	Выясните, чем отличается реакция операционной системы (выводимое сообщение) на
	различные ошибки аутентификации (например, неправильный пользователь, неверный
	пароль и т.д.).
      </listitem><listitem>
	Сравните права доступа к директориям /bin
	и /tmp. Какие операции сможет совершать в них простой
	пользователь?
      </listitem><listitem>
	Создайте текстовый файл и задайте права на него таким образом, чтобы он мог
	просматриваться только владельцем и никем не мог редактироваться. 
      </listitem><listitem>
	Что смогут делать другие пользователями с файлами в домашней директории
	пользователя, если он задаст всем остальным пользователям право на запись в
	директорию, но удалит право исполнения на неё?
      </listitem><listitem>
	Найдите все исполняемые файлы с установленным suid-битом.
      </listitem><listitem>
	Получите имена всех пользователей системы, у которых в качестве командной оболочки
	используется программа /bin/false.
      </listitem></orderedlist></sect2></sect1><sect1 id="security-cmdexamples-scenarios"><title>Сценарии практического занятия на тему: Управление доступом. Управление пользователями</title><para><xref linkend="security-scenario-login"/><orderedlist><listitem>exit</listitem></orderedlist></para><para><xref linkend="security-scenario-rights"/><orderedlist><listitem>ls -l</listitem><listitem>ls -l /bin/bash</listitem><listitem>ls -ld /tmp</listitem><listitem>rm /bin/bash</listitem><listitem>chmod a=r test.txt</listitem><listitem>chmod go-rwx test.txt</listitem></orderedlist></para><para><xref linkend="security-scenario-su"/><orderedlist><listitem>ls -l /bin/passwd</listitem><listitem>passwd</listitem><listitem>ps aux | grep passwd</listitem><listitem>su -</listitem><listitem>exit</listitem></orderedlist></para><para><xref linkend="security-scenario-usersdb"/><orderedlist><listitem>cat
	    /etc/passwd</listitem><listitem>man 5 passwd</listitem><listitem>cat
	    /etc/group</listitem></orderedlist></para><para><xref linkend="security-scenario-users"/><orderedlist><listitem>useradd testuser -d /home/users/testuser -s /bin/sh</listitem><listitem>cat /etc/passwd | grep
	    testuser</listitem><listitem>passwd testuser</listitem><listitem>usermod -s /bin/false testuser</listitem><listitem>userdel
	    testuser</listitem></orderedlist></para></sect1>
</chapter>

  
<chapter id="chapter-network">
  <title>Сетевые средства UNIX</title>
  <para>
    Современные вычислительные системы невозможно представить без наличия
    сетей. Технологии взаимодействия между информационными системами развиваются с 70-х
    годов, не намного опередив развитие UNIX. Операционная система UNIX почти с самого
    рождения интегрировала в себя технологии локальных сетей, на её основе затем была
    построена сеть Internet, распространившаяся ныне по всему миру.
  </para>
  <!-- занятие №8 (лекция) -->
  <sect1 id="network-lect">
    <title>Сеть в UNIX</title>
    <para><link linkend="small-pres-5-01">Презентация 5-01: введение в сети</link></para>
    <sect2 id="network-lect-intro">
      <title>Введение в сети</title>
      <para> Организация взаимодействия между устройствами и программами в сети является
	сложной задачей. Сеть объединяет разное оборудование, различные операционные
	системы и программы – это было бы невозможно без приянтия общепринятых
	правил, стандартов.
      </para>
      <para>
	В области компьютерных сетей существует множество международных и промышленных
	стандартов, среди которых следует особенно выделить международный
	стандарт <acronym>OSI</acronym> и набор стандартов <acronym>IETF</acronym>
	(Internet Engineering Task Force).
      </para>
      <sect3 id="network-lect-intro-osi">
	<title>Семиуровневая модель OSI</title>
	<para><link linkend="small-pres-5-02">Презентация 5-02: взаимодействие открытых систем</link></para>
	<para>
	  В модели <emphasis id="def-osi" xreflabel="OSI">OSI</emphasis>,
	  называемой также моделью взаимодействия открытых систем (Open Systems
	  Interconnection – <acronym>OSI</acronym>) и разработанной
	  Международной Организацией по Стандартам (International Organization for
	  Standardization – <acronym>ISO</acronym>), средства сетевого
	  взаимодействия делятся на семь уровней, для которых определены стандартные
	  названия и функции (см. <xref linkend="img-osi"/>).
	</para>
	<para>
	  <figure id="img-osi" float="0">
	    <title>Уровни <acronym>ISO</acronym> <acronym>OSI</acronym></title>
	    <graphic fileref="images/osi.png"/>
	  </figure>	
	</para>
	<para>
	  Каждый уровень предоставляет <emphasis>интерфейс</emphasis> к вышележащему
	  уровню, скрывая детали реализации. При построении транспортной подсистемы
	  какого-либо приложения наибольший интерес представляют функции физического,
	  канального и сетевого уровней, тесно связанные с используемым в данной сети
	  оборудованием: сетевыми адаптерами, концентраторами, мостами, коммутаторами,
	  маршрутизаторами. Функции прикладного и сеансового уровней, а также уровня
	  представления реализуются операционными системами и системными приложениями
	  конечных узлов. Транспортный уровень выступает посредником между этими двумя
	  группами протоколов.
	</para>
	<para>
	  Удалённые процессы при обмене информацией взаимодействуют только с самым верхним
	  уровнем, но данные при продвижения по сети проходят через все уровни на одной
	  машине и затем в обратном порядке на другой машине.
	</para>
	<para>
	  Рассмотрим подробнее назначения каждого из уровней:
	</para>
	<phrase id="quest-5-1" xreflabel="Какие уровни входят в модель ISO OSI? Какие можно&#10;&#9;провести аналогии с реально существующими протоколами?"/>
	<sect4 id="network-lect-intro-osi-phys">
	  <title>Физический уровень</title>
	  <para>
	    <emphasis id="def-osi-phys" xreflabel="физический уровень">Физический
	    уровень</emphasis> выполняет передачу битов по физическим каналам, таким,
	    как витая пара, оптоволоконный кабель или радиоволны. На этом уровне
	    определяются характеристики физических сред передачи данных и параметров
	    электрических сигналов.
	  </para>
	</sect4>
	<sect4 id="network-lect-intro-osi-datalink">
	  <title>Канальный уровень</title>
	  <para>
	    <emphasis id="def-osi-dl" xreflabel="канальный уровень">Канальный
	    уровень</emphasis> беспечивает передачу кадра данных между любыми узлами в
	    сетях с типовой топологией либо между двумя соседними узлами в сетях с
	    произвольной топологией, отвечает за установление соединения и корректность
	    доставки данных по физическим каналам. В протоколах канального уровня заложена
	    определенная структура связей между компьютерами и способы их
	    адресации. Адреса, используемые на канальном уровне в локальных сетях, часто
	    называют <emphasis id="def-mac-address" xreflabel="МАС-адрес">МАС-адресами</emphasis> (Media Access Control, управление
	    доступом к среде). Часть канального уровня требует аппаратной реализации, в
	    операционной системе он, как правило, представлен драйвером сетевой карты.
	  </para>
	</sect4>
	<sect4 id="network-lect-intro-osi-network">
	  <title>Сетевой уровень</title>
	  <para>
	    <emphasis id="def-osi-network" xreflabel="сетевой уровень">Сетевой
	      уровень</emphasis> в первую очередь должен предоставлять средства для решения
	    следующих задач:
	  </para>	  
	  <itemizedlist>
	    <listitem>доставки пакетов в сети с произвольной топологией;</listitem>
	    <listitem>структуризации сети путем надежной локализации трафика;</listitem>
	    <listitem>согласования различных протоколов канального уровня.</listitem>
	  </itemizedlist>
	  <para>
	    Сетевой уровень позволяет передавать данные между любыми, произвольно
	    связанными узлами сети (при этом не бетёт на себя никаких обязательств по
	    надежности передачи данных). Это достигается благодаря
	    наличию <emphasis>адресации</emphasis> – каждый узел в сети имеет
	    свой уникальный идентификатор.
	  </para>	  
	  <para>
	    Реализация протокола сетевого уровня подразумевает наличие в сети специального
	    устройства – <emphasis id="def-router" xreflabel="маршрутизатор">маршрутизатора</emphasis>. Маршрутизаторы объединяют
	    отдельные сети в общую составную сеть. К каждому маршрутизатору могут быть
	    присоединены несколько сетей (по крайней мере две). 
	  </para>
	</sect4>
	<sect4 id="network-lect-intro-osi-trans">
	  <title>Транспортный уровень</title>
	  <para>
	    <emphasis id="def-osi-trans" xreflabel="транспортный уровень">Транспортный
	    уровень</emphasis> обеспечивает передачу данных между любыми узлами сети с
	    требуемым уровнем надежности. Для этого на транспортном уровне имеются
	    средства установления соединения, нумерации, буферизации и упорядочивания
	    пакетов.
	  </para>
	</sect4>
	<sect4 id="network-lect-intro-osi-session">
	  <title>Сеансовый уровень</title>
	  <para>
	    <emphasis id="def-osi-sess" xreflabel="сеансовый уровень">Сеансовый
	    уровень</emphasis> предоставляет средства управления диалогом, позволяющие
	    фиксировать, какая из взаимодействующих сторон является активной в настоящий
	    момент, а также предоставляет средства синхронизации в рамках процедуры обмена
	    сообщениями.
	  </para>
	</sect4>
	<sect4 id="network-lect-intro-osi-pres">
	  <title>Уровень представления</title>
	  <para>
	    В отличии от нижележащих уровней, которые имеют дело с надежной и эффективной
	    передачей битов от отправителя к
	    получателю, <emphasis id="def-osi-pres" xreflabel="уровень представления">уровень представления</emphasis>
	    имеет дело с внешним представлением данных. На этом уровне могут выполняться
	    различные виды преобразования данных, такие как компрессия и декомпрессия,
	    шифровка и дешифровка данных.
	  </para>
	</sect4>
	<sect4 id="network-lect-intro-osi-app">
	  <title>Прикладной уровень</title>
	  <para>
	    <emphasis id="def-osi-app" xreflabel="прикладной уровень">Прикладной
	    уровень</emphasis> – это в сущности набор разнообразных сетевых
	    сервисов, предоставляемых конечным пользователям и приложениям. Примерами
	    таких сервисов являются, например, электронная почта, передача файлов,
	    подключение удаленных терминалов к компьютеру по сети.
	  </para>
	</sect4>
	<para>
	  Существует несколько групп протоколов (называемые также <quote>стеки
	  протоколов</quote>), которые частично или полностью соответствуют уровням
	  эталонной модели <acronym>OSI</acronym>. Для нас наибольший интерес представляет
	  набор протоколов TCP/IP.
	</para>
      </sect3>
      <sect3 id="network-lect-intro-tcpip"> 
	<title>Протоколы Internet: TCP/IP</title>
	<para><link linkend="small-pres-5-03">Презентация 5-03: протоколы Internet: TCP/IP</link></para>
	<para>
	  Протоколы TCP/IP (Transmission Control Protocol / Internet Protocol) были
	  разработаны по заказу Министерства обороны США 30 лет назад для связи
	  экспериментальной сети <acronym>ARPAnet</acronym> и представляет собой набор
	  общих протоколов для разнородной вычислительной среды. Большой вклад в развитие
	  стека TCP/IP внёс университет Беркли, реализовав этот протокол для операционнной
	  системы UNIX. Популярность UNIX и удачные идеи, заложенные в TCP/IP, привели к
	  образованию и бурному развитию международной сети Internet. Все протоколы
	  семейства TCP/IP и связанные с ними проходят стандартизацию в
	  организации <acronym>IETF</acronym> через выпуск так называемых RFC (Request For
	  Comment) документов.
	</para>
	<para>
	  Протоколы, входящие в TCP/IP частично соответствуют модели OSI
	  (см. <xref linkend="img-tcpip"/>). Стек TCP/IP поддерживает на нижнем уровне все
	  популярные стандарты физического и канального уровней: для локальных
	  сетей – Ethernet, Token Ring, FDDI, для глобальных – PPP,
	  ISDN. Основными протоколами стека, давшими ему название, являются протоколы IP и
	  TCP, относящиеся соответственно к сетевому и транспортному уровню. IP
	  обеспечивает продвижение пакета по сети, TCP гарантирует надёжность его доставки.
	</para>
	<para>
	  За долгие годы использования стек TCP/IP обзавёлся множеством протоколов
	  прикладного уровня: FTP, SMTP, HTTP и т.п..
	</para>
	<para>
	  <figure id="img-tcpip" float="0">
	    <title>Соответствие стека TCP/IP модели OSI</title>
	    <graphic fileref="images/tcpip.png"/>
	  </figure>	
	</para>
	<para>
	  Поскольку стек TCP/IP изначально создавался для глобальной сети, он имеет много
	  особеностей, дающих ему преимущество перед другими протоколами, когда речь
	  заходит о глобальных связях. Это способности фрагментации пакетов, гибкая
	  система адресации, простота широковещательных запросов.
	</para>
	<para>
	  Сегодня набор протоколов TCP/IP самый распространённый протокол вычислительных
	  сетей, к тому же он является наиболее <quote>оригинальным</quote> для
	  UNIX-систем. Рассмотрим, как производится администрирование этих протоколов в
	  UNIX. 
	</para>
      </sect3>	
    </sect2>
    <sect2 id="network-lect-iface">
      <title>Сетевой интерфейс в UNIX</title>
      <para><link linkend="small-pres-5-04">Презентация 5-04: сетевой интерфейс в UNIX</link></para>
      <phrase id="quest-5-2" xreflabel="Что такое сетевой интерфейс в UNIX? Для чего он&#10;      используется и каким образом конфигурируется?"/>
      <para>
	Основной сетевой подсистемы UNIX является сетевой интерфейс.
	<emphasis id="def-iface" xreflabel="сетевой интерфейс">Сетевой
	интерфейс</emphasis> – это абстракция, используемая для представления
	связи канального уровня сети с протоколом TCP/IP в UNIX.
      </para>
      <para>
	Каждый сетевой интерфейс в системе имеет уникальное имя, сотстоящее
	из <emphasis>типа устройства</emphasis> и <emphasis>номера</emphasis> (0 или
	больше для однотипных устройств). Под типами устройств в различных UNIX-системах
	может пониматься вид протокола канального уровня
	(Ethenet – <literal moreinfo="none">eth</literal>) или название драйвера устройства
	(Realtek – <literal moreinfo="none">rl</literal>).
      </para>
      <para>
	Интерфейс имеет набор параметров, большинство которых относятся к сетевому уровню
	(IP-адрес, маска сети и т.п.). Важным параметром сетевого интерфейса является
	аппаратный адрес (В Ethernet аппаратный адрес называется MAC-адрес и состоит из
	шести байтов, которые принято записывать в шестнадцатеричной системе исчисления и
	разделять двоеточиями).
      </para>
      <para>
	Узнать параметры интерфейса можно с помощью команды <command moreinfo="none">ifconfig</command>,
	указав в качестве аргумента его имя:
      </para>
      <para>
	<example>
	  <title>Пример выполнения команды ifconfig</title>
	  <screen format="linespecific">desktop ~ # ifconfig eth0
eth0      Link encap:Ethernet  HWaddr 00:0D:60:8D:42:AA  
          inet addr:192.168.1.5  Bcast:192.168.1.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:6160 errors:0 dropped:0 overruns:0 frame:0
          TX packets:5327 errors:0 dropped:0 overruns:0 carrier:0
          collisions:1006 txqueuelen:1000 
          RX bytes:3500059 (3.3 Mb)  TX bytes:2901625 (2.7 Mb)
          Base address:0x8000 Memory:c0220000-c0240000
desktop ~ # ifconfig lo
lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:188 errors:0 dropped:0 overruns:0 frame:0
          TX packets:188 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:14636 (14.2 Kb)  TX bytes:14636 (14.2 Kb)</screen>
	</example>
      </para>
      <para>
	Создание сетевого интерфейса производится в момент загрузки драйвера сетевой карты
	или создания логического соединения (например, в PPP). Настройка сетевых
	параметров, связанных с интерфейсом производится той же
	командой <command moreinfo="none">ifconfig</command>, о чем будет сказано далее.
      </para>
      <para>
	Для диагностики трафика на канальном уровне применяется специальные
	программы. Самыми распространёнными в UNIX
	являются <application moreinfo="none">tcpdump</application> и <application moreinfo="none">ethereal</application>.
	При <quote>прослушивании</quote> канала, эти программы взаимодействуют с заданным
	сетевым интерфейсом.
      </para>
    </sect2>    
    <sect2 id="network-lect-ip">
      <title>Конфигурация IP-сетей</title>
      <sect3 id="network-lect-ip-address"> 
	<title>Сетевой адрес</title>
	<para><link linkend="small-pres-5-05">Презентация 5-05: сетевой адрес</link></para>
	<para>
	  В IP-сетях каждому сетевому интерфейсу присваивается некоторый единственный
	  на всю глобальную сеть адрес, который не зависит от среды передачи данных и
	  всегда имеет один и тот же формат.
	</para>
	<para>
	  <emphasis id="def-ip-addr" xreflabel="IP-адрес">Адрес</emphasis>, определяемый
	  протоколом IP, состоит из четырех байтов, записываемых традиционно в десятичной
	  системе счисления и разделяемых точкой. Адрес сетевого интерфейса eth0 из
	  примера – 192.168.1.5.
	</para>
	<para>
	  Второй сетевой интерфейс из примера, lo, – так называемая заглушка (loopback),
	  которая используется для организации сетевых взаимодействий компьютера с самим
	  собой: любой посланный в заглушку пакет немедленно обрабатывается как принятый
	  оттуда. Заглушка обычно имеет адрес 127.0.0.1.
	</para>
	<para>
	  Для установления связи между интерфейсом и IP-адресом необходимо выполнить команду:
	  <informalexample>
	    <screen format="linespecific">desktop ~ # ifconfig eth0 192.168.1.1 up</screen>
	  </informalexample>	  
	</para>
      </sect3>
      <sect3 id="network-lect-ip-routing"> 
	<title>Маршрутизация</title>
	<para><link linkend="small-pres-5-06">Презентация 5-06: маршрутизация</link></para>
	<phrase id="quest-5-3" xreflabel="Как управлять IP-маршрутизацией в UNIX?"/>
	<para>
	  Маска подсети позволяет определить все узлы, находящиеся в той же локальной
	  сети. Пакеты к ним будут доставляться напрямую через канальный уровень.
	</para>
	<para>
	  Более сложный вопрос встает, если IP-адрес компьютера-адресата не входит в
	  локальную сеть компьютера-отправителя. Ведь и в этом случае пакет необходимо
	  отослать какому-то абоненту локальной сети, с тем, чтобы тот перенаправил его
	  дальше. Этот абонент, <emphasis>маршрутизатор</emphasis>, подключен к нескольким
	  сетям, и ему вменяется в обязанность пересылать пакеты между ними по
	  определенным правилам. В самом простом случае таких сетей
	  две: <quote>внутренняя</quote>, к которой подключены компьютеры,
	  и <quote>внешняя</quote>, соединяющая маршрутизатор со всей глобальной
	  сетью. Таблицу, управляющую маршрутизацией пакетов, можно просмотреть с помощью
	  команды netstat -r или route (обе команды имеют
	  ключ <parameter class="command" moreinfo="none">-n</parameter>, заставляющий их использовать в
	  выдаче IP-адреса, а не имена компьютеров):
	</para>
	<para>
	  <example>
	    <title>Пример выполнения команды route</title>
	    <screen format="linespecific">desktop ~ # route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0
127.0.0.0       0.0.0.0         255.0.0.0       U     0      0        0 lo
0.0.0.0         192.168.1.1     0.0.0.0         UG    0      0        0 eth0</screen>
	  </example>
	</para>
	<para>
	  Компьютер или аппаратное устройство, осуществляющее маршрутизацию между
	  локальной сетью и Internet обычно называется <emphasis id="def-gate" xreflabel="шлюз">шлюзом</emphasis>.
	</para>
	<para>
	  Задавать параметры маршрутизации можно с помощью той же
	  команды <command moreinfo="none">route</command>. 
	</para>
      </sect3>
      <sect3 id="network-lect-ip-icmp"> 
	<title>Служебный протокол ICMP</title>
	<para><link linkend="small-pres-5-07">Презентация 5-07: протокол ICMP</link></para>
	<para>
	  Есть такие протоколы уровня IP, действие которых этим уровнем и
	  ограничивается. Например, служебный протокол ICMP (Internet Control Message
	  Protocol), предназначенный для передачи служебных сообщений.
	</para>
	<para>
	  Примером применения ICMP является утилита <command moreinfo="none">ping</command>, которая
	  позволяет проверить работоспособность узлов в сети. Другое применение
	  ICMP – сообщать отправителю, почему его пакет невозможно доставить
	  адресату, или передавать информацию об изменении маршрута, о возможности
	  фрагментации и т. п.
	</para>
	<para>
	  Протоколом ICMP пользуется утилита <command moreinfo="none">traceroute</command>, позволяющая
	  приблизительно определять маршрут следования пакета:
	</para>
	<para>
	  <example>
	    <title>Пример выполнения команды <command moreinfo="none">traceroute</command></title>
	    <screen format="linespecific">desktop ~ # traceroute ya.ru
traceroute to ya.ru (213.180.204.8), 64 hops max, 40 byte packets
 1  195.91.230.65 (195.91.230.65)  0.890 ms  1.907 ms  0.809 ms
 2  cs7206.rinet.ru (195.54.192.28)  0.895 ms  0.769 ms  0.605 ms
 3  ix2-m9.yandex.net (193.232.244.93)  1.855 ms  1.519 ms  2.95 ms
 4  c3-vlan4.yandex.net (213.180.210.146)  3.412 ms  2.698 ms  2.654 ms
 5  ya.ru (213.180.204.8)  2.336 ms  2.612 ms  3.482 ms</screen>
	  </example>
	</para>
	<para>
	  Утилита traceroute показывает список абонентов, через которых проходит пакет по
	  пути к адресату, и потраченное на это время. Однако список этот
	  приблизительный. Строго говоря, неизвестно, каким маршрутом шла очередная группа
	  пакетов, потому что с тех пор, как посылалась предыдущая группа, какой-нибудь из
	  промежуточных маршрутизаторов мог передумать и послать новые пакеты другим
	  путем.
	</para>
      </sect3>
      <sect3 id="network-lect-ip-tcp"> 
	<title>Информация о соединениях</title>
	<para><link linkend="small-pres-5-08">Презентация 5-08: сетевые соединения</link></para>
	<para>
	  Транспортных протоколов в TCP/IP два – это TCP (Transmission Control Protocol,
	  протокол управления соединением) и UDP (User Datagram Protocol). UDP устроен
	  просто. Пользовательские данные помещаются в единственный транспортный
	  пакет-датаграмму, которой приписываются обычные для транспортного уровня данные:
	  адреса и порты отправителя и получателя, после чего пакет уходит в сеть искать
	  адресата. Проверять, был ли адресат способен этот пакет принять, дошел ли пакет
	  до него и не испортился ли по дороге, предоставляется следующему –
	  прикладному – уровню.
	</para>
	<para>
	  В UNIX существует прозрачный механизм именования сетевых протоколов. Согласно
	  стандартам Internet для большинства приложений существуют <emphasis>стандартные
	  порты</emphasis>, на которых соответствующие приложения должны принимать
	  соединения. В файле <filename moreinfo="none">/etc/services</filename> можно увидеть список
	  соответствия имён протоколов номерам портов. Благодаря этому файлу, в UNIX можно
	  во всех утилитах вместо номера порта писать имя соответвтвующего протокола.
	</para>
	<para>
	  Другое дело – TCP. Этот протокол очень заботится о том, чтобы
	  передаваемые данные дошли до адресата в целости и сохранности. Для этого
	  предпринимаются следующие действия:
	  <itemizedlist>
	    <listitem>
	      установление соеднинения;
	    </listitem>
	    <listitem>
	      обработка подтверждения корректной доставки;
	    </listitem>
	    <listitem>
	      отслеживание состояния абонентов.
	    </listitem>
	  </itemizedlist>
	</para>
	<para>
	  Для просмотра всех существующих в настоящий момент сетевых соединений можно
	  воспользоваться командой <command moreinfo="none">netstat</command>:
	</para>
	<para>
	  <example>
	    <title>Пример выполнения команды <command moreinfo="none">netstat</command></title>
	    <screen format="linespecific">desktop ~ # netstat -an
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 0.0.0.0:32769           0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:32770           0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN
tcp        0      0 192.168.11.5:34949      83.149.196.70:5223      ESTABLISHED
tcp        0      0 192.168.11.5:39833      213.248.55.180:5223     ESTABLISHED
tcp        0      0 192.168.11.5:59577      192.168.11.1:22         TIME_WAIT
udp        0      0 0.0.0.0:32768           0.0.0.0:*
udp        0      0 0.0.0.0:32769           0.0.0.0:*
udp        0      0 0.0.0.0:111             0.0.0.0:*</screen>
	  </example>	  
	</para>
      </sect3>
      <sect3 id="network-lect-ip-sysinit">
	<title>Настройка сети при загрузке системы</title>
	<para>
	  Для того, чтобы каждый раз при загрузке не задавать сетевые параметры,
	  существует возможность задать настройки сети в конфигурационных файлах
	  операционной системы. В этом случае при старте системы будет произведена процедура
	  настройки интерфейса, маршрутизации и т.п..
	</para>
	<para>
	  Такие файлы конфигурации являются специфичными для отдельно взятых версий
	  UNIX. Примеры будут рассмотрены на практическом занятии.
	</para>
      </sect3>
    </sect2>    
    <sect2 id="network-lect-internet">
      <title>Сервисы Internet</title>
      <para>
	<sect3 id="network-lect-internet-dns">
	  <title>Служба доменных имён</title>
	  <para><link linkend="small-pres-5-09">Презентация 5-09: служба доменных имён</link></para>
	  <phrase id="quest-5-4" xreflabel="Что такое служба доменных имён в UNIX? Как&#10;&#9;    она конфигурируется?"/>
	  <para>
	    В предыдущих примерах использовался
	    ключ <parameter class="command" moreinfo="none">-n</parameter> многих сетевых утилит, чтобы
	    избежать путаницы между IP-адресами и доменными именами компьютеров. С другой
	    стороны, доменные имена – несколько слов (часто осмысленных),
	    запоминать гораздо удобнее, чем адреса (четыре числа).
	  </para>
	  <para>
	    Когда-то имена всех компьютеров в сети, соответствующие IP-адресам, хранились
	    в файле <filename moreinfo="none">/etc/hosts</filename>. Пока абоненты Internet были
	    наперечет, поддерживать правильность его содержимого не составляло труда. Как
	    только сеть начала расширяться, неувязок стало больше. Трудность была не
	    только в том, что содержимое hosts быстро менялось, но и в том, что за
	    соответствие имен адресам в различных сетях отвечали разные люди и разные
	    организации. Появилась необходимость структурировать глобальную сеть не только
	    топологически (с помощью IP и сетевых масок), но и административно, с
	    указанием, за какие группы адресов кто отвечает.
	  </para>
	  <para>
	    Проще всего было структурировать сами имена компьютеров. Вся сеть была
	    поделена на домены – зоны ответственности отдельных государств
	    (<quote>us</quote>, <quote>uk</quote>,
	    <quote>ru</quote>, <quote>it</quote> и т. п.) или независимые зоны
	    ответственности (<quote>com</quote>, <quote>org</quote>, <quote>net</quote>,
	    <quote>edu</quote> и т. п.). Для каждого из таких доменов первого уровня
	    должно присутствовать подразделение, выдающее всем абонентам имена,
	    заканчивающиеся на <quote>.домен</quote> Подразделение обязано организовать и
	    поддерживать службу, заменяющую файл hosts: любой желающий имеет право узнать,
	    какой IP-адрес соответствует имени компьютера в этом домене или какому
	    доменному имени соответствует определенный IP-адрес.
	  </para>
	  <para>
	    Такая служба называется DNS (Domain Name
	    Service, <emphasis id="def-dns" xreflabel="служба доменных имен">служба доменных имен</emphasis>). Она
	    имеет иерархическую структуру. Если за какую-то группу абонентов домена
	    отвечают не хозяева домена, а кто-то другой, ему выделяется поддомен (или
	    домен второго уровня), и он сам распоряжается именами вида
	    <quote>имя_компьютера.поддомен.домен</quote>. Таким образом, получается нечто
	    вроде распределенной сетевой базы данных, хранящей короткие записи о
	    соответствии доменных имен IP-адресам.
	  </para>
	  <para>
	    В самом простом случае для того, чтобы сказать системе, какой сервер доменных
	    имён использовать, необходимо изменить
	    файл <filename moreinfo="none">/etc/resolv.conf</filename>. В более сложных системах можно
	    установить и настроить собственный сервер доменных имён.
	  </para>
	  <para>
	    Для проверки работы системы DNS используются утилиты <command moreinfo="none">dig</command>
	    и <command moreinfo="none">host</command>. 
	  </para>
	</sect3>
	<sect3 id="network-lect-internet-rsh">
	  <title>Удалённый терминал</title>
	  <para><link linkend="small-pres-5-10">Презентация 5-10: удалённый терминал</link></para>
	  <para>
	    Концепция <emphasis>терминала</emphasis>, описанная в главе
	    <xref linkend="shell-base-terminal"/>, может быть расширена на
	    сеть. Действительно, было бы удобно получить доступ к удалённой машине и
	    работать с ней как за обычными монитором и клавиатурой. Отпадает необходимость
	    иметь аппаратный терминал к каждому хосту, можно зайти терминалом на один
	    хост, затем <emphasis id="def-remote-terminal" xreflabel="удалённый      терминал">удаленным терминалом</emphasis> по сети на любой другой хост. В
	    современных условиях повсеместности сети Internet, удалённые терминалы
	    становятся основным рабочим инструментом администратора системы.
	  </para>
	  <para>
	    В сетях TCP/IP существует несколько приложений, позволяющих осуществить
	    терминальный заход. Рассмотрим два из них: <application moreinfo="none">telnet</application>
	    и <application moreinfo="none">ssh</application>. Оба построены по единому клиент-серверному
	    принципу.
	  </para>
	  <para>
	    Telnet – стандартное приложение, которое присутствует практически в
	    каждой реализации TCP/IP. Оно может быть использовано для связи между хостами,
	    работающими пол управлением различных операционных систем. Telnet использует
	    согласование опций клиента и сервера, чтобы определить, какие характеристики
	    присутствуют с той и с другой стороны.
	  </para>
	  <para>
	    Клиент telnet взаимодействует и с пользователем, находящимся за терминалом, и
	    с протоколами TCP/IP. Обычно, все что пользователь вводит с клавиатуры
	    отправляется по TCP соединению, а все что приходит по соединению попадает на
	    терминал.
	  </para>
	  <para>
	    Сервер telnet обычно взаимодействует с так называемыми псевдотерминальными
	    устройствами в UNIX системах. Это делает его похожим на командный
	    интерпритатор (shell), который запускается на сервере, или на любую программу,
	    которая запускается из командной оболочки, так как именно они общаются с
	    терминальными устройствами. Некоторые приложения, например, полноэкранные
	    редакторы, считают, что они общаются с терминальным устройством.
	  </para>
	  <para>
	    Клиент telnet имеет еще одно полезное преминение. С его помощью можно
	    тестировать стандартные сетевые протоколы – если в качестве порта
	    назначения назначить порт соответствующего приложения. Telnet отправляет
	    текстовые строки, разделённые знаками переноса строки, что делает его
	    совместимым со многими протоколами Internel (SMTP, HTTP и т.п.).
	  </para>
	  <para>
	    Программа telnet обладает значительным недостатком – вся информация
	    в ней (в том числе аутентификация пользователей) производится открытым
	    текстом. В современных условиях глобальной сети это уже небезопасно. Решением
	    этой проблемы является программа ssh, которая, будучи аналогичной по
	    функциональности программе telnet, устанавливает защищённое соединение и
	    предоставляет удалённый терминал с шифрацией всего промежуточного трафика.
	  </para>
	  <para>
	    В настоящее время для удалённого администрирования серверами в Internet
	    применяется исключительно команда ssh.
	  </para>
	</sect3>
	<sect3 id="network-lect-internet-proxy">
	  <title>Прокси-серверы</title>
	  <para>
	    <emphasis id="def-proxy" xreflabel="прокси-сервер">Прокси-сервер</emphasis> – специальная
	    служба, расположенная между локальной сетью и Internet, которая обеспечивает
	    доступ в Internet по протоколам HTTP, FTP и т.п. всем локальным компьютерам.
	  </para>
	  <para>
	    Такой сервер может поддерживать аутентификацию пользователей, учёт и
	    фильтрацию трафика. 
	  </para>
	  <para>
	    Недостатком такой схемы является то, что клиент в локальной сети должен явным
	    образом устанавливать соединение с прокси-сервером для запроса к удаленному
	    хосту в Internet.
	  </para>
	</sect3>
      </para>
    </sect2>    
    <sect2 id="network-lect-firewall">
      <title>Межсетевой экран</title>
      <para><link linkend="small-pres-5-11">Презентация 5-11: межсетевой экран iptables</link></para>
      <phrase id="quest-5-5" xreflabel="Какие функции выполняет межсетевой экран? Каковы принципы &#10;      управления межсетевым экраном iptables?"/>
      <para>
	В UNIX существует мощный механизм анализа сетевых и транспортных пакетов,
	позволяющий избавляться от нежелательной сетевой активности, манипулировать
	потоками данных и даже преобразовывать служебную информацию в них. Обычно такие
	средства носят название firewall (<quote>fire wall</quote> –
	противопожарная стена, брандмауэр), общепринятый русский
	термин – <emphasis id="def-firewall" xreflabel="межсетевой экран">межсетевой экран</emphasis>.
      </para>
      <para>
	В различных версиях UNIX функциональность и управление межсетевым экраном может
	значительно отличаться. В данных лекциях будет рассматриваться
	приложение <application moreinfo="none">iptables</application>, которое используется для
	организации межсетевого экрана в Linux.
      </para>
      <sect3 id="network-lect-firewall-iptables">
	<title>Концепции iptables</title>
	<para>
	  Суть <application moreinfo="none">iptables</application> в следующем. Обработка сетевого пакета
	  системой представляется как его конвейерная обработка. Пакет нужно получить из
	  сетевого интерфейса или от системного процесса, затем следует выяснить
	  предполагаемый маршрут этого пакета, после чего отослать его через сетевой
	  интерфейс либо отдать какому-нибудь процессу, если пакет предназначался нашему
	  компьютеру. Налицо три конвейера обработки пакетов: <quote>получить –
	  маршрутизировать – отослать</quote> (действие
	  маршрутизатора), <quote>получить – маршрутизировать –
	  отдать</quote> (действие при получении пакета процессом)
	  и <quote>взять – маршрутизировать – отослать</quote>
	  (действие при отсылке пакета процессом).
	</para>
	<para>
	  Между каждыми из этих действий системы помещается модуль межсетевого экрана,
	  именуемый <emphasis id="def-chain" xreflabel="цепочка">цепочкой</emphasis>. Цепочка обрабатывает пакет, исследуя,
	  изменяя и даже, возможно, уничтожая его. Если пакет уцелел, она передает его
	  дальше по конвейеру. В этой стройной схеме есть два исключения. Во-первых, ядро
	  Linux дает доступ к исходящему пакету только после принятия решения о его
	  маршрутизации, поэтому связка <quote>взять – маршрутизировать</quote>
	  остается необработанной, а цепочка, обрабатывающая исходящие пакеты (она
	  называется OUTPUT) вставляется после маршрутизации. Во-вторых, ограничения
	  на <quote>чужие</quote> пакеты, исходящие не от нас и не для нас
	  предназначенные, существенно отличаются от ограничений на
	  пакеты <quote>свои</quote>, поэтому после маршрутизации транзитные пакеты
	  обрабатываются еще одной цепочкой (она называется FORWARD). Цепочка,
	  обслуживающая связку <quote>получить – маршрутизировать</quote>,
	  называется PREROUTING, цепочка, обслуживающая
	  связку <quote>маршрутизировать – отдать</quote> – INPUT, а
	  цепочка, стоящая непосредственно перед отсылкой пакета – POSTROUTING
	  (см. <xref linkend="img-iptables"/>).
	</para>
	<para>
	  <figure id="img-iptables" float="0">
	    <title>Обработка пакета в iptables</title>
	    <graphic fileref="images/iptables.png"/>
	  </figure>	
	</para>
	<para>
	  Если пакет не имеет свойств, требуемых первым правилом, к нему применяется
	  второе, если второе также не подходит – третье, и так вплоть до
	  последнего, правила по умолчанию, которое применяется к любому пакету. Если
	  свойства пакета удовлетворяют правилу, над ним совершается действие. Действие
	  DROP уничтожает пакет, а действие ACCEPT немедленно выпускает его из таблицы,
	  после чего пакет движется дальше по конвейеру. Некоторые действия, например LOG,
	  никак не влияют на судьбу пакета, после их выполнения он остается в таблице: к
	  нему применяется следующее правило, и т. д. до ACCEPT или DROP.
	</para>
	<para>
	  Одной из важных функций сетевого экрана является подмена адресов и модификация
	  сетевых пакетов. <emphasis id="def-nat" xreflabel="NAT">NAT</emphasis>
	  (Network Address Translation – подмена сетевых адресов) –
	  это механизм, позволяющий организовать передачу пакетов между сетями, не
	  имеющими сведений о сетевых адресах друг друга. Этот процесс, чем-то схожий с
	  маршрутизацией, позволяет организовывать шлюзы локальных сетей в Internet,
	  распределять внешние соединения на отдельные машины внутри сети и т.п..
	</para>
	<para>
	  Следует помнить, что чем больше транспортных соединений отслеживается
	  межсетевым экранам, тем больше требуется оперативной памяти ядру Linux и тем
	  медленнее работает процедура сопоставления проходящих пакетов таблице. Впрочем,
	  мощность современных компьютеров позволяет без каких-либо затруднений
	  обслуживать преобразование адресов для сети с пропускной способностью 100Мбит/с
	  и даже выше.
	</para>
	<para>
	  Таким образом, администратору возможны несколько функций воздействия на пакеты:
	  фильтрация, подмена адресов, изменение других параметров пакетов.
	  Пример организации межсетевого экрана будет рассмотрен на практическом занятии.
	</para>
      </sect3>
    </sect2>    
    <sect2 id="network-lect-summary">
      <title>Резюме</title>
      <para><link linkend="small-pres-5-12">Презентация 5-12: резюме</link></para>
      <para>
	Сеть состоит из различных аппаратно-программных узлов, для объединения которых
	используются стандартные протоколы. Эталонной моделью взаимодействия таких систем
	является семиуровневая модель OSI.
      </para>
      <para>
	Протокол TCP/IP частично реализует уровни OSI. Основные протоколы IP (сетевого
	уровня) и TCP (транспортного уровня) позволили объединить разрозненные локальные
	сети в глобальную сеть Internet.
      </para>
      <para>
	В UNIX основной сетевого взаимодействия является интерфейс, который находится
	между канальным и сетевым уровнем. Конфигурация TCP/IP включает в себя настройку
	интерфейса, маршрутизации и сервисов Internet, в первую очередь сервера доменных
	имен. 
      </para>
      <para>
	Для удаленного управления компьютерами используется программа telnet и её
	современных защищённый аналог – ssh.
      </para>
      <para>
	Важным элементом сетевой мнфраструктуры является межсетевой экран, который
	позволяет ограничить сетевой трафик и изменить его свойства. На лекции был
	рассмотрен межсетевой экран Linux – iptables.
      </para>
      <para><emphasis>Ключевые термины: </emphasis><xref linkend="def-osi"/>, <xref linkend="def-osi-phys"/>, <xref linkend="def-osi-dl"/>, <xref linkend="def-mac-address"/>, <xref linkend="def-osi-network"/>, <xref linkend="def-router"/>, <xref linkend="def-osi-trans"/>, <xref linkend="def-osi-sess"/>, <xref linkend="def-osi-pres"/>, <xref linkend="def-osi-app"/>, <xref linkend="def-iface"/>, <xref linkend="def-ip-addr"/>, <xref linkend="def-gate"/>, <xref linkend="def-dns"/>, <xref linkend="def-remote-terminal"/>, <xref linkend="def-proxy"/>, <xref linkend="def-firewall"/>, <xref linkend="def-chain"/>, <xref linkend="def-nat"/></para>
    </sect2>    
    <sect2 id="network-lect-additional">
      <title>Дополнительные материалы</title>
      <para>
	<orderedlist inheritnum="ignore" continuation="restarts">
	  <listitem>
	    Олифер В.Г., Олифер Н.А. <emphasis>Компьютерные сети. Принципы, технологии,
	    протоколы</emphasis>. – СПб.: Питер, 2002. – 672 с.:
	    ил.
	  </listitem>
	  <listitem>
	    Курячий Г.В., Маслинский К.А. <emphasis>Операционная система
	    Linux</emphasis>. – М.: Интуит.Ру, 2005. – 392 с.: ил.
	  </listitem>
	</orderedlist>
      </para>
    </sect2>    
    <sect2 id="network-lect-questions"><title>Вопросы</title><para><orderedlist><listitem><xref linkend="quest-5-1"/></listitem><listitem><xref linkend="quest-5-2"/></listitem><listitem><xref linkend="quest-5-3"/></listitem><listitem><xref linkend="quest-5-4"/></listitem><listitem><xref linkend="quest-5-5"/></listitem></orderedlist></para></sect2>
    <sect2 id="network-lect-presentaion"><title>Презентация</title><para><figure id="small-pres-5-01" float="0"><title>Презентация 5-01: введение в сети</title><graphic fileref="pres/small-lect5-01.png"/></figure></para><para><figure id="small-pres-5-02" float="0"><title>Презентация 5-02: взаимодействие открытых систем</title><graphic fileref="pres/small-lect5-02.png"/></figure></para><para><figure id="small-pres-5-03" float="0"><title>Презентация 5-03: протоколы Internet: TCP/IP</title><graphic fileref="pres/small-lect5-03.png"/></figure></para><para><figure id="small-pres-5-04" float="0"><title>Презентация 5-04: сетевой интерфейс в UNIX</title><graphic fileref="pres/small-lect5-04.png"/></figure></para><para><figure id="small-pres-5-05" float="0"><title>Презентация 5-05: сетевой адрес</title><graphic fileref="pres/small-lect5-05.png"/></figure></para><para><figure id="small-pres-5-06" float="0"><title>Презентация 5-06: маршрутизация</title><graphic fileref="pres/small-lect5-06.png"/></figure></para><para><figure id="small-pres-5-07" float="0"><title>Презентация 5-07: протокол ICMP</title><graphic fileref="pres/small-lect5-07.png"/></figure></para><para><figure id="small-pres-5-08" float="0"><title>Презентация 5-08: сетевые соединения</title><graphic fileref="pres/small-lect5-08.png"/></figure></para><para><figure id="small-pres-5-09" float="0"><title>Презентация 5-09: служба доменных имён</title><graphic fileref="pres/small-lect5-09.png"/></figure></para><para><figure id="small-pres-5-10" float="0"><title>Презентация 5-10: удалённый терминал</title><graphic fileref="pres/small-lect5-10.png"/></figure></para><para><figure id="small-pres-5-11" float="0"><title>Презентация 5-11: межсетевой экран iptables</title><graphic fileref="pres/small-lect5-11.png"/></figure></para><para><figure id="small-pres-5-12" float="0"><title>Презентация 5-12: резюме</title><graphic fileref="pres/small-lect5-12.png"/></figure></para></sect2>
  </sect1>
  <sect1 id="network-cmd">
    <title>Методические указания по командам управления сетью в UNIX</title>
    <sect2 id="network-cmd-config">
      <title>Команды по конфигурированию сети</title>
      <variablelist>
	<varlistentry>
	  <term><emphasis id="def-cmd-ifconfig" xreflabel="ifconfig">ifconfig</emphasis></term>
	  <listitem>
	   <para>
	     Команда используется для настройки сетевых интерфейсов
     	   </para>
	   <para>
	     Команда <command moreinfo="none">ifconfig</command> имеет следующий синтаксис:
	     <synopsis format="linespecific">ifconfig [-L] [-m] interface [create] [address_family] [address [dest_address]] [parameters]
ifconfig interface destroy
ifconfig -a [-L] [-d] [-m] [-u] [address_family]
ifconfig -l [-d] [-u] [address_family]
ifconfig [-L] [-d] [-m] [-u] [-C]</synopsis>
	   </para>
	   <para>
             Команда <command moreinfo="none">ifconfig</command> используется для настройки сетевых
	     интерфейсов. Команда должна использоваться при загрузке системы для настройки
	     адресов каждого сетевого интерфейса, а также может использоваться после
	     загрузки для изменения параметров сетевых интерфейсов. Если команда введена
	     без аргументов, <command moreinfo="none">ifconfig</command> выдает информацию о состоянии
	     активных интерфейсов.  Если в качестве аргумента указан какой-либо интерфейс,
	     то выдается информация только о состоянии этого интерфейса; если указан один
	     аргумент -a, выдается информация о состоянии всех интерфесов, даже
	     отключенных. Пример:
	     <informalexample>
	       <screen format="linespecific">user@desktop$ ifconfig rl0
rl0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	   options=8&lt;VLAN_MTU&gt;
	   inet6 fe80::250:22ff:febb:5f1%rl0 prefixlen 64 scopeid 0x3
	   inet 192.168.19.86 netmask 0xffffff00 broadcast 192.168.19.255
	   ether 00:50:22:bb:05:f1
	   media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
           status: active</screen>
	    </informalexample>
	     Иначе команда конфигурирует указанный интерфейс. Изменить настройки какого-либо интерфейса может только суперпользователь.
	   </para>
	   <para>
	    Опции:
	    <simplelist type="horiz" columns="2">
		    <member><emphasis>интерфейс</emphasis></member>
		    <member> – имя интерфейса (например, rl0 в BSD или eth0 в Linux).</member>
		    <member><emphasis>up</emphasis></member>
		    <member> – вызывает активизацию интерфейса. Задается неявно при присвоении адреса интерфейсу.</member>
		    <member><emphasis>down</emphasis></member>
		    <member> – вызывает остановку работы драйвера для интерфейса. </member>
		    <member><emphasis>[-]arp</emphasis></member>
		    <member> – включает или отключает использование протокола <emphasis>ARP</emphasis> для интерфейса.</member>
		    <member><emphasis>[-]promisc</emphasis></member>
		    <member> – включает или отключает неразборчивый режим (promiscuous mode) работы интерфейса. 
			    В этом режиме все проходящие по сети пакеты будут приниматься интерфейсом. </member>
		    <member><emphasis>[-]allmulti</emphasis></member>
		    <member> – включает или отключает режим <emphasis>all-multicast</emphasis>. В этом режиме все многоадресные 
			    (multicast) пакеты в сети будут приниматься интерфейсом. </member>
		    <member><emphasis>metric N</emphasis></member>
		    <member> – устанавливает метрику интерфейса. </member>
		    <member><emphasis>mtu N</emphasis></member>
		    <member> – устанавливает максимальный размер пакета (Maximum Transfer Unit - MTU) для интерфейса. </member>
		    <member><emphasis>адрес</emphasis></member>
		    <member> – IP-адрес, присваиваемый интерфейсу. </member>
		    <member><emphasis>netmask адрес</emphasis></member>
		    <member> – устанавливает маску сети IP для этого интерфейса. По умолчанию используется обычная маска сети класса 
			    A, B или C (что определяется по IP-адресу интерфейса), но можно усановить любое значение.</member>
		    <member><emphasis>add адрес/длина_префикса</emphasis></member>
		    <member> – добавляет адрес IPv6 для интерфейса.</member>
		    <member><emphasis>del адрес/длина_префикса</emphasis></member>
		    <member> – удаляет адрес IPv6 для интерфейса. </member>
		    <member><emphasis>irq адрес</emphasis></member>
		    <member> – устанавливает аппаратное прерывание, используемое устройством. Не для всех устройств можно динамически менять значение IRQ. </member>
		    <member><emphasis>media тип</emphasis></member>
		    <member> – устанавливает физический порт или тип носителя, используемый устройством. Не для всех устройств можно менять этот параметр, и 
			    для разных устройств могут поддерживаться различные значения. Типичные значения типа - 10base2 (коаксиальный кабель Ethernet), 
			    10baseT (витая пара Ethernet 10 Мбит/сек), AUI (внешний передатчик) и т.д. Специальный тип носителя auto можно использовать, 
			    чтобы потребовать от драйвера автоматически обпределять тип носителя. Не все драйверы могут это делать. </member>
		    <member><emphasis>[-]broadcast [адрес]</emphasis></member>
		    <member> – если указан аргумент адрес, задает соответствующий протоколу широковещательный адрес для интерфейса. В противном случае устанавливает
			    (или сбрасывает) флаг IFF_BROADCAST для интерфейса. </member>
	    </simplelist>
	    <emphasis>Пример.</emphasis> изменение IP-адреса интерфейса rl0:
	    <informalexample>
		    <screen format="linespecific">user@desktop ~ $ ifconfig rl0
rl0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	   options=8&lt;VLAN_MTU&gt;
	   inet6 fe80::250:22ff:febb:5f1%rl0 prefixlen 64 scopeid 0x3
	   inet 192.168.19.86 netmask 0xffffff00 broadcast 192.168.19.255
	   ether 00:50:22:bb:05:f1
	   media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
	   status: active
user@desktop ~ $ ifconfig rl0 192.168.0.1
user@desktop ~ $ ifconfig rl0
rl0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	   options=8&lt;VLAN_MTU&gt;
	   inet6 fe80::250:22ff:febb:5f1%rl0 prefixlen 64 scopeid 0x3
	   inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.19.255
	   ether 00:50:22:bb:05:f1
	   media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
	   status: active</screen>
	    </informalexample>
	   </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><emphasis id="def-cmd-arp" xreflabel="arp">arp</emphasis></term>
	  <listitem>
	    <para>
	      Команда <command moreinfo="none">arp</command> отображает <acronym>ARP</acronym>-таблицу
	      данного хоста. С помощью параметра <parameter class="command" moreinfo="none">-i</parameter>
	      можно специфицировать сетевой интерфейс, информация о котором интересует.
	    </para>
	    <para>
	      <informalexample>
		<screen format="linespecific">desktop ~ # arp -i eth0
Address                  HWtype  HWaddress           Flags Mask            Iface
DIMON.mshome.net         ether   00:50:BF:12:8A:9E   C                     eth0</screen>
	      </informalexample>
	    </para>
	    <para>
	      Таблица с информацией о канальном уровне содержит связь IP- и MAC-адресов.
	      При использовании параметра <parameter class="command" moreinfo="none">-n</parameter>
	      IP-адреса не будут заменяться символьными именами хостов.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><emphasis id="def-cmd-route" xreflabel="route">route</emphasis></term>
	  <listitem>
	    <para>
	      Эта команда используется для просмотра и изменения таблицы маршрутизации
	      хоста. Для этой команды также работает
	      параметр <parameter class="command" moreinfo="none">-n</parameter>, при использовании которого
	      IP-адреса не будут заменяться символьными именами хостов.
	    </para>
	    <para>
	      Пример обычной таблицы маршрутизации для отдельного компьютера в сети:
	      <informalexample>
		<screen format="linespecific">desktop ~ # route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.5.0     0.0.0.0         255.255.255.0   U     0      0        0 eth1
127.0.0.0       0.0.0.0         255.0.0.0       U     0      0        0 lo
0.0.0.0         192.168.5.254   0.0.0.0         UG    0      0        0 eth1</screen>
	      </informalexample>
	      Особый интерес представляет адрес <literal moreinfo="none">0.0.0.0</literal>, который
	      соответствует хосту назначения по умолчанию.
	    </para>
	    <para>
	      Для добавление нового маршрута к определённому хосту используются параметры
	      <parameter class="command" moreinfo="none">add</parameter>
	      и <parameter class="command" moreinfo="none">-host</parameter>:
	      <informalexample>
		<screen format="linespecific">desktop ~ # route add -host 192.168.0.1 eth0</screen>
	      </informalexample>
	      Эта команда создаёт новую строку в таблице маршрутизации, согласно которой
	      все пакетыы к узлу <literal moreinfo="none">192.168.0.1</literal> должны отправляться в
	      сетевой интерфейс <literal moreinfo="none">eth0</literal>.
	    </para>
	    <para>
	      Также можно добавлять шлюз для отправки пакетов в определённую сеть или к
	      хосту: 
	      <informalexample>
		<screen format="linespecific">desktop ~ # route add -net 192.168.1.0 gw 192.168.0.5</screen>
	      </informalexample>
	      Таким образом, все пакеты для сети <literal moreinfo="none">192.168.1.0</literal> будут
	      направляться на узел
	      <literal moreinfo="none">192.168.0.5</literal>. 
	    </para>
	    <para>
	      Аналогично, маршруты удаляются
	      параметром <parameter class="command" moreinfo="none">del</parameter> с указанием всей
	      информации о маршруте:
	      <informalexample>
		<screen format="linespecific">desktop ~ # route del default gw 192.168.0.1</screen>
	      </informalexample>
	      Эта команда удаляет маршрут по умолчанию через
	      хост <literal moreinfo="none">192.168.0.1</literal>.
	    </para>	    
	  </listitem>
	</varlistentry>

      </variablelist>
    </sect2>
    <sect2 id="network-cmd-diagn">
      <title>Команды по диагностике сети</title>
      <variablelist>
	<varlistentry>
	  <term><emphasis id="def-cmd-ping" xreflabel="ping">ping</emphasis></term>
	  <listitem>
	    <para>
	      Команда используется для посылки пакетов ICMP ECHO_REQUEST
	      сетевым хостам.
	    </para>
	    <para>
	      Команда <command moreinfo="none">ping</command> имеет следующий синтаксис:
	      <synopsis format="linespecific">ping [-AaDdfnoQqRrv] [-c число_пакетов] [-i секунд] [-l preload] [-M mask | time]
		[-m ttl] [-P policy] [-p pattern] [-S src_addr] [-s packetsize]
		[-t timeout] [-z tos] host
ping [-AaDdfLnoQqRrv] [-c число_пакетов] [-I iface] [-i секунд] [-l preload]
		[-M mask | time] [-m ttl] [-P policy] [-p pattern] [-S src_addr]
		[-s packetsize] [-T ttl] [-t timeout] [-z tos] mcast-group</synopsis>
	    </para>
	    <para>
	      Команда <command moreinfo="none">ping</command> использует датаграмму ECHO_REQUEST протокола
	      ICMP, чтобы вызвать ответ ICMP ECHO_RESPONSE указанного хоста или сетевого
	      шлюза. Если хост отвечает, <command moreinfo="none">ping</command> выдает сообщение, что
	      хост включен (хост is alive), в стандартный выходной поток.
	    </para>
	    <para>
	      Для проверки наличия хоста в сети достаточно ввести
	      команду <command moreinfo="none">ping</command> с аргументом - именем или адресом хоста:
	      <informalexample>
		<screen format="linespecific">user@desktop$ ping yandex.ru
64 bytes from 213.180.204.11: icmp_seq=0 ttl=48 time=5.659 ms
64 bytes from 213.180.204.11: icmp_seq=1 ttl=48 time=5.404 ms
64 bytes from 213.180.204.11: icmp_seq=2 ttl=48 time=4.889 ms
^C
--- yandex.ru ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max/stddev = 4.889/5.317/5.659/0.320 ms</screen>
	      </informalexample>
	      Для отправки определенного числа пакетов необходимо указать
	      опцию <parameter class="command" moreinfo="none">-c число_пакетов</parameter>. Для установки
	      интервала между отправкой пакетов используется
	      опция <parameter class="command" moreinfo="none">-i секунд</parameter>.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><emphasis id="def-cmd-traceroute" xreflabel="traceroute">traceroute</emphasis></term>
	  <listitem>
	    <para>
	      Команда <command moreinfo="none">traceroute</command> служит для отладки сетевых соединений
	      посредством построения маршрута следования пакетов к хосту назначения. 
	      Для этой команды также работает
	      параметр <parameter class="command" moreinfo="none">-n</parameter>, при использовании которого
	      IP-адреса не будут заменяться символьными именами хостов.
	    </para>
	    <para>
	      Пример следования пакетов до хоста ya.ru:
	      <informalexample>
		<screen format="linespecific">desktop ~ # traceroute ya.ru
traceroute to ya.ru (213.180.204.8), 64 hops max, 40 byte packets
 1  195.91.230.65 (195.91.230.65)  0.890 ms  1.907 ms  0.809 ms
 2  cs7206.rinet.ru (195.54.192.28)  0.895 ms  0.769 ms  0.605 ms
 3  ix2-m9.yandex.net (193.232.244.93)  1.855 ms  1.519 ms  2.95 ms
 4  c3-vlan4.yandex.net (213.180.210.146)  3.412 ms  2.698 ms  2.654 ms
 5  ya.ru (213.180.204.8)  2.336 ms  2.612 ms  3.482 ms</screen>
	      </informalexample>
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><emphasis id="def-cmd-netstat" xreflabel="netstat">netstat</emphasis></term>
	  <listitem>
	    <para>
	      Команда используется для показа состояния сети.
	    </para>
	    <para>
	      Команда <command moreinfo="none">netstat</command> имеет следующий синтаксис:
	      <synopsis format="linespecific">netstat [-AaLnSW] [-f protocol_family | -p protocol] [-M core] [-N system]</synopsis>
	    </para>
	    <para>
	      Команда <command moreinfo="none">netstat</command> показывает содержимое различных структур
	      данных, связанных с сетью, в различных форматах в зависимости от указанных
	      опций. <emphasis>Первая форма</emphasis> команды показывает список активных
	      сокетов (sockets) для каждого протокола. <emphasis>Вторая форма</emphasis>
	      выбирает одну из нескольких других сетевых структур данных. <emphasis>Третья
	      форма</emphasis> показывает динамическую статистику пересылки пакетов по
	      сконфигурированным сетевым интерфейсам; аргумент интервал задает, сколько
	      секунд собирается информация между последовательными показами.
	    </para>
	    <para>
	      <parameter class="command" moreinfo="none">-p имя_протокола</parameter> Ограничить показ
	      статистики или адресов управляющих блоков только протоколом с указанным
	      именем_протокола, например, tcp.
	    </para>
	    <para>
	      Опции:
	      <simplelist type="horiz" columns="2">
		<member><parameter class="command" moreinfo="none">-a</parameter></member>
		<member> – показывать состояние всех сокетов; обычно сокеты, используемые серверными процессами, не показываются.</member>
		<member><parameter class="command" moreinfo="none">-A</parameter></member>
		<member> – показывать адреса любых управляющих блоков протокола, связанных с сокетами; используется для отладки.</member>
		<member><parameter class="command" moreinfo="none">-i</parameter></member>
		<member> – показывать состояние автоматически сконфигурированных (auto-configured) интерфейсов. Интерфейсы, 
		  статически сконфигурированные в системе, но не найденные во время загрузки, не показываются.</member>
		<member><parameter class="command" moreinfo="none">-n</parameter></member>
		<member> – показывать сетевые адреса как числа. <command moreinfo="none">netstat</command>  обычно показывает адреса как символы. 
		  Эту опцию можно использовать с любым форматом показа.</member>
		<member><parameter class="command" moreinfo="none">-r</parameter></member>
		<member> – показать таблицы маршрутизации. При использовании с опцией <parameter class="command" moreinfo="none">-s</parameter>, 
		  показывает статистику маршрутизации.</member>
		<member><parameter class="command" moreinfo="none">-s</parameter></member>
		<member> – показать статистическую информацию по протоколам. При использовании с опцией <parameter class="command" moreinfo="none">-r</parameter>,
		  показывает статистику маршрутизации.</member>
		<member><parameter class="command" moreinfo="none">-f семейство_адресов</parameter></member>
		<member> – ограничить показ статистики или адресов управляющих блоков только указанным семейством_адресов, в качестве которого можно указывать: 
		  <simplelist type="horiz" columns="2">
		    <member><emphasis>inet</emphasis></member>
		    <member>Для семейства адресов AF_INET</member>
		    <member><emphasis>unix</emphasis></member>
		    <member>Для семейства адресов AF_UNIX</member>
		</simplelist></member>
		<member><parameter class="command" moreinfo="none">-I интерфейс</parameter></member>
		<member> – выделить информацию об указанном интерфейсе в
		  отдельный столбец; по умолчанию (для третьей формы команды) используется
		  интерфейс с наибольшим объемом переданной информации с момента последней
		  перезагрузки системы.  В качестве интерфейса можно указывать любой из
		  интерфейсов, перечисленных в файле конфигурации системы, например, emd1
		  или lo0.</member>
		<member><parameter class="command" moreinfo="none">-p имя_протокола</parameter></member>
		<member> –    Ограничить показ статистики или адресов управляющих блоков только протоколом с указанным именем_протокола, например, tcp.</member>
	      </simplelist>
	      <emphasis>Пример.</emphasis> показ таблицы маршрутизации:
	      <informalexample>
		<screen format="linespecific">user@desktop ~$ netstat -r
Routing tables		  
Internet:
Destination        Gateway            Flags    Refs      Use  Netif Expire
default            19-101.local       UGS         0  1373769    rl0
localhost          localhost          UH          1      290    lo0
192.168.0          link#1             UC          0        0    dc0
192.168.19         link#3             UC          0        0    rl0
19-86.local        localhost          UGHS        0        0    lo0
19-101.local       00:0d:bc:e4:27:bf  UHLW        1        0    rl0    116

Internet6:
Destination        Gateway            Flags      Netif Expire
localhost.prov.ru  localhost.prov.ru  UH          lo0
fe80::%dc0         link#1             UC          dc0
fe80::2a0:ccff:fe3 00:a0:cc:3d:1f:bd  UHL         lo0
fe80::%rl0         link#3             UC          rl0
fe80::250:22ff:feb 00:50:22:bb:05:f1  UHL         lo0
fe80::%lo0         fe80::1%lo0        U           lo0
fe80::1%lo0        link#5             UHL         lo0
ff01::             localhost.prov.ru  U           lo0
ff02::%dc0         link#1             UC          dc0
ff02::%rl0         link#3             UC          rl0
ff02::%lo0         localhost.prov.ru  UC          lo0</screen>
			  </informalexample>
		  </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><emphasis id="def-cmd-host" xreflabel="host">host</emphasis></term>
	  <listitem>
	    <para>
	      Команда <command moreinfo="none">host</command> служит для получения доменной информации о
	      хосте: IP-адрес, MX-записи и другой информации, связанной с данным
	      символьным именем. Имя хоста указывается в качестве аргумента команды.
	    </para>
	    <para>
	      Пример работы команды:
	      <informalexample>
		<screen format="linespecific">user@desktop ~$ host yandex.ru
yandex.ru has address 213.180.204.11
yandex.ru mail is handled by 10 mx2.yandex.ru.
yandex.ru mail is handled by 0 mx1.yandex.ru.</screen>
	      </informalexample>
	    </para>
	    <para>
	      Вторым аргументом можно указать DNS-сервер, который будет использоваться при
	      получении этой информации:
	      <informalexample>
		<screen format="linespecific">user@desktop ~$ host yandex.ru ns1.aiya.ru
Using domain server:
Name: ns1.aiya.ru
Address: 85.142.20.152#53
Aliases:

yandex.ru has address 213.180.204.11
Using domain server:
Name: ns1.aiya.ru
Address: 85.142.20.152#53
Aliases:

Using domain server:
Name: ns1.aiya.ru
Address: 85.142.20.152#53
Aliases:

yandex.ru mail is handled by 0 mx1.yandex.ru.
yandex.ru mail is handled by 10 mx2.yandex.ru.</screen>
	      </informalexample>
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><emphasis id="def-cmd-tcpdump" xreflabel="tcpdump">tcpdump</emphasis></term>
	  <listitem>
	    <para>
	      Команда <command moreinfo="none">tcpdump</command> используется для мониторинга сети на
	      канальном и более высоких уровнях. Программа <quote>слушает</quote> на одним
	      или нескольких сетевых интерфейсах и выводит дамп пакетов, проходящих через
	      этот интерфейс.
	    </para>
	    <para>
	      Параметр <parameter class="command" moreinfo="none">-i</parameter> задаёт имя сетевого
	      интерфейса, на котором запускается прослушивание. При просмотре
	      захватываемых данных удобно использовать
	      ключ <parameter class="command" moreinfo="none">-l</parameter>, который буферезует вывод
	      построчно. Для этой команды также работает
	      параметр <parameter class="command" moreinfo="none">-n</parameter>, при использовании
	      которого IP-адреса не будут заменяться символьными именами хостов. Пример
	      работы команды:
	      <informalexample>
		<screen format="linespecific">desktop ~ # tcpdump -i eth0 -l -n
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth1, link-type EN10MB (Ethernet), capture size 96 bytes
12:51:07.486755 arp who-has 0.0.0.0 (00:30:48:2b:6d:6a) tell 0.0.0.0
12:51:12.486606 arp who-has 0.0.0.0 (00:30:48:2b:6d:6a) tell 0.0.0.0
12:51:14.457608 IP 192.168.5.23.56385 &gt; 194.91.250.11.443: P 3645922938:3645923156(218) ack 2092518729 win 10086
12:51:14.491343 IP 194.91.250.11.443 &gt; 192.168.5.23.56385: . ack 218 win 10720</screen>
	      </informalexample>
	    </para>
	    <para>
	      Для вывода расширенной информации о пакетах исплюзуются
	      ключи <parameter class="command" moreinfo="none">-v</parameter>
	      или <parameter class="command" moreinfo="none">-vv</parameter>.
	      <informalexample>
		<screen format="linespecific">desktop ~ # tcpdump -i eth1 -l -n -vv
tcpdump: listening on eth1, link-type EN10MB (Ethernet), capture size 96 bytes
12:57:53.043797 IP (tos 0x0, ttl  51, id 46031, offset 0, flags [DF], proto: TCP (6),
  length: 286) 194.91.250.11.5190 &gt; 192.168.5.23.38993: P 2517343058:2517343292(234)
  ack 2346573376 win 2202 &lt;nop,nop,timestamp 2713588760 497668&gt;
12:57:53.043865 IP (tos 0x0, ttl  64, id 52382, offset 0, flags [DF], proto: TCP (6),
  length: 52) 192.168.5.23.38993 &gt; 194.91.250.11.5190: ., cksum 0x1fd7 (correct),
  1:1(0) ack 234 win 11945 &lt;nop,nop,timestamp 506366 2713588760&gt;
12:57:53.401516 IP (tos 0x0, ttl  48, id 45237, offset 0, flags [DF], proto: TCP (6),
  length: 210) 194.91.250.11.443 &gt; 192.168.5.23.56385: P 2092522043:2092522213(170)
  ack 3645927446 win 10720
...</screen>
	      </informalexample>
	    </para>
	    <para>
	      Команда <command moreinfo="none">tcpdump</command> обладает очень богатым интерфейсом,
	      включающем условные выражения, по которым должны выделяться интересующие
	      пакеты. Например, можно использовать условия удалённого порта (равно 80):
	      <informalexample>
		<screen format="linespecific">desktop ~ # tcpdump -i eth1 -l -n -vv dst port 80
tcpdump: listening on eth1, link-type EN10MB (Ethernet), capture size 96 bytes
13:55:36.563959 IP (tos 0x0, ttl  64, id 3936, offset 0, flags [DF], proto: TCP (6),
  length: 60) 192.168.5.23.52348 &gt; 213.180.204.11.80: S, cksum 0x2766 (correct),
  3855548287:3855548287(0) win 5840 &lt;mss 1460,sackOK,timestamp 1372191 0,nop,wscale 2&gt;
13:55:36.592654 IP (tos 0x0, ttl  64, id 3937, offset 0, flags [DF], proto: TCP (6),
  length: 40) 192.168.5.23.52348 &gt; 213.180.204.11.80: ., cksum 0xebc5 (correct),
  3855548288:3855548288(0) ack 3869420799 win 5840
13:55:36.592731 IP (tos 0x0, ttl  64, id 3938, offset 0, flags [DF], proto: TCP (6),
  length: 627) 192.168.5.23.52348 &gt; 213.180.204.11.80: P 0:587(587) ack 1 win 5840
...</screen>
	      </informalexample>
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><emphasis id="def-cmd-nmap" xreflabel="nmap">nmap</emphasis></term>
	  <listitem>
	    <para>
	      <!-- TODO! -->
	      Команда <command moreinfo="none">nmap</command> – сетевой сканер, с помощью
	      которого можно определить уязвимость удалённых хостов. Основное назначение
	      этой программы – определение состояние портов удалённого хоста
	      (закрыты они, открыты или заблокированны). Также программа может на
	      основании собственной базы знаний определить по поведению удалённого хоста,
	      какая операционная система запущена на нём.
	    </para>
	    <para>
	    </para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
    <sect2 id="network-cmd-term">
      <title>Команды удалённого терминала</title>
      <variablelist>
	<varlistentry>
	  <term><emphasis id="def-cmd-telnet" xreflabel="telnet">telnet</emphasis></term>
	  <listitem>
	    <para>
	      <!-- TODO! -->
	      <application moreinfo="none">telnet</application> – программа сетевого терминала.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><emphasis id="def-cmd-ssh" xreflabel="ssh">ssh</emphasis></term>
	  <listitem>
	    <para>
	      <!-- TODO! -->
	      Программа <application moreinfo="none">ssh</application> является более современным и
	      защищённым аналогом программы <application moreinfo="none">telnet</application>.
	    </para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
    <sect2 id="network-cmd-firewall">
      <title>Команды по управлению сетевым экраном</title>
      <variablelist>
	<varlistentry>
	  <term><emphasis id="def-cmd-iptables" xreflabel="iptables">iptables</emphasis></term>
	  <listitem>
	    <para>
	      <!-- TODO! -->
	      Команда <command moreinfo="none">iptables</command> является интерфейсом к межсетевому
	      экрану ядра Linux. 
	    </para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
    <sect2 id="network-cmd-summary">
      <title>Резюме</title>
      <para>
	В этом разделе описываются основные команды по управлению и диагностике сети в UNIX.
      </para>
      <para><emphasis>Ключевые термины: </emphasis><xref linkend="def-cmd-ifconfig"/>, <xref linkend="def-cmd-arp"/>, <xref linkend="def-cmd-route"/>, <xref linkend="def-cmd-ping"/>, <xref linkend="def-cmd-traceroute"/>, <xref linkend="def-cmd-netstat"/>, <xref linkend="def-cmd-host"/>, <xref linkend="def-cmd-tcpdump"/>, <xref linkend="def-cmd-nmap"/>, <xref linkend="def-cmd-telnet"/>, <xref linkend="def-cmd-ssh"/>, <xref linkend="def-cmd-iptables"/></para>
    </sect2>    
    <sect2 id="network-cmd-additional">
      <title>Дополнительные материалы</title>
      <para>
	<orderedlist inheritnum="ignore" continuation="restarts">
	  <listitem>
	    Курячий Г.В. <emphasis>Операционная система UNIX</emphasis>. –
	    М.:Интуит.Ру, 2004. – 292 с.: ил.
	  </listitem>
	  <listitem>
	    Рейчардс К., Фостер-Джонсон Э. <emphasis>UNIX:
	    справочник</emphasis>. – СПб.: Питер Ком, 1999. – 384 с.:
	    ил.
	  </listitem>
	</orderedlist>
      </para>
    </sect2>    
  </sect1>
  <!-- занятие №9 (практическое занятие) -->
  <sect1 id="network-base-examples"><title>Практическое занятие. Управление сетью</title><para>
      <emphasis>Цель занятия:</emphasis> изучение инструментов конфигурирования сети в
      UNIX, включающих настроку параметров TCP/IP-сети.
    </para><para>
      <emphasis>Изучаемые команды:</emphasis> 
      <xref linkend="def-cmd-arp"/>,
      <xref linkend="def-cmd-ifconfig"/>,
      <xref linkend="def-cmd-netstat"/>,
      <xref linkend="def-cmd-ping"/>,
      <xref linkend="def-cmd-route"/>,
      <xref linkend="def-cmd-ssh"/>,
      <xref linkend="def-cmd-telnet"/>,
      <xref linkend="def-cmd-traceroute"/>
    </para><sect2 id="network-scenario-eth"><title>Сценарий: Настройка сетевого интерфейса</title><para>
	Сценарий посвящен сетевым интерфейсам – прослойке между канальным и
	сетевым уровнем в UNIX. В сценарии показано, как получать информацию о настроенных
	в системе сетевых интерфейсах и как производится их диагностика и
	конфигурирование.
      </para><para><emphasis>Начальные условия:</emphasis>
	Командная строка суперпользователя после входа в систему.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	  <para>
	    Получить сведения обо всех настроенных сетевых интерфейсах с помощью
	    команды <command moreinfo="none">ifconfig -a</command>: 
	    <informalexample>
	      <screen format="linespecific">desktop ~ # ifconfig -a
eth0      Link encap:Ethernet  HWaddr 00:0D:60:8D:42:AA  
          inet addr:192.168.1.5  Bcast:192.168.1.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:204779 errors:0 dropped:0 overruns:0 frame:0
          TX packets:107606 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:302429520 (288.4 Mb)  TX bytes:9177476 (8.7 Mb)
          Base address:0x8000 Memory:c0220000-c0240000 

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:228 errors:0 dropped:0 overruns:0 frame:0
          TX packets:228 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:17724 (17.3 Kb)  TX bytes:17724 (17.3 Kb)</screen>
	    </informalexample>		
	  </para>
	</listitem>	
	<listitem>
	  <para>
	    Проверить возможность соединения с локальной машиной с помощью
	    команды <command moreinfo="none">ping 127.0.0.1</command>.
	    <informalexample>
	      <screen format="linespecific">desktop ~ # ping 127.0.0.1
PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.052 ms
64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.051 ms
64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.055 ms</screen>
	    </informalexample>
	  </para>
	</listitem>	
	<listitem>
	  <para>
	    Перед конфигурированием интерфейса <emphasis>eth0</emphasis> необходимо
	    убедиться, что он отключен. Отключение сетевого
	    интерфейса <emphasis>eth0</emphasis> производится командой <command moreinfo="none">ifconfig
	    eth0 down</command>.
	    <informalexample>
	      <screen format="linespecific">desktop ~ # ifconfig eth0 down
desktop ~ # ifconfig -a
lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:228 errors:0 dropped:0 overruns:0 frame:0
          TX packets:228 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:17724 (17.3 Kb)  TX bytes:17724 (17.3 Kb)</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Для связи сетевого интерфейса <emphasis>eth0</emphasis> с IP-адресом
	    192.168.1.1 выполним команду <command moreinfo="none">ifconfig eth0 192.168.1.1 up</command>.
	    <informalexample>
	      <screen format="linespecific">desktop ~ # ifconfig eth0 192.168.1.1 up
desktop ~ # ifconfig -a
eth0      Link encap:Ethernet  HWaddr 00:0C:F1:2E:0E:F9
          inet addr:192.168.1.1  Bcast:192.168.1.255  Mask:255.255.255.0
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
          Interrupt:11 Base address:0x2000 Memory:c0210000-c0210fff

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:228 errors:0 dropped:0 overruns:0 frame:0
          TX packets:228 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:17724 (17.3 Kb)  TX bytes:17724 (17.3 Kb)</screen>
	    </informalexample>
	  </para>
	  <para>
	    При этом по умолчанию используется сеть класса <literal moreinfo="none">C</literal>,
	    т.е. маска сети <quote>255.255.255.0</quote>.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Для задания специфической маски подсети используется
	    параметр <parameter class="command" moreinfo="none">netmask</parameter>. Например, данная
	    команда задаёт параметры сети класса <literal moreinfo="none">A</literal>: <command moreinfo="none">ifconfig
	    eth0 10.10.1.1 netmask 255.0.0.0 up</command>.
	    <informalexample>
	      <screen format="linespecific">desktop ~ # ifconfig eth0 10.10.1.1 netmask 255.0.0.0 up
desktop ~ # ifconfig -a
eth0      Link encap:Ethernet  HWaddr 00:0C:F1:2E:0E:F9
          inet addr:10.10.1.1  Bcast:10.255.255.255  Mask:255.0.0.0
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)
          Interrupt:11 Base address:0x2000 Memory:c0210000-c0210fff

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:228 errors:0 dropped:0 overruns:0 frame:0
          TX packets:228 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:17724 (17.3 Kb)  TX bytes:17724 (17.3 Kb)</screen>
	    </informalexample>	    
	  </para>
	</listitem>
	<listitem>
	  <para>
	    С помощью команды <command moreinfo="none">arp</command> можно узнать текущую ARP-таблицу
	    операционной системы (соответствие MAC-адресов канального уровня
	    IP-адресам). Таблица автоматически поддерживается операционной системой в
	    процессе сетевого обмена.
	    <informalexample>
	      <screen format="linespecific">desktop ~ # arp
Address                  HWtype  HWaddress           Flags Mask            Iface
gate.localnet            ether   00:02:44:8F:16:B7   C                     eth0</screen>
	    </informalexample>	    
	  </para>
	</listitem>
      </orderedlist></sect2><sect2 id="network-scenario-route"><title>Сценарий: Настройка таблицы маршрутизации</title><para>
	В сценарии производится изучение и настройка таблицы маршрутизации IP. С помощью
	специальной программы производится изучение маршрута следования пакетов.
      </para><para><emphasis>Начальные условия:</emphasis>
	Командная строка суперпользователя, сетевой интерфейс настроен на статический
	IP-адрес.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	  <para>
	    Для просмотра таблицы маршрутизации воспользуемся командой <command moreinfo="none">route
	      -n</command>:
	    <informalexample>
	      <screen format="linespecific">desktop ~ # route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.0.0.0        0.0.0.0         255.0.0.0       U     0      0        0 eth0
127.0.0.0       0.0.0.0         255.0.0.0       U     0      0        0 lo
0.0.0.0         10.10.1.254     0.0.0.0         UG    0      0        0 eth0</screen>
	    </informalexample>	    
	  </para>		
	</listitem>
	<listitem>
	  <para>
	    Без использования ключа <parameter class="command" moreinfo="none">-n</parameter> для всех
	    имён будут использоваться символьные значения: <command moreinfo="none">route</command>
	    <informalexample>
	      <screen format="linespecific">desktop ~ # route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
localnet        *               255.0.0.0       U     0      0        0 eth0
loopback        *               255.0.0.0       U     0      0        0 lo
default         gate.localnet   0.0.0.0         UG    0      0        0 eth0</screen>
	    </informalexample>	    
	  </para>		
	</listitem>
	<listitem>
	  <para>
	    Для добавления новой строки в таблицу нужно воспользоваться
	    параметром <parameter class="command" moreinfo="none">add</parameter>:
	    <command moreinfo="none">route add -host 10.10.2.1 dev eth0</command>.
	    <informalexample>
	      <screen format="linespecific">desktop ~ # route add -host 10.10.2.1 dev eth0
desktop ~ # route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.10.2.1       0.0.0.0         255.255.255.255 UH    0      0        0 eth0
10.0.0.0        0.0.0.0         255.0.0.0       U     0      0        0 eth0
127.0.0.0       0.0.0.0         255.0.0.0       U     0      0        0 lo
0.0.0.0         10.10.1.254     0.0.0.0         UG    0      0        0 eth0</screen>	    
	    </informalexample>
	    Эта команда добавляет явный маршрут до отдельного хоста с указанным IP-адресом
	    через интерфейс <emphasis>eth0</emphasis>.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Аналогичным образом маршрут удаляется, используется
	    параметр <parameter class="command" moreinfo="none">del</parameter>: 
	    <command moreinfo="none">route del -host 10.10.2.1</command>.
	    <informalexample>
	      <screen format="linespecific">desktop ~ # route add -host 10.10.2.1 dev eth0
desktop ~ # route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.0.0.0        0.0.0.0         255.0.0.0       U     0      0        0 eth0
127.0.0.0       0.0.0.0         255.0.0.0       U     0      0        0 lo
0.0.0.0         10.10.1.254     0.0.0.0         UG    0      0        0 eth0</screen>	    
	    </informalexample>	    
	  </para>
	</listitem>
	<listitem>
	  <para>    
	    В качестве назначения маршрута можно указывать также целую сеть (парамеметр
	    <parameter class="command" moreinfo="none">-net</parameter>. Рассмотрим команду, которая
	    задаёт маршрут в сеть <quote>192.168.1.0</quote> через
	    шлюз <quote>10.10.1.253</quote>: 
	    <command moreinfo="none">route add -net 192.168.1.0 gw 10.10.1.253</command>.
	    <informalexample>
	      <screen format="linespecific">desktop ~ # route add -net 192.168.1.0 gw 10.10.1.253
desktop ~ # route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.1.0     10.10.1.253     255.255.255.255 UG    0      0        0 eth0
10.0.0.0        0.0.0.0         255.0.0.0       U     0      0        0 eth0
127.0.0.0       0.0.0.0         255.0.0.0       U     0      0        0 lo
0.0.0.0         10.10.1.254     0.0.0.0         UG    0      0        0 eth0</screen>	    
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Рассмотрим простой маршрут движения пакетов до хоста в Internet с помощью
	    программы <command moreinfo="none">traceroute ya.ru</command>: 
	    <informalexample>
	      <screen format="linespecific">desktop ~ # traceroute ya.ru
traceroute to ya.ru (213.180.204.8), 64 hops max, 40 byte packets
 1  10.10.1.254 (10.10.1.254)  3.418 ms  2.67 ms  0.719 ms
 2  cs7206.rinet.ru (195.54.192.28)  1.34 ms  1.378 ms  0.647 ms
 3  ix2-m9.yandex.net (193.232.244.93)  1.554 ms  1.457 ms  1.420 ms
 4  c3-vlan4.yandex.net (213.180.210.146)  2.137 ms  2.154 ms  1.842 ms
 5  ya.ru (213.180.204.8)  2.646 ms  2.183 ms 2.220 ms</screen>	    
	    </informalexample>
	  </para>
	</listitem>
      </orderedlist></sect2><sect2 id="network-scenario-dns"><title>Сценарий: Изучение службы доменных имён</title><para>
	Сценарий посвящен изучению службы доменных имён – её использованию и
	конфигурированию. 
      </para><para><emphasis>Начальные условия:</emphasis>
	Командная строка суперпользователя, сетевой интерфейс настроен на статический
	IP-адрес.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	  <para>
	    Просмотрим содержимое файла <filename moreinfo="none">/etc/hosts</filename>, содержащего имена
	    локальных хостов: <command moreinfo="none">cat /etc/hosts</command>
	    <informalexample>
	      <screen format="linespecific">desktop ~ # cat /etc/hosts
#
# hosts         This file describes a number of hostname-to-address
#               mappings for the TCP/IP subsystem.  It is mostly
#               used at boot time, when no name servers are running.
#               On small systems, this file can be used instead of a
#               "named" name server.  Just add the names, addresses
#               and any aliases to this file...
#

# Localhost
127.0.0.1       localhost

# Home LAN
10.10.1.254    gate.localnet gate
10.10.1.20     boss.localnet boss</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Проверим работоспособность DNS с помощью команды обращения к хосту в Internet
	    по имени <command moreinfo="none">ping ya.ru</command>:
	    <informalexample>
	      <screen format="linespecific">desktop ~ # ping ya.ru
PING ya.ru (213.180.204.8) 56(84) bytes of data.
64 bytes from ya.ru (213.180.204.8): icmp_seq=1 ttl=54 time=3.56 ms
64 bytes from ya.ru (213.180.204.8): icmp_seq=2 ttl=54 time=2.22 ms</screen>	    
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Для корректной работы службы доменных имен необходимо прописать используемые
	    серверы DNS в файле <filename moreinfo="none">/etc/resolv.conf</filename>. Просмотрим его
	    содержимое <command moreinfo="none">cat /etc/resolv.conf</command>:
	    <informalexample>
	      <screen format="linespecific">desktop ~ # cat /etc/resolv.conf
domain localnet
nameserver 10.10.1.17</screen>	    
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    С помощью команды <command moreinfo="none">host ya.ru</command> узнаем информацию DNS о хосте
	    в Internet:
	    <informalexample>
	      <screen format="linespecific">desktop ~ # host ya.ru
ya.ru has address 213.180.204.8
ya.ru mail is handled by 10 cmail.yandex.ru.</screen>	    
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Вторым аргументом команды <command moreinfo="none">host ya.ru ns1.yandex.ru</command> имя
	    DNS-сервера, с которого необходимо получить инормацию:
	    <informalexample>
	      <screen format="linespecific">desktop ~ # host ya.ru ns1.yandex.ru
ya.ru has address 213.180.204.8
Using domain server:
Name: ns1.yandex.ru
Address: 213.180.193.1#53
Aliases:

Using domain server:
Name: ns1.yandex.ru
Address: 213.180.193.1#53
Aliases:

ya.ru mail is handled by 10 cmail.yandex.ru.</screen>
	    </informalexample>
	  </para>
	</listitem>
      </orderedlist></sect2><sect2 id="network-scenario-diagn1"><title>Сценарий: Простая диагностика работы сети</title><para>
	Сценарий рассматривает самые простые способы диагностики работы сети.
      </para><para><emphasis>Начальные условия:</emphasis>
	Командная строка суперпользователя, сетевой интерфейс настроен на статический
	IP-адрес.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	  <para>
	    Для проверки работоспособности сетевых служб воспользуемся командой удалённого
	    терминала: <command moreinfo="none">telnet ya.ru 80</command>. В данном случае будет
	    установлено соединение с хостом в Internet по порту 80 (HTTP):
	    <informalexample>
	      <screen format="linespecific">desktop ~ # telnet ya.ru 80
Trying 213.180.204.8...
Connected to ya.ru.
Escape character is '^]'.
GET / HTTP/1.0

HTTP/1.0 200 OK
Server: thttpd/2.25b 29dec2003
Content-Type: text/html; charset=windows-1251
Date: Wed, 23 Nov 2005 05:40:33 GMT
Last-Modified: Mon, 07 Nov 2005 15:13:14 GMT
Accept-Ranges: bytes
Connection: close
Content-Length: 2005

&lt;html&gt;
&lt;head&gt;
...</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Если во время соединения с удалённым узлом ввести команду <command moreinfo="none">netstat
	      -t</command>, то можно увидеть, что состояние этого
	      соединения – <quote>ESTABLISHED</quote>:
	    <informalexample>
	      <screen format="linespecific">desktop ~ # netstat -t
Active Internet connections (servers and established)
tcp        0      0 desktop:42639           ya.ru:http              ESTABLISHED</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Информацию обо всех соединениях в системе можно получить с помощью команды
	    <command moreinfo="none">netstat -a</command>. В этом случае будет выводиться информация
	    обо всех TCP-, UDP- и локальных сокетах:
	    <informalexample>
	      <screen format="linespecific">desktop ~ # netstat -a
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 *:32769                 *:*                     LISTEN
tcp        0      0 *:32770                 *:*                     LISTEN
tcp        0      0 *:sunrpc                *:*                     LISTEN
tcp        0      0 *:ssh                   *:*                     LISTEN
tcp        0      0 desktop:42639           ya.ru:http              ESTABLISHED
udp        0      0 *:32768                 *:*
udp        0      0 *:32769                 *:*
udp        0      0 *:sunrpc                *:*
Active UNIX domain sockets (servers and established)
Proto RefCnt Flags       Type       State         I-Node Path
unix  2      [ ACC ]     STREAM     LISTENING     8344   /var/run/acpid.socket
unix  2      [ ACC ]     STREAM     LISTENING     8866   /var/run/sdp
...</screen>
	    </informalexample>    
	  </para>
	</listitem>
      </orderedlist></sect2><sect2 id="network-scenario-ssh"><title>Сценарий: Работа по удалённому терминалу</title><para>
	Сценарий рассматривает работу по удалённому сетевому терминалу с использованием
	программы ssh.
      </para><para><emphasis>Начальные условия:</emphasis>
	Командная строка суперпользователя, сетевой интерфейс настроен на статический
	IP-адрес.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	  <para>
	    С помощью команды <command moreinfo="none">ssh user@10.10.1.222</command> 
	    <informalexample>
	      <screen format="linespecific">desktop ~ # ssh user@10.10.1.222
Password:
Last login: Sat Nov 21 15:56:20 2005 from 10.10.1.5
user@remote ~ $ 
user@remote ~ $ exit</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Выполним команду <command moreinfo="none">who</command>, чтобы убедиться, что находимся на
	    удалённой машине. Для всех пользователей, работающий удалённо, указывается
	    IP-адрес. 
	    <informalexample>
	      <screen format="linespecific">user@remote ~ $ who
user     vc/1         Nov 14 14:04
user     pts/0        Nov 22 10:55 (10.10.1.5)</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Для завершение сеанса удалённого терминала нужно выйти из командной оболочки с
	    помощью команды <command moreinfo="none">exit</command>. 
	    <informalexample>
	      <screen format="linespecific">user@remote ~ $ exit
logout
Connection to 10.10.1.5 closed.
desktop ~ #</screen>
	    </informalexample>
	  </para>
	</listitem>
      </orderedlist></sect2><sect2><title>Задания для самоподготовки</title><orderedlist><listitem>
	Настройте сетевой интерфейс eth0 на сеть с адресом 192.168.77.0, состоящую из 16
	машин.
      </listitem><listitem>
	С помощью программы netstat определите какие значения
	принимают локальные порты в исходящих TCP-соединениях? В какой диапазон они
	попадают?
      </listitem></orderedlist></sect2></sect1><sect1 id="network-base-examples-scenarios"><title>Сценарии практического занятия на тему: Управление сетью</title><para><xref linkend="network-scenario-eth"/><orderedlist><listitem>ifconfig -a</listitem><listitem>ping 127.0.0.1</listitem><listitem>ifconfig
	    eth0 down</listitem><listitem>ifconfig eth0 192.168.1.1 up</listitem><listitem>ifconfig
	    eth0 10.10.1.1 netmask 255.0.0.0 up</listitem><listitem>arp</listitem></orderedlist></para><para><xref linkend="network-scenario-route"/><orderedlist><listitem>route
	      -n</listitem><listitem>route</listitem><listitem>route add -host 10.10.2.1 dev eth0</listitem><listitem>route del -host 10.10.2.1</listitem><listitem>route add -net 192.168.1.0 gw 10.10.1.253</listitem><listitem>traceroute ya.ru</listitem></orderedlist></para><para><xref linkend="network-scenario-dns"/><orderedlist><listitem>cat /etc/hosts</listitem><listitem>ping ya.ru</listitem><listitem>cat /etc/resolv.conf</listitem><listitem>host ya.ru</listitem><listitem>host ya.ru ns1.yandex.ru</listitem></orderedlist></para><para><xref linkend="network-scenario-diagn1"/><orderedlist><listitem>telnet ya.ru 80</listitem><listitem>netstat
	      -t</listitem><listitem>netstat -a</listitem></orderedlist></para><para><xref linkend="network-scenario-ssh"/><orderedlist><listitem>ssh user@10.10.1.222</listitem><listitem>who</listitem><listitem>exit</listitem></orderedlist></para></sect1>
  <!-- занятие №10 (практическое занятие) -->
  <sect1 id="network-advanced-examples"><title>Практическое занятие. Расширенная диагностика и настройка сети</title><para>
      <emphasis>Цель занятия:</emphasis> знакомство с командами анализа сетевой активности
      и хостов в TCP/IP-сети и интстументами управления межсетевым экраном в Linux.
    </para><para>
      <emphasis>Изучаемые команды:</emphasis> 
      <xref linkend="def-cmd-iptables"/>,
      <xref linkend="def-cmd-nmap"/>,
      <xref linkend="def-cmd-tcpdump"/>
    </para><sect2 id="network-scenario-tcpdump"><title>Сценарий: Сканирование локальной сети</title><para>
	Сценарий описывает возможности по просмотру сетевого трафика, проходящего через
	присутствующие в системе сетевые интерфейсы.
      </para><para><emphasis>Начальные условия:</emphasis>
	Командная строка суперпользователя после входа в систему, настроенные сетевой
	интерфейс и таблица маршрутизации.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	  <para>
	    Выведем все пакеты, проходящие через интерфейс eth0, с помощью
	    команды <command moreinfo="none">tcpdump -i eth0 -l -n</command>:
	    <informalexample>
	      <screen format="linespecific">desktop ~ # tcpdump -i eth0 -l -n
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes
14:37:23.929208 IP 192.168.0.204.32791 &gt; 192.168.0.1.53:  40133+ A? ya.ru. (23)
14:37:23.931050 IP 192.168.0.1.53 &gt; 192.168.0.204.32791:  40133- 1/0/0 A 213.180.204.8 (39)
14:37:23.932778 IP 192.168.0.204 &gt; 213.180.204.8: ICMP echo request, id 12586, seq 1, length 64
14:37:23.954412 IP 213.180.204.8 &gt; 192.168.0.204: ICMP echo reply, id 12586, seq 1, length 64
14:37:23.954784 IP 192.168.0.204.32791 &gt; 192.168.0.1.53:  29723+ PTR? 8.204.180.213.in-addr.arpa. (44)
14:37:23.956530 IP 192.168.0.1.53 &gt; 192.168.0.204.32791:  29723- 1/0/0 (63)
...</screen>
	    </informalexample>
	    Прервать выполнение команды можно
	    нажатием <keycombo moreinfo="none"><keycap moreinfo="none">Ctrl</keycap><keycap moreinfo="none">C</keycap></keycombo>.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Используем фильтр по уалённому порту для просмотра всего трафика в сети,
	    генерируемого данной машиной,
	    <command moreinfo="none">tcpdump -i eth0 -l -n src host 192.168.0.204</command>:
	    <informalexample>
	      <screen format="linespecific">desktop ~ # tcpdump -i eth0 -l -n src host 192.168.0.204
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes
14:43:02.492487 IP 192.168.0.204.32791 &gt; 192.168.0.1.53:  13524+ AAAA? yandex.ru. (27)
14:43:02.520278 IP 192.168.0.204.32791 &gt; 192.168.0.1.53:  12908+ AAAA? yandex.ru. (27)
14:43:02.522799 IP 192.168.0.204.32791 &gt; 192.168.0.1.53:  48501+ A? yandex.ru. (27)
14:43:02.525069 IP 192.168.0.204.57521 &gt; 1.0.0.0.80: S 1379873941:1379873941(0) win
   5840 &lt;mss 1460,sackOK,timestamp 2563967 0,nop,wscale 2&gt;
...</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Условия можно объёдинять, например, посмотрим все обращения по протоколу http
	    на хост <emphasis>ya.ru</emphasis>, <command moreinfo="none">tcpdump -i eth0 -l -n src host
	    192.168.0.204 and dst port 80</command>:
	    <informalexample>
	      <screen format="linespecific">desktop ~ # tcpdump -i eth0 -l -n src host 192.168.0.204 and dst port 80
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes
14:49:39.015251 IP 192.168.0.204.38172 &gt; 213.180.204.11.80: S 1789772982:1789772982(0)
   win 5840 &lt;mss 1460,sackOK,timestamp 2663083 0,nop,wscale 2&gt;
14:49:39.054551 IP 192.168.0.204.38172 &gt; 213.180.204.11.80: . ack 851659167 win 5840
14:49:39.056486 IP 192.168.0.204.38172 &gt; 213.180.204.11.80: P 0:626(626) ack 1 win 5840
14:49:39.598337 IP 192.168.0.204.38172 &gt; 213.180.204.11.80: . ack 1411 win 8460
14:49:39.604713 IP 192.168.0.204.38172 &gt; 213.180.204.11.80: . ack 2821 win 11280
14:49:39.659811 IP 192.168.0.204.38172 &gt; 213.180.204.11.80: . ack 4231 win 14100
14:49:39.784351 IP 192.168.0.204.38172 &gt; 213.180.204.11.80: . ack 5641 win 16920
14:49:39.848824 IP 192.168.0.204.38172 &gt; 213.180.204.11.80: . ack 7051 win 19740
14:49:39.966120 IP 192.168.0.204.38172 &gt; 213.180.204.11.80: F 626:626(0) ack 8118
   win 22560</screen>
	    </informalexample>
	    В данном примере можно увидеть одно последовательное TCP-соединение.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    С помощью параметров <parameter class="command" moreinfo="none">-X</parameter>
	    и <parameter class="command" moreinfo="none">-s</parameter> можно просмотреть содержимое
	    пакетов, <command moreinfo="none">tcpdump -i eth0 -l -n -X -s 2048 src host 192.168.0.204 and
	    dst port 80</command>:  
	    <informalexample>
	      <screen format="linespecific">desktop ~ # tcpdump -i eth0 -l -n -X -s 2048 src host 192.168.0.204 and dst port 80
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 2048 bytes
15:00:20.150901 IP 192.168.0.204.58273 &gt; 213.180.204.11.80: S 2473175603:2473175603(0)
   win 5840 &lt;mss 1460,sackOK,timestamp 2823357 0,nop,wscale 2&gt;
        0x0000:  4500 003c be8e 4000 4006 18f9 c0a8 00cc  E..&lt;..@.@.......
        0x0010:  d5b4 cc0b e3a1 0050 9369 aa33 0000 0000  .......P.i.3....
        0x0020:  a002 16d0 9789 0000 0204 05b4 0402 080a  ................
        0x0030:  002b 14bd 0000 0000 0103 0302            .+..........
15:00:20.172752 IP 192.168.0.204.58273 &gt; 213.180.204.11.80: . ack 2349139833 win 5840
        0x0000:  4500 0028 be8f 4000 4006 190c c0a8 00cc  E..(..@.@.......
        0x0010:  d5b4 cc0b e3a1 0050 9369 aa34 8c05 0779  .......P.i.4...y
        0x0020:  5010 16d0 80c1 0000                      P.......
15:00:20.172815 IP 192.168.0.204.58273 &gt; 213.180.204.11.80: P 0:624(624) ack 1 win 5840
        0x0000:  4500 0298 be90 4000 4006 169b c0a8 00cc  E.....@.@.......
        0x0010:  d5b4 cc0b e3a1 0050 9369 aa34 8c05 0779  .......P.i.4...y
        0x0020:  5018 16d0 023e 0000 4745 5420 2f79 616e  P....&gt;..GET./yan
        0x0030:  6473 6561 7263 683f 7465 7874 3d74 6573  dsearch?text=tes
        0x0040:  7426 7374 7970 653d 7777 7720 4854 5450  t&amp;stype=www.HTTP
        0x0050:  2f31 2e31 0d0a 486f 7374 3a20 7777 772e  /1.1..Host:.www.
        0x0060:  7961 6e64 6578 2e72 750d 0a55 7365 722d  yandex.ru..User-
        0x0070:  4167 656e 743a 204d 6f7a 696c 6c61 2f35  Agent:.Mozilla/5
        0x0080:  2e30 2028 5831 313b 2055 3b20 4c69 6e75  .0.(X11;.U;.Linu
        0x0090:  7820 6936 3836 3b20 656e 2d55 533b 2072  x.i686;.en-US;.r
        0x00a0:  763a 312e 372e 3132 2920 4765 636b 6f2f  v:1.7.12).Gecko/
...</screen>
	    </informalexample>
	  </para>
	</listitem>
      </orderedlist></sect2><sect2 id="network-scenario-nmap"><title>Сценарий: Сканирование удалённых хостов</title><para>
      </para><para><emphasis>Начальные условия:</emphasis>
	Командная строка суперпользователя после входа в систему, настроенные сетевой
	интерфейс и таблица маршрутизации.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	  <para>
	    Простое сканирование хоста можно произвести, если указать его IP-адрес в
	    аргументе команды <application moreinfo="none">nmap</application>: <command moreinfo="none">nmap
	    192.168.0.120</command>:
	    <informalexample>
	      <screen format="linespecific">user@desktop ~ $ nmap 192.168.0.120
Starting nmap 3.75 ( http://www.insecure.org/nmap/ ) at 2006-02-06 23:21 MSK
Interesting ports on gate.localnet (192.168.0.120):
(The 1658 ports scanned but not shown below are in state: closed)
PORT    STATE SERVICE
21/tcp  open  ftp
22/tcp  open  ssh
80/tcp  open  http
443/tcp open  https
873/tcp open  rsync

Nmap run completed -- 1 IP address (1 host up) scanned in 0.555 seconds</screen>
	    </informalexample>
	    При этом <application moreinfo="none">nmap</application> производит попытки соединения с
	    портами, что может быть обнаружено на стороне хоста.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Более <quote>тихим</quote> способом сканирования является SYN-сканирование,
	    когда вместо настоящего соединения посылается только SYN-пакет. Этот способ
	    сканировани доступен только скперпользователю: <command moreinfo="none">nmap -sS
	    192.168.0.120</command>
	    <informalexample>
	      <screen format="linespecific">desktop ~ # nmap -sS 192.168.0.120
Starting nmap 3.75 ( http://www.insecure.org/nmap/ ) at 2006-02-06 23:28 MSK
Interesting ports on gate.localnet (192.168.0.120):
(The 1658 ports scanned but not shown below are in state: closed)
PORT    STATE SERVICE
21/tcp  open  ftp
22/tcp  open  ssh
80/tcp  open  http
443/tcp open  https
873/tcp open  rsync
MAC Address: 00:11:2F:F4:4B:55 (Asustek Computer)

Nmap run completed -- 1 IP address (1 host up) scanned in 0.405 seconds</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Самую полную информацию о тестируемом хосте можно узнать, если использовать
	    ключи <parameter class="command" moreinfo="none">-v</parameter> (дважды)
	    и <parameter class="command" moreinfo="none">-O</parameter>, <command moreinfo="none">nmap -sS -v -v -O
	    192.168.0.120</command>: 
	    <informalexample>
	      <screen format="linespecific">desktop ~ # nmap -sS -v -v -O 192.168.0.120
Starting nmap 3.75 ( http://www.insecure.org/nmap/ ) at 2006-02-06 23:31 MSK
Initiating SYN Stealth Scan against gate.localnet (192.168.0.120) [1663 ports] at 23:31
Discovered open port 80/tcp on 192.168.0.120
Discovered open port 21/tcp on 192.168.0.120
Discovered open port 443/tcp on 192.168.0.120
Discovered open port 22/tcp on 192.168.0.120
Discovered open port 873/tcp on 192.168.0.120
The SYN Stealth Scan took 0.08s to scan 1663 total ports.
For OSScan assuming port 21 is open, 1 is closed, and neither are firewalled
Host gate.localnet (192.168.0.120) appears to be up ... good.
Interesting ports on gate.localnet (192.168.0.120):
(The 1658 ports scanned but not shown below are in state: closed)
PORT    STATE SERVICE
21/tcp  open  ftp
22/tcp  open  ssh
80/tcp  open  http
443/tcp open  https
873/tcp open  rsync
MAC Address: 00:11:2F:F4:4B:55 (Asustek Computer)
Device type: general purpose
Running: Linux 2.4.X|2.5.X|2.6.X
OS details: Linux 2.4.18 - 2.6.7
OS Fingerprint:
TSeq(Class=RI%gcd=1%SI=2E7845%IPID=Z%TS=1000HZ)
T1(Resp=Y%DF=Y%W=16A0%ACK=S++%Flags=AS%Ops=MNNTNW)
T2(Resp=N)
T3(Resp=Y%DF=Y%W=16A0%ACK=S++%Flags=AS%Ops=MNNTNW)
T4(Resp=Y%DF=Y%W=0%ACK=O%Flags=R%Ops=)
T5(Resp=Y%DF=Y%W=0%ACK=S++%Flags=AR%Ops=)
T6(Resp=Y%DF=Y%W=0%ACK=O%Flags=R%Ops=)
T7(Resp=Y%DF=Y%W=0%ACK=S++%Flags=AR%Ops=)
PU(Resp=Y%DF=N%TOS=C0%IPLEN=164%RIPTL=148%RID=E%RIPCK=E%UCK=E%ULEN=134%DAT=E)

Uptime 24.662 days (since Fri Jan 13 07:38:30 2006)
TCP Sequence Prediction: Class=random positive increments
                         Difficulty=3045445 (Good luck!)
TCP ISN Seq. Numbers: FC47E005 FC966A63 FC61563D FBC11ADD FC5E53A5 FBBE2AA2
IPID Sequence Generation: All zeros

Nmap run completed -- 1 IP address (1 host up) scanned in 2.340 seconds</screen>
	    </informalexample>
	    На основании анализа поведения системы программа делает предположение о типе
	    операционной системы, запущенной на хосте.
	  </para>
	</listitem>
      </orderedlist></sect2><sect2 id="network-scenario-iptables"><title>Сценарий: Настройка сетевого экрана</title><para>
      </para><para><emphasis>Начальные условия:</emphasis>
	Командная строка суперпользователя после входа в систему, настроенные сетевой
	интерфейс и таблица маршрутизации.
      </para><orderedlist inheritnum="ignore" continuation="restarts">
	<listitem>
	  <para>
	    Для просмотра текущей таблицы правил сетевого экрана воспользуемся командой
	    <command moreinfo="none">iptables -L</command>:
	    <informalexample>
	      <screen format="linespecific">desktop ~ # iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination</screen>
	    </informalexample>
	    Все три цепочки не содержат правил и имеют политику разрешения всех пакетов по
	    умолчанию.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Запретим весь сетевой трафик как на вход, так и на выход
	    командами <command moreinfo="none">iptables -P INPUT DROP</command>, <command moreinfo="none">iptables -P
	    OUTPUT DROP</command>:
	    <informalexample>
	      <screen format="linespecific">desktop ~ # iptables -P INPUT DROP
desktop ~ # iptables -P OUTPUT DROP
desktop ~ # iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Любой сетевой обмен (даже команда <command moreinfo="none">ping 127.0.0.1</command>) будет
	    запрещён:
	    <informalexample>
	      <screen format="linespecific">desktop ~ # ping 127.0.0.1
PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
ping: sendmsg: Operation not permitted
ping: sendmsg: Operation not permitted</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Разрешим вход и выход всем пакетам, связанным с локальным интерфейсом
	    (<emphasis>lo</emphasis>) с помощью команд:
	    <command moreinfo="none">iptables -A INPUT -i lo -j ACCEPT</command> и <command moreinfo="none">iptables -A
	      OUTPUT -o lo -j ACCEPT</command>.
	    <informalexample>
	      <screen format="linespecific">desktop ~ # iptables -A INPUT -i lo -j ACCEPT
desktop ~ # iptables -A OUTPUT -o lo -j ACCEPT
desktop ~ # ping 127.0.0.1
PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.056 ms
64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.043 ms</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Разрешим вход и выход всем пакетам, относящимся к
	    протоколу <acronym>ICMP</acronym>: 
	    <command moreinfo="none">iptables -A INPUT -p icmp -j ACCEPT</command> и <command moreinfo="none">iptables -A
	      OUTPUT -p icmp -j ACCEPT</command>.
	    <informalexample>
	      <screen format="linespecific">desktop ~ # iptables -A INPUT -p icmp -j ACCEPT
desktop ~ # iptables -A OUTPUT -p icmp -j ACCEPT</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Чтобы пропускать пакеты, относящиеся ко
	    всем <emphasis>установленным</emphasis> соединениям, добавим два правила:
	    <command moreinfo="none">iptables -A INPUT -m state --state ESTABLISHED -j ACCEPT</command> и
	    <command moreinfo="none">iptables -A OUTPUT -m state --state ESTABLISHED -j ACCEPT</command>
	    <informalexample>
	      <screen format="linespecific">desktop ~ # iptables -A INPUT -m state --state ESTABLISHED -j ACCEPT
desktop ~ # iptables -A OUTPUT -m state --state ESTABLISHED -j ACCEPT</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Теперь осталось только разрешить входящие и исходящие соединения на
	    определённые порты. Например, для исходящего доступа по
	    протоколу <acronym>HTTP</acronym> выполним <command moreinfo="none">iptables -A OUTPUT -m
	    state --state NEW -p tcp --dport 80 -j ACCEPT</command>:
	    <informalexample>
	      <screen format="linespecific">desktop ~ # iptables -A OUTPUT -m state --state NEW -p tcp --dport 80 -j ACCEPT</screen>
	    </informalexample>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    В завершение можно очистить все заданные правила с помощью <command moreinfo="none">iptables -F</command>:
	    <informalexample>
	      <screen format="linespecific">desktop ~ # iptables -F
desktop ~ # iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination</screen>
	    </informalexample>
	    Обратите внимание, что это не изменило политики по умолчанию.
	  </para>
	</listitem>
      </orderedlist></sect2><sect2><title>Задания для самоподготовки</title><orderedlist><listitem>
	Подсчитайте число устанавливаемых tcp соеднинений в сети за одну минуту.
      </listitem><listitem>
	Проследите сожержимое tcp-сессии telnet- и ssh-соединения. Сравните результаты.
      </listitem></orderedlist></sect2></sect1><sect1 id="network-advanced-examples-scenarios"><title>Сценарии практического занятия на тему: Расширенная диагностика и настройка сети</title><para><xref linkend="network-scenario-tcpdump"/><orderedlist><listitem>tcpdump -i eth0 -l -n</listitem><listitem>tcpdump -i eth0 -l -n src host 192.168.0.204</listitem><listitem>tcpdump -i eth0 -l -n src host
	    192.168.0.204 and dst port 80</listitem><listitem>tcpdump -i eth0 -l -n -X -s 2048 src host 192.168.0.204 and
	    dst port 80</listitem></orderedlist></para><para><xref linkend="network-scenario-nmap"/><orderedlist><listitem>nmap
	    192.168.0.120</listitem><listitem>nmap -sS
	    192.168.0.120</listitem><listitem>nmap -sS -v -v -O
	    192.168.0.120</listitem></orderedlist></para><para><xref linkend="network-scenario-iptables"/><orderedlist><listitem>iptables -L</listitem><listitem>iptables -P INPUT DROP</listitem><listitem>iptables -P
	    OUTPUT DROP</listitem><listitem>ping 127.0.0.1</listitem><listitem>iptables -A INPUT -i lo -j ACCEPT</listitem><listitem>iptables -A
	      OUTPUT -o lo -j ACCEPT</listitem><listitem>iptables -A INPUT -p icmp -j ACCEPT</listitem><listitem>iptables -A
	      OUTPUT -p icmp -j ACCEPT</listitem><listitem>iptables -A INPUT -m state --state ESTABLISHED -j ACCEPT</listitem><listitem>iptables -A OUTPUT -m state --state ESTABLISHED -j ACCEPT</listitem><listitem>iptables -A OUTPUT -m
	    state --state NEW -p tcp --dport 80 -j ACCEPT</listitem><listitem>iptables -F</listitem></orderedlist></para></sect1>
</chapter>

  
<chapter id="chapter-applications">
  <title>Обзор прикладных программ</title>
  <para>
    UNIX-подобные операционные системы содержат огромное количество программ для
    пользователей и администрторов системы. Часть из них запускается с графическом
    пользовательским интерфейсом (см. <xref linkend="chapter-x-windows"/>), однако
    администратору чаще приходится работать со средствами командной строки через
    сетевой терминал <application moreinfo="none">ssh</application>.
  </para>
  <para>
    Чаще всего аминистратору приходится править текстовые конфигурационные файлы, для чего
    подойдёт множество редакторов или средств командной строки. В этой лекции
    рассматриваются маленький и простой редактор <application moreinfo="none">joe</application> и более
    распространённый универсальный редактор <application moreinfo="none">vi</application>. 
  </para>
  <para>
    Другие полезные программы администратора – программы для отправления почты,
    загрузки файлов по протоколам HTTP и FTP, среди которых здесь
    рассматриваются <application moreinfo="none">sendmail</application>
    и <application moreinfo="none">wget</application>.
  </para>
  <sect1 id="apps-editors">
    <title>Текстовые редакторы</title>
    <sect2 id="apps-editors-joe">
      <title>joe: минималистский консольный редактор</title>
      <para>
	Редактор <application moreinfo="none">joe</application> обладает полноценным интерфейсом к
	консольном режиме. Для открытия файла на редактирования можно запустить команду
	<command moreinfo="none">joe имя_файла</command>. Текущая (3-я) версия редактора имеет уже
	достаточно широкие возможности – это: подсветка синтаксиса, открытие
	для редактирования нескольких файлов, запуск внутренние команды, использование
	комбинации клавиш и т.д..
      </para>
      <para>
	Интересной особенностью редактора является возможность запуска его в одном из
	<quote>стилей</quote> интерфейсов других распространённых редакторов, таких
	как <application moreinfo="none">emacs</application> или <application moreinfo="none">pico</application>. Для
	запуска рекатора в жтом случае нужно использовать команду <command moreinfo="none">jmacs</command>
	или <command moreinfo="none">jpico</command> соответственно. Далее будет рассматриваться работа
	редактора в его <quote>оригинальном</quote> стиле интерфейса.
      </para>
      <sect3 id="apps-editors-joe-screen">
	<title>Рабочий экран</title>
	<para>
	  Верхнюю строку занимает <emphasis>строка состояния</emphasis>, в которой
	  содержится следующая информация (слева-направо):
	  <itemizedlist>
	    <listitem>состояние нажатых управляющих клавиш;</listitem>
	    <listitem>имя редактируемого файла;</listitem>
	    <listitem>информация об изменениях (например, <quote>Read Only</quote>
	    или <quote>Modified</quote>);</listitem>
	    <listitem>положение курсора (строка и колонка);</listitem>
	    <listitem>текущее время;</listitem>
	    <listitem>руководство к помощи.</listitem>
	  </itemizedlist>
	  Если открыто несколько файлов, каждый из них будет сопросождаться таким
	  заголовком. 
	</para>
	<para>
	  Основной объём экрана занимает рабочая область редактирования текста. Курсор
	  может перемещаться с помощью стандартных клавиш: стрелок, <keycap moreinfo="none">PgUp</keycap>
	  / <keycap moreinfo="none">PgDn</keycap> и т.п.. 
	</para>
	<para>
	  Внизу экрана находится командная строка, в которой выводятся вопросы или
	  сообщения редактора.
	</para>
      </sect3>
      <sect3 id="apps-editors-joe-keys">
	<title>Управляющие клавиши</title>
	<para>
	  Большинство комбинаций построено на основе сочетания клавиш
	  <keycombo moreinfo="none"><keycap moreinfo="none">Ctrl</keycap><keycap moreinfo="none">K</keycap></keycombo>. Например, для
	  закрытия файла с
	  сохранением – <keycombo moreinfo="none"><keycap moreinfo="none">Ctrl</keycap> <keycap moreinfo="none">K</keycap> <keycap moreinfo="none">X</keycap></keycombo>.
	  Для отмены операций и для выхода без сохранения
	  используется <keycombo moreinfo="none"><keycap moreinfo="none">Ctrl</keycap><keycap moreinfo="none">C</keycap></keycombo>.
	</para>
	<para>
	  При
	  нажатии <keycombo moreinfo="none"><keycap moreinfo="none">Ctrl</keycap> <keycap moreinfo="none">K</keycap> <keycap moreinfo="none">H</keycap></keycombo>
	  можно получить справку по существующим сочетаниям клавиш и командам.
	</para>
	<para>
	  Для выделения областей используются
	  комбинации <keycombo moreinfo="none"><keycap moreinfo="none">Ctrl</keycap> <keycap moreinfo="none">K</keycap> <keycap moreinfo="none">B</keycap></keycombo>
	  и <keycombo moreinfo="none"><keycap moreinfo="none">Ctrl</keycap> <keycap moreinfo="none">K</keycap> <keycap moreinfo="none">K</keycap></keycombo>. Выделенный
	  текст можно копировать с помощью <keycombo moreinfo="none"><keycap moreinfo="none">Ctrl</keycap> <keycap moreinfo="none">K</keycap> <keycap moreinfo="none">С</keycap></keycombo>.
	</para>
      </sect3>
      <sect3 id="apps-editors-joe-commands">
	<title>Встроенные команды</title>
	<para>
	  Редактор <application moreinfo="none">joe</application> имеет ряд встроенных команд. При
	  этом <application moreinfo="none">joe</application> может быть запущен в качестве потокового
	  редактора, когда на стандартный вход подаётся последовательность команд по
	  изменению или созданию текста.
	</para>
	<para>
	  Для вычисления простых математических функций и выражений используется
	  встроенный калькулятор, вызываемый по
	  нажатию <keycombo moreinfo="none"><keycap moreinfo="none">ESC</keycap> <keycap moreinfo="none">M</keycap></keycombo>.
	</para>
      </sect3>
      <sect3 id="apps-editors-joe-config">
	<title>Настройка</title>
	<para>
	  Конфигурация редактора хранится в директории <filename moreinfo="none">/etc/joe/</filename> и
	  включает в себя настройки редактора, клавиш управления, подсветки синтаксиса и
	  т.д..
	</para>
      </sect3>
    </sect2>    
    <sect2 id="apps-editors-vi">
      <title>vi: универсальный текстовый редактор</title>
      <para>
	Редактор <application moreinfo="none">vi</application> является одним из самых распространённых
	текстовых редакторов для различных версий UNIX. Администратору необходимо овладеть
	хотя бы основами этого редактора, так как найти его можно практически в любой
	UNIX-системе.
      </para>
      <para>
	Как и с другими экранными редакторами, чтобы открыть файл, достаточно
	набрать <command moreinfo="none">vi имя_файла</command>.
      </para>
      <sect3 id="apps-editors-vi-modes">
	<title>Режимы работы</title>
	<para>
	  Основной особенностью редактора <application moreinfo="none">vi</application> является наличие
	  <emphasis>режимов работы</emphasis>. Основным режимом является <emphasis>режим
	  команд</emphasis>, в котором нажатия на клавиши задают команду редактору. Для
	  реактирования текста удобно применять <emphasis>режим вставки</emphasis>, в
	  котором курсор может перемещаться по редактируемому тексту, вставлять или
	  удалять символы.
	</para>
	<para>
	  В начале работы редактор находится в командном режиме, а для перехода в режим
	  вставки необходимо ввести команду <literal moreinfo="none">i</literal> (insert)
	  или <literal moreinfo="none">a</literal> (append) – для вставки текста перед и после
	  курсора соответственно. Для возвращения в командный режим используется клавиша
	  <keycap moreinfo="none">ESC</keycap>.
	</para>
	<para>
	  В командном режиме все нажатия клавиш воспринимаются как команды. Длинные
	  команды удобно набирать в <emphasis>командной строке</emphasis> – в
	  последней строке экране, куда можно перейти при нажатии <quote>:</quote>.
	</para>	
      </sect3>
      <sect3 id="apps-editors-vi-commands">
	<title>Полезные команды</title>
	<para>
	  Для простейшей работы с редакторомv <application moreinfo="none">vi</application> достаточно
	  знать несколько команд.
	</para>	
	<para>
	  Команда <command moreinfo="none">:w</command> сохраняет текущие изменения в файле, при
	  необходимости запрашивая имя файла. С помощью команды <command moreinfo="none">:q</command>
	  можно выйти из редактора, но только если файл не был изменён – иначе,
	  придётся добавлять к команде специальный
	  модификатор <quote>!</quote>: <command moreinfo="none">:q!</command> – для выхода без
	  сохранения.
	</para>	
      </sect3>
      <sect3 id="apps-editors-vi-versions">
	<title>Версии редактора</title>
	<para>
	  Существует несколько версий редактора <application moreinfo="none">vi</application>. Одним из
	  самых распространённых является
	  редактор <application moreinfo="none">vim</application>: <quote>усовершенствованный</quote>
	  <application moreinfo="none">vi</application>. Возможности его очень широки и включают
	  разнообразные режимы редактирования для разных языков, подсветку синтаксиса и
	  т.п..
	</para>	
      </sect3>
      <sect3 id="apps-editors-vi-additional">
	<title>Дополнительная информация</title>
	<para>
	  Текстовым редакторам <application moreinfo="none">vi</application>
	  и <application moreinfo="none">vim</application> посвящено множество книг и материалов в сети
	  Internet, рекомендуется обратить внимание на книги указанные в разделе
	  <xref linkend="applications-additional"/>.
	</para>	
      </sect3>
    </sect2>    
    <sect2 id="applications-additional">
      <title>Дополнительные материалы</title>
      <para>
	<orderedlist inheritnum="ignore" continuation="restarts">
	  <listitem>
	    Курячий Г.В., Маслинский К.А. <emphasis>Операционная система
	    Linux</emphasis>. – М.: Интуит.Ру, 2005. – 392 с.: ил.
	  </listitem>
	  <listitem>
	    Курячий Г.В. <emphasis>Операционная система UNIX</emphasis>. –
	    М.:Интуит.Ру, 2004. – 292 с.: ил.
	  </listitem>
	</orderedlist>
      </para>
    </sect2>    
  </sect1>
  <sect1 id="apps-net">
    <title>Программы сетевого обмена</title>
    <sect2 id="apps-net-sendmail">
      <title>sendmail: программа отправления почты</title>
      <para>
	Программа <application moreinfo="none">sendmail</application> является частью
	одноимённого <acronym>SMTP</acronym>-сервера и позволяет отправлять письма
	электронной почты. Однако, многие другие распространённые почтовые серверы или
	(например, <application moreinfo="none">Postfix</application>
	или <application moreinfo="none">ssmtp</application>) программы
	предоставляют <emphasis>совместимый</emphasis>
	с <application moreinfo="none">sendmail</application> интерфейс.
      </para>
      <para>
	По умолчанию <application moreinfo="none">sendmail</application> принимает на стандартный ввод
	тело письма вплоть до получения EOF. Таким образом, при работе в командной строке
	для завершения ввода текста необходимо
	нажать <keycombo moreinfo="none"><keycap moreinfo="none">Ctrl</keycap> <keycap moreinfo="none">D</keycap></keycombo>.
      </para>
      <para>
	Для простейшего использования программы достаточно
	ключа <parameter class="command" moreinfo="none">-t</parameter>. При этом
	программа <application moreinfo="none">sendmail</application>
	проанализирует <emphasis>заголовок</emphasis> письма и выберет из него имена и
	адреса отправителя и получателя письма.
      </para>
      <para>
	Пример отправления простого письма:
	<example>
	  <title>Отправление письма с помощью sendmail</title>
	  <screen format="linespecific">user@desktop ~ $ sendmail -t
From: Vasily Poopkin &lt;vas@pupkin.ru&gt;
To: Aleksey Fedoseev &lt;aleksey@fedoseev.net&gt;
Subject: Idea

Hi there!

I'm Vasily, and you're Aleksey.
Super-puper email body.
^D
user@desktop ~ $</screen>
	</example>
	Заголовки отделаются от тела письма пустой строкой в соответствии
	в <acronym>RFC</acronym> протокола
	<acronym>SMTP</acronym>.
      </para>
      <sect3 id="apps-net-sendmail-param">
	<title>Параметры команды</title>
	<para>
	  Также распространены следующие параметры:
	  <variablelist>
	    <varlistentry>
	      <term><parameter class="command" moreinfo="none">-F строка</parameter></term>
	      <listitem>
		задать полное имя отправителя, этот параметр игнорируется, если в письме
		был указан заголовок <quote>From:</quote>;
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter class="command" moreinfo="none">-f адрес</parameter> или
		<parameter class="command" moreinfo="none">-r адрес</parameter></term>
	      <listitem>
		использовать параметр в качестве адреса отправителя, используемого в
		обмене с <acronym>SMTP</acronym>-сервером (иногда его
		называют <quote>envelope from</quote>);
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
	<para>
	  После этих флагов можно указать список адресов получателей, на которые будут
	  отправлено данное письмо, например, следующая команда отправит письмо сразу
	  нескольким получателям:
	  <informalexample>
	    <screen format="linespecific">user@desktop ~ $ sendmail -f user@desktop.localnet alice@mails.org bob@mails.org test@fedoseev.net
From: User &lt;user@desktop.localnet&gt;

hello!

This is broadcats message.
^D</screen>
	  </informalexample>
	</para>
      </sect3>
      <para>
	Команду <command moreinfo="none">sendmail</command> можно с успехом использовать при
	автоматической генерации почтовых сообщений администратору, если на стандартный
	ввод команды <command moreinfo="none">sendmail</command> подать вывод
	команды <command moreinfo="none">cat</command> или <command moreinfo="none">echo</command>:
	<informalexample>
	  <screen format="linespecific">user@desktop ~ $ cat warning.txt | sendmail admin@localhost</screen>
	</informalexample>
      </para>
    </sect2>
    <sect2 id="apps-net-wget">
      <title>wget: консольный загрузчик файлов</title>
      <para>
	<application moreinfo="none">wget</application> – универсальная программа закачки
	файлов по протоколам <acronym>HTTP</acronym>, <acronym>HTTPS</acronym>
	и <acronym>FTP</acronym>. При работе
	с <acronym>HTML</acronym>/<acronym>XML</acronym>-файлами программа может находить
	ссылки и переходить по ним, получая полноценную локальную версию сайта.
      </para>
      <para>
	Команда имеет простой формат:
	<synopsis format="linespecific">wget [опции] URL</synopsis>
	Например, для загрузки файла достаточно выполнить команду:
	<informalexample>
	  <screen format="linespecific">user@desktop ~ $ wget ftp://mirror.aiya.ru/pub/ALTLinux/ISO/MD5SUM
--12:27:19--  ftp://mirror.aiya.ru/pub/ALTLinux/ISO/MD5SUM
           =&gt; `MD5SUM'
Распознаётся mirror.aiya.ru... 85.142.20.147
Устанавливается соединение с mirror.aiya.ru|85.142.20.147|:21... соединение установлено.
Выполняется вход под именем anonymous ... Выполнен вход в систему!
==&gt; SYST ... готово.  ==&gt; PWD ... готово.
==&gt; TYPE I ... готово.   ==&gt; CWD /pub/ALTLinux/ISO ... готово.
==&gt; PASV ... готово.  ==&gt; RETR MD5SUM ... готово.
Длина: 393 (не достоверно)

100%[=======================================================================&gt;] 393 --.--K/s

12:27:29 (429.29 KB/s) - `MD5SUM' сохранён [393]</screen>
	</informalexample>
	Загруженный файл сохраняется в локальной директории.
      </para>
      <sect3 id="apps-net-wget-param">
	<title>Параметры команды</title>
	<para>
	  Команда <command moreinfo="none">wget</command> имеет набор параметров:
	  <variablelist>
	    <varlistentry>
	      <term><parameter class="command" moreinfo="none">-b</parameter></term>
	      <listitem>
		запустить программу на заднем фоне, вывод при этом перенаправляется в
		журнал <application moreinfo="none">wget</application>;
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter class="command" moreinfo="none">-q</parameter></term>
	      <listitem>
		не выводить информацию на стандартный вывод, удобно для применения в
		скриптах; 
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter class="command" moreinfo="none">-t число</parameter></term>
	      <listitem>
		число попыток загрузки файла; 
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter class="command" moreinfo="none">-c</parameter></term>
	      <listitem>
		продолжить закачку для файлов, загруженных частично;
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><parameter class="command" moreinfo="none">-r</parameter></term>
	      <listitem>
		загружать рекурсивно – удобно применять к директориям или к
		сайтам, которые необходимо загрузить целиком.
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
	<para>	
	  Команда обладает множеством параметров, связанными как с процессом закачки, так и
	  со спецификой протоколов. Все они подробно описаны в <command moreinfo="none">man 1
	  wget</command>.
	</para>
      </sect3>
      <sect3 id="apps-net-wget-config">
	<title>Настройка</title>
	<para>
	  Команда <command moreinfo="none">wget</command> имеет немало настроек, касающихся параметров
	  доступа к хостам, использование проски-серверов и т.п.. Все они находятся в
	  файле <filename moreinfo="none">/etc/wget/wgetrc</filename> или в
	  файле <filename moreinfo="none">.wgetrc</filename> в домашней директории пользователя.
	</para>
      </sect3>
    </sect2>
  </sect1>
</chapter>

  
<chapter id="chapter-base-admin">
  <title>Базовое администрирование UNIX</title>
  <para>
    Прошлые лекции были посвящены различным особенностям архитектуры UNIX, использованию
    этой операционной системы в локальной и сетевой работе, некоторым аспектам
    администрирования системы. В этой части речь пойдет о комплексном администрировании
    UNIX-систем – об управлении службами и управлении программным обеспечением.
  </para>
  <!-- занятие № 11 (лекция) -->
  <sect1 id="base-admin-lect">
    <title>Управление службами</title>
    <para>
      В этой лекции освещяются процесс загрузки UNIX-систем и запуск системных
      служб. Некоторые их них, такие как <emphasis>планировщик заданий</emphasis>
      или <emphasis>системный журнал</emphasis>, рассматриваются более подробно.
    </para>
    <sect2 id="base-admin-lect-sysinit">
      <title>Загрузка операционной системы</title>
      <sect3 id="base-admin-lect-sysinit-stages">
	<title>Этапы загрузки системы</title>
	<para><link linkend="small-pres-6-01">Презентация 6-01: этапы загрузки системы</link></para>
	<para>
	  Загрузку операционной системы можно разделить на несколько этапов.  Начальный
	  этап загрузки не зависит от того, какая операционная система установлена на
	  компьютере, он в первую очередь связан с особенностями архитектуры используемого
	  компьютера. Затем следуют этапы загрузчиков, которые также могут не относиться к
	  определённым операционным системам, после чего инициализируется ядро
	  операционной системы и производятся специфические только для этой ОС операции.
	</para>    
	<phrase id="quest-6-1" xreflabel="Из каких этапов состоит загрузка операционной системы&#10;&#9;UNIX?"/>
	<para>
	  Рассмотрим загрузку операционной системы UNIX как следующую последовательность
	  этапов (<xref linkend="img-system-init"/>): 
	</para>
	<para>
	  <figure id="img-system-init" float="0">
	    <title>Этапы загрузки ОС UNIX</title>
	    <graphic fileref="images/system_init.png"/>
	  </figure>	
	</para>
	<para>
	  <variablelist>
	    <varlistentry>
	      <term><emphasis id="def-null-loader" xreflabel="досистемный&#10;&#9;      загрузчик">досистемный
	      загрузчик</emphasis></term>
	      <listitem>
		<para>
		 Как правило, сразу после включения питания программа
		 ПЗУ <acronym>BIOS</acronym> проводит тестирование оборудования, затем
		 запускается досистемный загрузчик.
		</para>
		<para>
		  Задача этого этапа – определить (возможно, с помощью
		  пользователя), с какого устройства будет идти загрузка, загрузить оттуда
		  специальную программу-загрузчик и запустить её. Например, выяснить, что
		  устройство для загрузки – жесткий диск, считать самый первый
		  сектор этого диска и передать управление программе, которая находится в
		  считанной области.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis id="def-first-loader" xreflabel="загрузчик первого&#10;&#9;      уровня">загрузчик первого
	      уровня</emphasis></term>
	      <listitem>
		<para> 
		  Загрузчик первого уровня занимает обычно не более одного
		  сектора в самом начале диска – в его загрузочном секторе
		  (Master Boot Record).
		</para>
		<para>
		  Ядро операционной системы имеет довольно сложную структуру –
		  а значит, и непростой способ загрузки; оно может быть довольно большим,
		  и может располагаться неизвестно где на диске, подчиняясь законам
		  файловой системы (например, состоять из нескольких частей, разбросанных
		  по диску). Учесть все это первичный загрузчик не в состоянии, поэтому
		  его задача: определить, где на диске находится <emphasis>загрузчик
		  второго уровня</emphasis>, загрузить его в память и передать ему
		  управление.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis id="def-second-loader" xreflabel="загрузчик второго&#10;&#9;      уровня">загрузчик второго
	      уровня</emphasis></term>
	      <listitem>
		<para> 
		  Вторичный загрузчик – сложная программа с интерфейсом
		  пользователя, который даёт возможность выбирать опрерационную систему
		  или параметры загрузки ядра. Загрузчик должен иметь доступ к образу
		  ядра, поэтому в него включается поддержка <emphasis>файловых
		  систем</emphasis>. 
		</para>
		<para> 
		  В любом случае вторичный загрузчик читает образ ядра в определённый
		  адрес памяти и передаёт туда управление.
		</para>
		<para>
		  Большинство операционных систем имеют собственные загрузчики первого и
		  второго уровней. Однако, существуют <emphasis>универсальные
		  загрузчики</emphasis>, например <application moreinfo="none">GRUB</application>.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>инициализация ядра операционной системы</emphasis></term>
	      <listitem>
		<para>
		  Как мы уже выяснии ранее, ядро – очень сложная программа,
		  взаимодействующая с различным оборудованием, поэтому прежде чем начать
		  работу с системой, её необходимо проинициализировать.
 		</para>
		<para>
		  Этот этап специфичен для различных операционных систем. В UNIX-подобных
		  системах при этом обычно выводится информация о загрузке ядра
		  отладочного характера.
 		</para>
		<para>
		  Первым делом ядро занимается определением параметров вычислительной
		  подсистемы компьютера: выясняет тип и быстродействие центрального
		  процессора, объем оперативной памяти, объем и структуру кэш-памяти;
		  делает предположение об архитектуре компьютера в целом и многое
		  друго.
 		</para>
		<para>
		  На следующем шаге ядро определяет состав и архитектуру всего аппаратного
		  наполнения компьютера: тип и параметры шин передачи данных и устройств
		  управления ими (контроллеров), список внешних устройств, доступных по
		  шинам, настройки этих устройств – диапазон портов
		  ввода-вывода, адрес ПЗУ, занимаемое аппаратное прерывание, номер канала
		  прямого доступа к памяти и т.п..
		</para>
		<para>
		  Ядро на основании переданного ему параметра выбирает корневой
		  раздел – файловую систему, содержащую будущий
		  каталог <filename moreinfo="none">/</filename> и его подкаталоги (для системной
		  начальной загрузки важены каталоги
		  <filename moreinfo="none">/etc</filename>, <filename moreinfo="none">/bin</filename>,
		  и <filename moreinfo="none">/sbin</filename>). Корневой
		  раздел <emphasis>монтируется</emphasis> в
		  качестве <filename moreinfo="none">/</filename>. После этого ядро запускает свой
		  первый процесс – <emphasis>init</emphasis> (по
		  умолчанию, <filename moreinfo="none">/sbin/init</filename>).
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>процесс init</emphasis></term>
	      <listitem>
		<para>
		  С этого момента операционная система обеспечивает полноценную
		  функциональность всем исполняющимся процессам. В UNIX первым запускаемым
		  процессом является init, о котором сказано в следующем разделе.
		</para>
	      </listitem>
	    </varlistentry>
	    </variablelist>
	</para>
      </sect3>
      <sect3 id="base-admin-lect-sysinit-init">
	<title>Процесс init</title>
	<para><link linkend="small-pres-6-02">Презентация 6-02: процесс init</link></para>
	<phrase id="quest-6-2" xreflabel="Какую роль выполняет процесс init в UNIX?"/>
	<para>
	  Процесс <emphasis id="def-init-proc" xreflabel="init">init</emphasis> является обычным
	  процессом операционной системы, однако он имеет некоторые особенности: его PID
	  всегда равен <literal moreinfo="none">1</literal>, и процесс этот работает всё время, пока
	  работает система.
	</para>
	<para>
	  В UNIX-системах init играет две важные роли:
	  <itemizedlist>
	    <listitem>
	      <para>
		производит инициализацию системы – как правило, для работы
		запущенного ядра не достаточно, нужно примонтировать все файловые системы,
		загрузить дополнительные драйверы устройств, запустить демоны и т.п.;
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		является родительским для всех процессов в системе – это
		является гарантией того, что в UNIX любой процесс имеет своего родителя. 
	      </para>
	      <para>
		<figure id="img-process-hierarchy-example" float="0">
		  <title>Пример иерархии процессов в UNIX</title>
		  <graphic fileref="images/process_hierarchy.png"/>
		</figure>	
	      </para>
	      <para>
		Это обеспечивается тем, что в UNIX процессы создаются с помощью
		последовательного ответвления (системный вызов <emphasis>fork</emphasis>).
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>
	<para>
	  Как правило, процесс <application moreinfo="none">init</application> запускается из исполняемого
	  файла <filename moreinfo="none">/sbin/init</filename> и является специфичным для различных
	  UNIX-систем. Рассмотрим примеры различных современных версий UNIX и их
	  классификацию с точкм зрения инициализации системы.
	</para>
      </sect3>
      <sect3 id="base-admin-lect-sysinit-unixes">
	<title>Различия загрузки UNIX-подобных систем</title>
	<para>
	  Исторически, различные версии UNIX наследовались от двух систем: оригинальной
	  UNIX компании AT&amp;T (вплоть до версии System V) и BSD UNIX, созданной в
	  университете Беркли. В них применялись различные принципы загрузки системы, так
	  что современные версии UNIX по этому критерию можно разделить на:
	  <itemizedlist>
	    <listitem>наследники System V – так называемая UNIX System Group
	    (<acronym>USG</acronym>-системы): AIX, Solaris, UnixWare, Linux (дистрибутивы
	    RedHat, Mandriva, ALT Linux);</listitem>
	    <listitem>наследники BSD: семейство BSD, Linux (Slackware);</listitem>
	    <listitem>смешанные схемы: Linux (Debian, Gentoo).</listitem>
	  </itemizedlist>
	</para>
	<sect4 id="base-admin-lect-sysinit-unixes-sysv">
	  <title>Системы, наследующие System V</title>
	  <phrase id="quest-6-3" xreflabel="Что такое уровень выполнения системы? Какие уровни&#10;&#9;  выполнения выделяют в UNIX-системах, наследующих System V?"/>
	  <para><link linkend="small-pres-6-03">Презентация 6-03: уровни выполнения системы</link></para>
	  <para>
	    Основным признаком этих систем является наличие <emphasis id="def-runlevel" xreflabel="уровень выполнения">уровня выполнения</emphasis> (run
	    level) – одного из возможных режимов работы системы. Каждый уровень
	    исполнения имеет свой номер – часть этих номеров стандартизована.
	    В любой момент времени система может находиться в одном из них –
	    изменение режима работы производится с помощью перезапуска init с указанным
	    номером. 
	  </para>
	  <variablelist>
	    <varlistentry>
	      <term><emphasis>Уровень 0</emphasis></term>
	      <listitem>
		<para>
		  <emphasis>остановка системы</emphasis> (halt) – работа
		  системы должна быть прекращена;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>Уровень 1</emphasis></term>
	      <listitem>
		<para>
		  <emphasis id="def-single-mode" xreflabel="однопользовательский режим">однопользовательский режим</emphasis>
		  работы – система инициализирует минимум служб и даёт
		  единственному пользователю (как правило, суперпользователю) без
		  проведения аутентификации командную строку. Как правило, этот режим
		  используется для восстановления системы;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>Уровень 2</emphasis></term>
	      <listitem>
		<para>
		  <emphasis>многопользовательский режим</emphasis> –
		  пользователи могут работать на разных терминалах, вход в систему с
		  процессом аутентификации;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>Уровень 3</emphasis></term>
	      <listitem>
		<para>
		  <emphasis>многопользовательский сетевой режим</emphasis> – в
		  отличие от предыдущего уровня, осуществляется настройка сети и
		  запускаются различные сетевые службы;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>Уровень 4</emphasis></term>
	      <listitem>
		<para>
		  не имеет стандартного толкования и практически не используется;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>Уровень 5</emphasis></term>
	      <listitem>
		<para>
		  <emphasis>запуск графической подсистемы</emphasis> – по
		  сравнению с уровнем 3 производится также старт графической подсистемы
		  X11 (см. <xref linkend="chapter-x-windows"/>), и вход в систему
		  осуществляется уже в графическом режиме;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>Уровень 6</emphasis></term>
	      <listitem>
		<para>
		  <emphasis>перезагрузка системы</emphasis> – при включении
		  этого режима останавливаются все запущенные программы и производится
		  перезагрузка.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	  <para>
	    Таким образом, каждый уровень системы подразумевает запуск определённого
	    набора программ, который может быть задан администратором системы. Стартовые
	    скрипты, соответствующие уровням выполнения располагаются в
	    директории <filename moreinfo="none">/etc/rc.d</filename>. 
	  </para>
	  <para>
	    На практике, в серверных системах обычно при старте системы используется 3-й
	    уровень выполнения, в домашних – 5-й.
	  </para>
	  <para>
	  </para>
	</sect4>
	<sect4 id="base-admin-lect-sysinit-unixes-bsd">
	  <title>Системы, наследующие BSD</title>
	  <para>
	    В этих системах традиционно используется <emphasis>линейная схема</emphasis>
	    загрузки. Эта схема устроена намного проще (загрузка таких систем проходит
	    намного быстрее – особенно на медленных машинах), но зато более
	    сложная в администрировании.
	  </para>
	  <para>
	    Инициализация сиситемы осуществляется единым
	    скриптом <filename moreinfo="none">/etc/rc</filename>. В этом скрипте прописаны
	    последовательные команды инициализации системы, запуска демонов и т.п.. Следом
	    за ним следует запуск скрипта <filename moreinfo="none">/etc/rc.local</filename>, который
	    служит для запуска всех <emphasis>локальных</emphasis> программ и настроек,
	    установленных системым администратором сверх дистрибутива операционной системы.
	  </para>
	  <para>
	    При обновлении отдельных программ или изменении их настроек админимтратору
	    приходится вручную править стартовые скрипты. Эти сложности привели к тому,
	    что в современные BSD-системы внедряются более легкие в администрировании
	    схемы загрузки.
	  </para>
	</sect4>
	<sect4 id="base-admin-lect-sysinit-unixes-combined">
	  <title>Системы со смешанной схемой загрузки</title>
	  <para>
	    Некоторые современные UNIX-подобные системы (в частности, многие дистрибутивы
	    Linux) предоставляют собственные схемы загрузки системы, сочетающие в себе
	    достоинства обозначенных выше схем.
	  </para>
	  <para>
	    Для примера можно рассмотреть схему, используемую в дистрибутивах Linux Debian
	    и Gentoo. Вводится понятие <emphasis>программных уровней выполнения</emphasis>
	    (software run levels) – которые могут создаваться и изменяться
	    администратором системы.
	  </para>
	  <para>
	    Каждому уровеню выполнения соответствует набор сервисов, которые будут.
	    запущены при переключении системы на этот уровень выполнения. По умолчанию,
	    используется один уровень исполнения – <emphasis>default</emphasis>.
	  </para>
	  <para>
	    Службы связаны между собой через так называемые <emphasis>зависимости</emphasis>:
	    к примеру, служба, монтирующая сетевые папки, требует наличия сконфигурированной
	    сети, а значит зависит от службы конфигурации сети. Службы конфигурации сети, в
	    свою очередь, зависит от службы, загружающей дополнительные модули ядра (напрмер,
	    драйвер сетевой карты).
	  </para>
	  <para>
	    Управление уровнями загрузки – какие программы необходимо запускать
	    на кажом из них – производится аналогично System V-системам.
	  </para>
	</sect4>
      </sect3>
      <sect3 id="base-admin-lect-sysinit-inittab">
	<title>Конфигурация запуска init</title>
	<phrase id="quest-6-4" xreflabel="Для чего служит&#10;&#9;файл /etc/inittab?"/>
	<para>
	  Конигрурация процесса init находится в
	  файле <filename moreinfo="none">/etc/inittab</filename>. Ниже приведён пример такого файла.
	</para>
	<para>
	  <example>
	    <title>Пример файла <filename moreinfo="none">/etc/inittab</filename></title>
	    <programlisting format="linespecific">
# Default runlevel.
id:3:initdefault:

# System initialization, mount local filesystems, etc.
si::sysinit:/sbin/rc sysinit

# Further system initialization, brings up the boot runlevel.
rc::bootwait:/sbin/rc boot

l0:0:wait:/sbin/rc shutdown 
l1:S1:wait:/sbin/rc single
l2:2:wait:/sbin/rc nonetwork
l3:3:wait:/sbin/rc default
l4:4:wait:/sbin/rc default
l5:5:wait:/sbin/rc default
l6:6:wait:/sbin/rc reboot

# TERMINALS
c1:12345:respawn:/sbin/agetty 38400 tty1 linux
c2:2345:respawn:/sbin/agetty 38400 tty2 linux
c3:2345:respawn:/sbin/agetty 38400 tty3 linux
c4:2345:respawn:/sbin/agetty 38400 tty4 linux
c5:2345:respawn:/sbin/agetty 38400 tty5 linux
c6:2345:respawn:/sbin/agetty 38400 tty6 linux

# What to do at the "Three Finger Salute".
ca:12345:ctrlaltdel:/sbin/shutdown -r now

# Used by /etc/init.d/xdm to control DM startup.
x:a:once:/etc/X11/startDM.sh</programlisting>
	  </example>
	</para>
	<para>
	  Основными параметрами загрузки, задаемыми в этом файле, являются:
	  <itemizedlist>
	    <listitem><para>начальный уровень загрузки (строка с initdefault) –
	    номер уровня выполения, в который переводится система при
	    старте;</para></listitem>
	    <listitem><para>скрипты для запуска уровней исполнения – для каждого
	    уровня (0 – 6) задаётся программа с аргуметами запуска, которая
	    будет запущена в случае перевода системы на один из уровней
	    выполнения;</para></listitem>
	    <listitem><para>настройки виртуальных терминалов – сколько
	    необходимо инициализировать при старте системы, какую программу для этого
	    использовать;</para></listitem>
	    <listitem><para>настройка ракции на
		нажатие <keycombo moreinfo="none"><keycap moreinfo="none">Ctrl</keycap> <keycap moreinfo="none">Alt</keycap>
		  <keycap moreinfo="none">Del</keycap></keycombo> – какую программу необходимо
		  запустить при этом;
	    </para></listitem>
	    <listitem><para>
		прочие настройки, специфичные для данной версии UNIX.
	    </para></listitem>
	  </itemizedlist>
	</para>
      </sect3>
    </sect2>
    <sect2 id="base-admin-lect-services">
      <title>Системные службы</title>
      <para><link linkend="small-pres-6-04">Презентация 6-04: системные службы</link></para>
      <phrase id="quest-6-5" xreflabel="Что такое системные службы? Как организованы системые&#10;      службы в UNIX-системах, наследующих схему загрузки UNIX System V?"/>
      <para>
	<emphasis id="def-system-service" xreflabel="системная служба">Системные
	службы</emphasis> – это программы, выполняющие в системе определённую
	функцию и, как правило, стартующие при запуске системы. Каждой системной службе
	соответствует <emphasis>стартовый скрипт</emphasis> – специальная
	программа, осуществляющая запуск демона или программы, которая и обеспечивает
	функциональность службы.
      </para>
      <para>
	Таким образом, можно построить <command moreinfo="none">дерево зависимостей</command>, и
	перезапуск одного скрипта будет приводить к перезапуску всех его потомков.
      </para>
      <sect4 id="base-admin-lect-services-startstop">
	<title>Запуск и остановка служб</title>
	<para>
	  В System V-системах стартовые скрипты находятся в
	  директории <filename moreinfo="none">/etc/init.d</filename> и принимают единственный стадартный
	  аргумент – один
	  из: <quote>start</quote>, <quote>stop</quote>, <quote>restart</quote>. Таким
	  образом, каждая служба может быть остановлена, запущена или перезапущена.
	</para>
	<para>
	  Например, для перезапуска службы системного журнала необходимо выполнить команду
	  <command moreinfo="none">/etc/init.d/syslogd restart</command>.
	  <example>
	    <title>Пример перезапуска службы</title>
	    <screen format="linespecific">desktop ~ # /etc/init.d/syslogd restart
 * Stopping syslog-ng ...                                    [ ok ]
 * Starting syslog-ng ...                                    [ ok ]  
desktop ~ #</screen>
	  </example>
	</para>
	<para>
	  Как правило, для управления службами необходимо обладать правами суперпользователя.
	</para>
      </sect4>
      <sect4 id="base-admin-lect-services-autorun">
	<title>Автоматическая загрузка служб</title>
	<phrase id="quest-6-6" xreflabel="Каким образом производится автоматический старт служб в&#10;&#9;UNIX-системах, наследующих UNIX System V?"/>
	<para>
	  Службы используются в UNIX-системах, использующих System V-подобную схему
	  загрузки системы. При этом каждому уровню выполнения соответствует набор служб,
	  запускаемых при переключении на этот уровень.
	</para>
	<para>
	  В директории <filename moreinfo="none">/etc/rc.d/</filename> можно увидеть
	  директории <filename moreinfo="none">rc0.d</filename>, <filename moreinfo="none">rc1.d</filename> и
	  т.д. – по одной на каждый уровень выполенения. В этих директориях
	  содержатся ссылки на службы, которые будут запущены или остановлены при переходе на
	  соответствующий уровень выполнения.
	</para>
	<para>
	  Особый интерес представляют имена ссылок на стартовые скрипты служб: например, 
	  <command moreinfo="none">/etc/rc.d/rc0.d/K60crond</command>
	  и <command moreinfo="none">/etc/rc.d/rc3.d/S40crond</command>, указывающие на один
	  скрипт <command moreinfo="none">/etc/init.d/crond</command> службы системного журнала. Скрипт,
	  начинающийся с <quote>K</quote> соответствует останову службы,
	  а <quote>S</quote> – запуску. Числа, следующие перед именем службы
	  задают порядок запуска скриптов в директории. Например,
	  скрипт <command moreinfo="none">/etc/rc.d/rc3.d/S34syslogd</command> будет запущен до
	  скрипта <command moreinfo="none">/etc/rc.d/rc3.d/S40crond</command>, тогда
	  как <command moreinfo="none">/etc/rc.d/rc3.d/K60crond</command>
	  до <command moreinfo="none">/etc/rc.d/rc3.d/K66syslogd</command>. Можно заметить, что сумма
	  чисел для одной службы равна <literal moreinfo="none">100</literal> – это позволяет
	  упорядочить все скрипты в порядке старта, обратном порядку завершения.
	</para>
	<para>
	  Для установления связи между службами и уровнями выполнения используется утилита
	  <application moreinfo="none">chkconfig</application>.
	</para>
      </sect4>
      <sect3 id="base-admin-lect-services-about">
	<title>Какие бывают службы</title>
	<para><link linkend="small-pres-6-05">Презентация 6-05: системные службы: примеры</link></para>
	<phrase id="quest-6-7" xreflabel="Приведите примеры служб? Какие функции выполняет каждая&#10;&#9;из них?"/>	
	<para>
	  В современных UNIX-системах существует множество служб, выполняющих самые
	  разнообразные функции. Часть служб связано с демонами, часть – с
	  настройкой каких-то элементов операционной системы. Рассмотрим примеры служб,
	  существующих в том или ином виде практически во всех UNIX-системах:
	  <variablelist>
	    <varlistentry>
	      <term><emphasis>cron</emphasis></term>
	      <listitem>
		<para>
		  системный плнировщик заданий – демон, запускающий
		  определённые программы с заданными интервалами времени
		  (подробнее см. <xref linkend="base-admin-lect-services-cron"/>);
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>syslog</emphasis></term>
	      <listitem>
		<para>
		  системный журнал – демон, организующий единый интерфейс для
		  журналирования событий в системе
		  (подробнее см. <xref linkend="base-admin-lect-logging"/>);
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>network</emphasis></term>
	      <listitem>
		<para>
		  служба инициализация сети – производит автоматическую
		  настройку интерфейсов, маршрутизации и
		  т.п. (см. <xref linkend="network-lect-ip-sysinit"/>);
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>iptables</emphasis></term>
	      <listitem>
		<para>
		  служба инициализации межсетевого экрана в Linux;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>sshd</emphasis>, <emphasis>xinetd</emphasis>,
		<emphasis>ftpd</emphasis></term>
	      <listitem>
		<para>
		  набор сетевых служб, запускающих разичные сетевые серверы (подборнее
		  см. <xref linkend="base-admin-lect-services-network"/>);
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>sendmail</emphasis></term>
	      <listitem>
		<para>
		  почтовый сервер – демон, обеспечивающий отправление и
		  доставку почты по протоколу <acronym>SMTP</acronym>;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>modules</emphasis></term>
	      <listitem>
		<para>
		  служба, загружающая и инициализирующая дополнительные модули ядра;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>local</emphasis></term>
	      <listitem>
		<para>
		  служба, которая обычно запускается в последнюю очередь и позволяет
		  администратору стартовать дополнительные программы при загрузке системы;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><emphasis>checkroot</emphasis></term>
	      <listitem>
		<para>
		  служба, инициирующая проверку корневой файловой системы (с
		  использованием утилиты, специализированной для типа файловой системы).
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
	<para>
	  Рассмотрим более подробно некоторые из этих служб.
	</para>
      </sect3>
      <sect3 id="base-admin-lect-services-cron">
	<title>Служба планирования заданий</title>
	<para><link linkend="small-pres-6-06">Презентация 6-06: служба планирования заданий</link></para>
	<para>
	  Одной из распространённых задач администрирования является запуск каких-то задач
	  в определённое время с заданной периодичностью. В UNIX этой цели служит
	  <emphasis id="def-cron" xreflabel="планировщик&#10;&#9;  заданий">планировщик
	  заданий</emphasis> <application moreinfo="none">cron</application>.
	</para>
	<para>
	  Служба пранирования заданий состоит из демона, который обычно
	  называется <application moreinfo="none">crond</application> и набора конфигурационных
	  файлов – для каждого из пользователей и общесистемного
	  <filename moreinfo="none">/etc/crontab</filename>.
	</para>	
	<sect4 id="base-admin-lect-services-cron-config">
	  <title>Конфигурация планировщика заданий</title>
	  <phrase id="quest-6-8" xreflabel="Какой самый маленький и самый большой период запуска&#10;&#9;    задачи с помощью стандартной службы планировщика cron?"/>
	  <para>
	    Каждое задание характеризуется следующими параметрами:
	    <itemizedlist>
	      <listitem>
		минуты, часы, дни, месяцы и дни недели, в которые производится запуск;
	      </listitem>
	      <listitem>	
		имя исполняемого файла задачи.
	      </listitem>      
	    </itemizedlist>
	    В файле <filename moreinfo="none">/etc/crontab</filename> эти параметры записаны следующим
	    образом:
	    <example>
	      <title>Пример файла <filename moreinfo="none">/etc/crontab</filename></title>
      	      <programlisting format="linespecific">0    * * * *      rm -f /var/spool/cron/lastrun/cron.hourly
1    3 * * *      rm -f /var/spool/cron/lastrun/cron.daily
15   4 * * 6      rm -f /var/spool/cron/lastrun/cron.weekly
30   5 1 * *      rm -f /var/spool/cron/lastrun/cron.monthly
*/10 * * * *      /usr/bin/test -x /usr/sbin/run-crons &amp;&amp; /usr/sbin/run-crons
*/5  * * * *      /usr/bin/vnstat -u
58   * * * *      rdate -ncav ptbtime1.ptb.de</programlisting>
	    </example>
	    Каждая строка – отдельная планируемая задача.  Первые пять столбцов
	    соответствуют времени старта (точное время или промежуток, через косую), а
	    последний – исполняемой команде.
	  </para>
	  <para>
	    Для изменения конфигурации планировщика можно просто отредактировать этот
	    файл и запустить команду <command moreinfo="none">crontab</command>, но лучше пользоваться
	    этой командой с
	    параметром <parameter class="command" moreinfo="none">-e</parameter>: <command moreinfo="none">crontab
	    -e</command>.
	  </para>
	  <para>
	    В данном примере файла <filename moreinfo="none">/etc/crontab</filename> представлен механизм,
	    встречающийся в современных дистрибутивах –
	    директории <filename moreinfo="none">/etc/cron.*</filename>. В них располагаются исполняемые
	    файлы скриптов, который должны быть запущены раз в день, раз в неделю и т.п..
	    При этом администратору достаточно только добавить файл в соответствующую
	    директорию.
	  </para>
	</sect4>
	<sect4 id="base-admin-lect-services-cron-run">
	  <title>Запуск программ</title>
	  <para>
	    Демон <application moreinfo="none">crond</application> в заданное время производит запуск
	    программы от имени соответствующего пользователя. Задачи
	    из <filename moreinfo="none">/etc/crontab</filename> запускаются от имени суперпользователя. 
	  </para>
	  <para>
	    Демон планировщика контролирует результат выполнения запущенной программы и в
	    случае ошибки может отправлять письмо пользователю или администратору системы.
	  </para>
	</sect4>
	<para>
	  В разных UNIX-системах существует несколько реализаций службы планирования
	  заданий (например, <application moreinfo="none">dcron</application>,
	  <application moreinfo="none">fcron</application>, <application moreinfo="none">anacron</application> и т.п.), но
	  все они реализуют описанную выше базовую функциональность.
	</para>
      </sect3>
      <sect3 id="base-admin-lect-services-network">
	<title>Сетевые службы</title>
	<para><link linkend="small-pres-6-07">Презентация 6-07: сетевые службы</link></para>
	<phrase id="quest-6-9" xreflabel="Приведите примеры сетевых служб в UNIX."/>
	<para>
	  В современных UNIX-системах существует множество сетевых служб, решающих самые
	  разные задачи. Можно выделить несколько служб, которые используются чаще всего
	  используются сетевыми администраторами.
	</para>
	<para>
	  <variablelist>
	    <varlistentry>
	      <term>Служба ssd</term>
	      <listitem>
		<para>
		  Эта служба отвечает за запуск и останов
		  демона <application moreinfo="none">sshd</application> защищённого удалённого
		  терминала. Такой сервер обычно запускается на всех машинах, для которых
		  предполагается удалённый вход пользователей или администрирование.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Служба sendmail</term>
	      <listitem>
		<para>
		  <application moreinfo="none">sendmail</application> – один из самых
		  распространённых почтовых серверов. Он реализует Internet-протоколы,
		  связанные с отправлением почты (в первую
		  очередь <acronym>SMTP</acronym>) как в рамках локальной машины, так и
		  через Internet. Даже если сервер не является почтовым,
		  служба <application moreinfo="none">sendmail</application> служит для передачи писам
		  между пользователями системы.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Служба inetd</term>
	      <listitem>
		<para>
		  <application moreinfo="none">inetd</application> (и его более развитая
		  версия <application moreinfo="none">xinetd</application>) – это супер-сервер,
		  объединяющий множество сетевых служб. По сути этот сервер выполняет роль
		  транспорта для сетевых служб: слушает на заданом порту, при входящем
		  соединении запускает новый процесс и перенаправляет стандартный ввод и
		  вывод программы в tcp-соединение. При этом правила доступа, ограничение
		  по числу параллельных соединений, журналирование и т.п. организуюся
		  демоном <application moreinfo="none">inetd</application> и настраиваются в его
		  конфигурационных файлах.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Служба nfs</term>
	      <listitem>
		<para>
		  Демон сетевой файловой системы <acronym>NFS</acronym> (Network File
		  System), которая поддерживается в большинстве UNIX-систем. 
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Служба samba</term>
	      <listitem>
		<para>
		  <application moreinfo="none">samba</application> – это набор служб по
		  организации сетевого файлового хранилища на основе
		  протокола <acronym>CIFS</acronym>, используемого в сетевых файловых
		  системах MS Windows. Широко применяется при взаимодействии UNIX-серверов
		  и клиентских машин под Windows.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Служба bind</term>
	      <listitem>
		<para>
		  <application moreinfo="none">bind</application>
		  (или <application moreinfo="none">named</application>) – самый
		  распространённый сервер доменных имён для UNIX.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
      </sect3>
    </sect2>
    <sect2 id="base-admin-lect-logging">
      <title>Мониторинг и журналирование</title>
      <para>
	Журналирование событий и их мониторинг – важнейшая задача
	администратора – не только в связи с поддержанием уровня безопаности
	сиситемы, но для анализа неисправностей. Журналирование является нормой для всех
	служб в системе и присутствует во всех версиях UNIX. Мониторинг
	пользователей – отдельная задача администрирования, реализованная в
	UNIX также на схожих с журналированием механизмах.
      </para>
      <sect3 id="base-admin-lect-logging-syslog">
	<title>Служба системного журнала</title>
	<para><link linkend="small-pres-6-08">Презентация 6-08: служба системного журнала</link></para>
	<para>
	  Служба <emphasis id="def-syslog" xreflabel="системный журнал">системного
	    журнала</emphasis> состоит из следующих компонентов:
	</para>
	<phrase id="quest-6-10" xreflabel="Из каких компонентов состоит системный журнал в UNIX?&#10;&#9;Чем обусловлено такое разделение?"/>
	<para>
	  <variablelist>
	    <varlistentry>
	      <term>Системная функция syslog</term>
	      <listitem>
		<para>
		  API системныж журналов являются частью
		  стандартов <acronym>POSIX</acronym> и содержат функции по открытию
		  журналов и добавлению сообщений в них, константы уровней и типов ошибок
		  и т.п.. Программы обычно работают с этим API, не используя специфические
		  возможности отдельно взятых демонов журналов, что обеспечивает высокий
		  уровень переносимости программы в рамках POSIX-систем.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Демон syslogd</term>
	      <listitem>
		<para>
		  Процесс, запускаемый при старте системы и реализующий функциональность
		  журналирования: получение сообщений от приложений, фильтрацию их и
		  запись в файлы журналов.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Файл конфигурации <filename moreinfo="none">/etc/syslog.conf</filename></term>
	      <listitem>
		<para>
		  Конфигурация системного журнала является специфичной для каждого демона,
		  но обычно она содержит правила, согласно которым поступающие сообщения
		  фильтруются (какие из них можно отбросить, на какие обратить внимание и
		  т.п.), и указывает, в какие файлы нужно помещать журналируемую
		  информацию. Например, для всех сообщений, связанных с электронной
		  почтой, может использоваться файл с
		  именем <filename moreinfo="none">maillog</filename>. Другим интересным решением является
		  сохранение сообщений на другой машине в сети или даже автоматический
		  вывод их на принтер.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Файлы журналов в <filename moreinfo="none">/var/log</filename></term>
	      <listitem>
		<para>
		  Обычно все файлы журналов располагаются в
		  директории <filename moreinfo="none">/var/log</filename> и её поддиректориях. 
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
	<para>
	  Каждая запись в системном журанале содержит следующие стандартные параметры:
	  <itemizedlist>
	    <listitem>
	      время события;
	    </listitem>
	    <listitem>
	      имя программы, идентификатор процесса;
	    </listitem>
	    <listitem>
	      тип программы или сообщения (например: AUTH, DAEMON, FTP и т.п.);
	    </listitem>
	    <listitem>
	      уровень критичности записи (ALERT, ERR, WARNING, INFO и т.п.);
	    </listitem>
	    <listitem>
	      текст сообщения.
	    </listitem>
	  </itemizedlist>
	</para>
	<para>
	  В конфигурационном файле по любому из этих параметров может производиться
	  фильтрация. В файлах журналов параметры сохраняются в простом текстовом
	  виде, что позволяет применять стандартные для UNIX механизмы поиска по
	  текстовым файлам (например, <command moreinfo="none">grep</command>) и упрощает процесс анализа
	  событий.
	</para>
      </sect3>      
      <sect3 id="base-admin-lect-logging-logs">
	<title>Основные системные журналы</title>
	<para><link linkend="small-pres-6-09">Презентация 6-09: основные системные службы</link></para>
	<para>
	  Во многих UNIX-системах можно увидеть файлы системных журналов в директории
	  <filename moreinfo="none">/var/log</filename> со следующими названиями:
	  <variablelist>
	    <varlistentry>
	      <term><filename moreinfo="none">authlog</filename> / <filename moreinfo="none">security</filename></term>
	      <listitem>
		этот файл хранит сообщения, связанные с аутентификацией пользователей,
		ошибками входа в систему, изменением уровня доступа и т.д (хранит в том
		числе сообщения с типом AUTH);
	      </listitem>
	    </varlistentry>	  
	    <varlistentry>
	      <term><filename moreinfo="none">daemon</filename></term>
	      <listitem>
		файл с сообщениями от системных служб (хранит сообщения с типом DAEMON);
	      </listitem>
	    </varlistentry>	  
	    <varlistentry>
	      <term><filename moreinfo="none">dmesg</filename></term>
	      <listitem>
		в Linux-системах в файле с таким именем обычно хранятся сообщения от ядра.
	      </listitem>
	    </varlistentry>	  
	    <varlistentry>
	      <term><filename moreinfo="none">maillog</filename> / <filename moreinfo="none">mail</filename></term>
	      <listitem>
		сообщения о получении и доставке писем, этот журнал обычно ведётся
		почтовым сервером (хранит в том числе сообщения с типом MAIL);
	      </listitem>
	    </varlistentry>	  
	    <varlistentry>
	      <term><filename moreinfo="none">messages</filename></term>
	      <listitem>
		в этом файле обычно хранятся все сообщения, не попавшие в другие файлы
		журналов; 
	      </listitem>
	    </varlistentry>	  
	    <varlistentry>
	      <term><filename moreinfo="none">xferlog</filename></term>
	      <listitem>
		здесь содержатся записи обо всех файлах, загруженных с данной машины
		(обычно актуально для <acronym>FTP</acronym>-серверов).
	      </listitem>
	    </varlistentry>	  
	  </variablelist>
	</para>
	<para>
	  Некоторые системные службы (такие как
	  веб-сервер <application moreinfo="none">Apache</application>) имеют свои собственные файлы
	  журналов. Располагаются они обычно в поддиректориях
	  директории <filename moreinfo="none">/var/log</filename>,
	  например <filename moreinfo="none">/var/log/apache/</filename>.
	</para>
      </sect3>      
      <sect3 id="base-admin-lect-logging-logrotate">
	<title>Ротация системных журналов</title>
	<para><link linkend="small-pres-6-10">Презентация 6-10: ротация системных журналов</link></para>
	<phrase id="quest-6-11" xreflabel="Что такое ротация системных журналов и почему она&#10;&#9;  необходима?"/>
	<para>
	  Файлы журналов преставляют собой простые текстовые файлы, которым в конец
	  добавляются новые сообщения. Как правило, администратора интересует информация о
	  событиях, произошедших не так давно относительно текущего момента –
	  искать информацию в многомегабайтном журнале за последний год не так
	  просто. Кроме того, при увеличении размеров файлов журналов они могут
	  теоретически занять все свободное место на диске, так что администратору
	  придётся очищать их время от времени.
	</para>
	<para>
	  Для решения этих проблем используется так
	  называемая <emphasis id="def-logrotation" xreflabel="ротация журналов">ротация журналов</emphasis>:
	  процесс автоматического обновления файлов журналов – удаления и
	  архивация старых файлов и создание новых.
	</para>
	<para>
	  Для каждого из файлов журнала можно задать следующее:
	  <itemizedlist>
	    <listitem>как часто производить ротацию (обновлять файл журнала);</listitem>
	    <listitem>как долго хранить старые файлы журналов;</listitem>
	    <listitem>производить ли архивацию старых файлов;</listitem>
	    <listitem>выполнять ли дополнительные действия при обновлении
	    журнала.</listitem>
	  </itemizedlist>
	</para>
	<para>
	  Журнал может обновляться по времени (например, раз в неделю или раз в месяц) или
	  по объёму (например, при достижении размера в 1 Мб). При этом старый файл
	  журнала сохраняется с именем <filename moreinfo="none">имя_журнала.0</filename>, а все
	  предыдущие версии журналов (за позапрошлую неделю и т.п.) переименовываются с
	  увеличением цифры на единицу. Например:
	  <informalexample>
	    <screen format="linespecific">desktop ~ # ls -l /var/log/authlog*
-rw-r-----  1 root  wheel   47986 Feb  6 15:56 /var/log/authlog
-rw-r-----  1 root  wheel   77783 Feb  6 03:00 /var/log/authlog.0.gz
-rw-r-----  1 root  wheel   25395 Jan 30 03:00 /var/log/authlog.1.gz
-rw-r-----  1 root  wheel   46940 Jan 23 03:00 /var/log/authlog.2.gz
-rw-r-----  1 root  wheel  166844 Jan 16 03:00 /var/log/authlog.3.gz
-rw-r-----  1 root  wheel   68078 Jan  9 03:00 /var/log/authlog.4.gz
-rw-r-----  1 root  wheel   45941 Jan  2 03:00 /var/log/authlog.5.gz
-rw-r-----  1 root  wheel   95279 Dec 26 03:00 /var/log/authlog.6.gz
-rw-r-----  1 root  wheel   34083 Dec 19 03:00 /var/log/authlog.7.gz</screen>
	  </informalexample>	
	  В данном примере журналы аутентификации хранятся в течение восьми недель, при
	  этом все старые файлы архивируются. Архивация может быть очень полезна для
	  экономии места на диске.
	</para>
	<para>
	  Некоторые приложения требуют явного оповещения при обновлении файла
	  журнала. Поэтому программы ротации обычно предоставляют возможность запуска
	  утилиы до или после проведения обновления.
	</para>
	<para>
	  В операционной системе Linux для ротации журналов используется программа
	  <application moreinfo="none">logrotate</application>. В других UNIX-системах используются
	  аналогичные, часто встроенные средства.
	</para>
      </sect3>      
      <sect3 id="base-admin-lect-logging-users">
	<title>Мониторинг пользователей</title>
	<para><link linkend="small-pres-6-11">Презентация 6-11: мониторинг пользователей</link></para>
	<phrase id="quest-6-12" xreflabel="Какие средства мониторинга действий пользователей есть&#10;&#9;в UNIX? Приведите примеры команд и связанных с ними системных журналов."/>
	<para>
	  Журналирование входа пользователей в систему ведётся вне службы системного
	  журнала, однако в директории <filename moreinfo="none">/var/log</filename> есть несколько файлов,
	  непосредственно связанных с мониторингом пользователей:
	  <variablelist>
	    <varlistentry>
	      <term><filename moreinfo="none">wtmp</filename></term>
	      <listitem>
		Хранит информацию обо всех сеансах работы пользователя. Для просмотра
		информации из этого файла можно воспользоваться
		командой <command moreinfo="none">last</command>.
	      </listitem>
	    </varlistentry>	  
	    <varlistentry>
	      <term><filename moreinfo="none">lastlog</filename></term>
	      <listitem>
		Для каждого из пользователей хранится время последнего входа в систему
		вместе с именем соответствующего терминала (и IP-адреса в случае сетевого
		входа в систему). Содержимое этого файла можно посмотреть с помощью
		команды <command moreinfo="none">lastlog</command>. Обычно после входа пользователя в
		систему ему выводится информация из этого файла.
	      </listitem>
	    </varlistentry>	  
	    <varlistentry>
	      <term><filename moreinfo="none">faillog</filename></term>
	      <listitem>
		Для каждого пользователя хранит информацию о последней неудачной попытке
		входа в систему. Содержимое этого файла можно посмотреть с помощью
		команды <command moreinfo="none">faillog</command>.
	      </listitem>
	    </varlistentry>	  
	  </variablelist>
	</para>
	<para>
	  Все эти файлы имеют собственный двоичный формат, но также как и обычные файлы
	  журналов подвергаются ротации.
	</para>
      </sect3>      
    </sect2>
    <sect2 id="base-admin-lect-summary">
      <title>Резюме</title>
      <para><link linkend="small-pres-6-12">Презентация 6-12: резюме</link></para>
      <para>
	Загрузка компьютера проходит в несколько этапов, часть из которых не зависит от
	установленной на машине операционной системы. Основным отличием операционная
	системы UNIX является запуск процесса init для инициализации системы.
      </para>
      <para>
	Конкретика работы процесса init зависит от версии UNIX. Среди разновидностей init
	UNIX-систем выделяют два крупных класса, производных соответственно от AT&amp;T
	System V и BSD UNIX.
      </para>
      <para>
	Программы, запускаемые при старте системы, удобно представлять в виде системных
	служб. Службы могут соответствовать демонам, которые стартуют вместе с
	системой. Выделяют уровни загрузки системы, на каждом из которых существует свой
	набор запускаемых служб.
      </para>
      <para>
	Среди основных служб можно выделить: службу планировщика (cron), различные сетевые
	службы, слуюжу системного журнала.
      </para>
      <para>
	В UNIX работа с системными журналами стандартизована: заданы типы и уровней
	ошибок, расположение файлов журналов и т.п.. Большое значение при
	администрировании имеет ротация системных журналов.
      </para>
      <para><emphasis>Ключевые термины: </emphasis><xref linkend="def-null-loader"/>, <xref linkend="def-first-loader"/>, <xref linkend="def-second-loader"/>, <xref linkend="def-init-proc"/>, <xref linkend="def-runlevel"/>, <xref linkend="def-single-mode"/>, <xref linkend="def-system-service"/>, <xref linkend="def-cron"/>, <xref linkend="def-syslog"/>, <xref linkend="def-logrotation"/></para>
    </sect2>    
    <sect2 id="base-admin-lect-additional">
      <title>Дополнительные материалы</title>
      <para>
	<orderedlist inheritnum="ignore" continuation="restarts">
	  <listitem>
	    Курячий Г.В. <emphasis>Операционная система UNIX</emphasis>. –
	    М.: Интуит.Ру, 2004. – 292 с.: ил.
	  </listitem>
	</orderedlist>
      </para>
    </sect2>    
    <sect2 id="base-admin-lect-questions"><title>Вопросы</title><para><orderedlist><listitem><xref linkend="quest-6-1"/></listitem><listitem><xref linkend="quest-6-2"/></listitem><listitem><xref linkend="quest-6-3"/></listitem><listitem><xref linkend="quest-6-4"/></listitem><listitem><xref linkend="quest-6-5"/></listitem><listitem><xref linkend="quest-6-6"/></listitem><listitem><xref linkend="quest-6-7"/></listitem><listitem><xref linkend="quest-6-8"/></listitem><listitem><xref linkend="quest-6-9"/></listitem><listitem><xref linkend="quest-6-10"/></listitem><listitem><xref linkend="quest-6-11"/></listitem><listitem><xref linkend="quest-6-12"/></listitem></orderedlist></para></sect2>
    <sect2 id="base-admin-lect-presentaion"><title>Презентация</title><para><figure id="small-pres-6-01" float="0"><title>Презентация 6-01: этапы загрузки системы</title><graphic fileref="pres/small-lect6-01.png"/></figure></para><para><figure id="small-pres-6-02" float="0"><title>Презентация 6-02: процесс init</title><graphic fileref="pres/small-lect6-02.png"/></figure></para><para><figure id="small-pres-6-03" float="0"><title>Презентация 6-03: уровни выполнения системы</title><graphic fileref="pres/small-lect6-03.png"/></figure></para><para><figure id="small-pres-6-04" float="0"><title>Презентация 6-04: системные службы</title><graphic fileref="pres/small-lect6-04.png"/></figure></para><para><figure id="small-pres-6-05" float="0"><title>Презентация 6-05: системные службы: примеры</title><graphic fileref="pres/small-lect6-05.png"/></figure></para><para><figure id="small-pres-6-06" float="0"><title>Презентация 6-06: служба планирования заданий</title><graphic fileref="pres/small-lect6-06.png"/></figure></para><para><figure id="small-pres-6-07" float="0"><title>Презентация 6-07: сетевые службы</title><graphic fileref="pres/small-lect6-07.png"/></figure></para><para><figure id="small-pres-6-08" float="0"><title>Презентация 6-08: служба системного журнала</title><graphic fileref="pres/small-lect6-08.png"/></figure></para><para><figure id="small-pres-6-09" float="0"><title>Презентация 6-09: основные системные службы</title><graphic fileref="pres/small-lect6-09.png"/></figure></para><para><figure id="small-pres-6-10" float="0"><title>Презентация 6-10: ротация системных журналов</title><graphic fileref="pres/small-lect6-10.png"/></figure></para><para><figure id="small-pres-6-11" float="0"><title>Презентация 6-11: мониторинг пользователей</title><graphic fileref="pres/small-lect6-11.png"/></figure></para><para><figure id="small-pres-6-12" float="0"><title>Презентация 6-12: резюме</title><graphic fileref="pres/small-lect6-12.png"/></figure></para></sect2>
  </sect1>
<!-- TODO
  <sect1 id="base-admin-cmd">
    <title>Методические указания по командам управления службами и журналами</title>
    <sect2 id="base-admin-cmd-system">
      <title>Команды по управлению системой</title>
      <variablelist>
	<varlistentry>
	  <term><definition id="def-cmd-init">init</definition></term>
	  <listitem>
	    <para>
	      
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><definition id="def-cmd-shutdown">shutdown</definition></term>
	  <listitem>
	    <para>
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><definition id="def-cmd-reboot">reboot</definition></term>
	  <listitem>
	    <para>
	    </para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
    <sect2 id="base-admin-cmd-services">
      <title>Команды по управлению службами</title>
      <variablelist>
	<varlistentry>
	  <term><definition id="def-cmd-crontab">crontab</definition></term>
	  <listitem>
	    <para>
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><definition id="def-cmd-service">service</definition></term>
	  <listitem>
	    <para>
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><definition id="def-cmd-chkconfig">chkconfig</definition></term>
	  <listitem>
	    <para>
	    </para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
    <sect2 id="base-admin-cmd-users">
      <title>Команды по мониторингу пользователей</title>
      <variablelist>
	<varlistentry>
	  <term><definition id="def-cmd-last">last</definition></term>
	  <listitem>
	    <para>
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><definition id="def-cmd-lastlog">lastlog</definition></term>
	  <listitem>
	    <para>
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><definition id="def-cmd-faillog">faillog</definition></term>
	  <listitem>
	    <para>
	    </para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
    <sect2 id="base-admin-cmd-summary">
      <title>Резюме</title>
      <para>
	В данном разделе рассматриваются команды по работе со службами и системными
	журналами.
      </para>
      <list-of-definitions/>
    </sect2>    
    <sect2 id="base-admin-cmd-additional">
      <title>Дополнительные материалы</title>
      <para>
	<orderedlist>
	  <listitem>
	    Курячий Г.В. <emphasis>Операционная система UNIX</emphasis>.&nbsp;&ndash;
	    М.:Интуит.Ру, 2004.&nbsp;&ndash; 292 с.: ил.
	  </listitem>
	</orderedlist>
      </para>
    </sect2>    
  </sect1> -->
  <!-- занятие №12 (практическое занятие) 
  <sect1 id="base-admin-examples">
    <title>Практическое занятие по управлению службами</title>
    <scenario id="base-admin-scenario-init">
      <title></title>
      <scenario-intro>
      </scenario-intro>
      <scenario-start>
      </scenario-start>
      <orderedlist>
	<listitem>
	  <para>
	  </para>
	</listitem>
      </orderedlist>
    </scenario>  
    <sect2>
      <title>Задания для самоподготовки</title>
      <list-of-practices/>
    </sect2>
  </sect1>  
  <sect1 id="base-admin-examples-short">
    <title>Сценарии практического занятия на тему <quote>Управление службами</quote></title>
  </sect1> -->
  <!-- занятие № 11 (лекция) -->
<!-- TODO
  <sect1 id="base-admin-software-lect">
    <title>Управление программным обеспечением</title>
    <sect2 id="base-admin-software-lect-additional">
      <title>Дополнительные материалы</title>
      <para>
	<orderedlist>
	  <listitem>
	    Курячий Г.В., Маслинский К.А. <emphasis>Операционная система
	      Linux</emphasis>.&nbsp;&ndash; М.: Интуит.Ру, 2005.&nbsp;&ndash; 392 с.: ил.
	  </listitem>
	</orderedlist>
      </para>
    </sect2>    
    <sect2 id="base-admin-software-lect-questions">
      <title>Вопросы</title>
      <list-of-questions/>
    </sect2>
    <sect2 id="base-admin-software-lect-presentaion">
      <title>Презентация</title>
      <small-presentation/>
    </sect2>
  </sect1> -->
  <!-- занятие №12 (практическое занятие) -->
<!-- TODO
  <sect1 id="base-admin-software-examples">
    <title>Практическое занятие по управлению программным обеспечением</title>
    <scenario id="base-admin-software-scenario-init">
      <title></title>
      <scenario-intro>
      </scenario-intro>
      <scenario-start>
      </scenario-start>
      <orderedlist>
	<listitem>
	  <para>
	  </para>
	</listitem>
      </orderedlist>
    </scenario>  
    <sect2>
      <title>Задания для самоподготовки</title>
      <list-of-practices/>
    </sect2>
  </sect1>  
  <sect1 id="base-admin-software-examples-short">
    <title>Сценарии практического занятия на тему <quote>Управление программным
    обеспечением</quote></title>
  </sect1> -->
</chapter>

<!--  &chapter-services;-->
  
<chapter id="chapter-x-windows">
  <title>Графическая подсистема UNIX</title>
  <para>
    <!-- TODO! -->
    К сожалению, эта тема выходит за рамки лекций. Однако, она будет наполнена через
    неопределённое время.
  </para>
</chapter>

  
<chapter id="chapter-final">
  <title>Заключение</title>
  <para>
    Этот курс является базовым и во многом ознакомительным. Искусство администрирования
    требует не только знаний, но и опыта. Если Вам интересно продолжить изучение UNIX
    советую обратиться к любой из рекомендуемых по ходу лекций книг, но прежде установите
    себе Linux или любую другую открытую версию UNIX. 
  </para>
  <para>
    Удачи в освоении! Ждите более полной версии лекций.
  </para>
</chapter>
<appendix>
  <title>Список вопросов</title>
  <para><orderedlist><listitem><xref linkend="quest-1-1"/></listitem><listitem><xref linkend="quest-1-2"/></listitem><listitem><xref linkend="quest-1-3"/></listitem><listitem><xref linkend="quest-2-1"/></listitem><listitem><xref linkend="quest-2-2"/></listitem><listitem><xref linkend="quest-2-3"/></listitem><listitem><xref linkend="quest-2-4"/></listitem><listitem><xref linkend="quest-2-5"/></listitem><listitem><xref linkend="quest-2-6"/></listitem><listitem><xref linkend="quest-2-7"/></listitem><listitem><xref linkend="quest-2-8"/></listitem><listitem><xref linkend="quest-2-9"/></listitem><listitem><xref linkend="quest-2-10"/></listitem><listitem><xref linkend="quest-3-1"/></listitem><listitem><xref linkend="quest-3-2"/></listitem><listitem><xref linkend="quest-3-3"/></listitem><listitem><xref linkend="quest-3-4"/></listitem><listitem><xref linkend="quest-3-5"/></listitem><listitem><xref linkend="quest-3-6"/></listitem><listitem><xref linkend="quest-4-1"/></listitem><listitem><xref linkend="quest-4-2"/></listitem><listitem><xref linkend="quest-4-3"/></listitem><listitem><xref linkend="quest-4-4"/></listitem><listitem><xref linkend="quest-4-5"/></listitem><listitem><xref linkend="quest-4-6"/></listitem><listitem><xref linkend="quest-4-7"/></listitem><listitem><xref linkend="quest-5-1"/></listitem><listitem><xref linkend="quest-5-2"/></listitem><listitem><xref linkend="quest-5-3"/></listitem><listitem><xref linkend="quest-5-4"/></listitem><listitem><xref linkend="quest-5-5"/></listitem><listitem><xref linkend="quest-6-1"/></listitem><listitem><xref linkend="quest-6-2"/></listitem><listitem><xref linkend="quest-6-3"/></listitem><listitem><xref linkend="quest-6-4"/></listitem><listitem><xref linkend="quest-6-5"/></listitem><listitem><xref linkend="quest-6-6"/></listitem><listitem><xref linkend="quest-6-7"/></listitem><listitem><xref linkend="quest-6-8"/></listitem><listitem><xref linkend="quest-6-9"/></listitem><listitem><xref linkend="quest-6-10"/></listitem><listitem><xref linkend="quest-6-11"/></listitem><listitem><xref linkend="quest-6-12"/></listitem></orderedlist></para>
</appendix>
<appendix>
  <title>Список заданий для самоподготовки</title>
  <orderedlist><listitem>
	Создайте каталог test1 в домашней директории. Сравните время
	создания системных каталогов /bin, /tmp
	с каталогом test1.
      </listitem><listitem>
	Скопируйте файл /bin/ls в локальную директорию. Посмотрите
	атрибуты этого файла. Попробуйте запустить его.
      </listitem><listitem>
	Создайте в локальной директории символическую ссылку tmplnk
	на директорию /tmp. Скопируйте несколько файлов в
	директрию tmplnk.
      </listitem><listitem>
	Сравните файлы /dev/tty1
	и /dev/hda1. Какой тип они имеют? Чем они отличаются?
      </listitem><listitem>
	Найдите все файлы в системе, которые были модифицированы не более суток назад.
      </listitem><listitem>
	С помощью одной команды найдите все файлы с расширением .html в
	директории /usr и скопируйте их в локальную
	папку htmls.
      </listitem><listitem>
	Создайте архив директории /etc и узнайте его
	размер. Попробуйте создать сжатый архив той же папки. Сравните степень
	сжатия gzip и bzip2 на этом
	примере.
      </listitem><listitem>
	Создайте текстовый файл a.txt из десяти строк. Узнайте его
	размер. Создайте новый файл, содержащий в себе файл a.txt
	четыре раза.
      </listitem><listitem>
	С помощью одной команды найдите все файлы с расширением .txt в
	директории /usr и объедините их в один большой
	файл big.txt.
      </listitem><listitem>
	Получите с помощью одной команды файл, содержащий все числовые идентификаторы
	пользователей, зарегистрированных в ситсеме.
      </listitem><listitem>
	Получите с помощью одной команды строки с 5-ой по 8-ю в
	файле /proc/cpuinfo, содержащем информацию о процессоре.
      </listitem><listitem>
	Придумайте регулярное выражение, соответствующее URL с использованием
	протокола http. Найдите все строки, содержащие такие URL в
	файлах директории /etc.
      </listitem><listitem>
	С помощью одной команды найдите все файлы с расширениями .txt
	или .html в директории /usr, в которых
	содержится слово user.
      </listitem><listitem>
	Сравните время создания корневой директории с текущим временем системы.
      </listitem><listitem>
	Получите список всех типов файловых систем, примонтированных в настоящий
	момент. Какой тип имеет корневая файловая система?
      </listitem><listitem>
	Найдите три процесса, использующих самый большой объём памяти. Какой процент
	памят они потребляют от общего объёма?
      </listitem><listitem>
	Получите иерархию родительских процессов для текущей командной оболочки.
      </listitem><listitem>
	Найдите, в каком файле в директории /proc хранится информация
	о системной памяти.
      </listitem><listitem>
	С помощью сигнала остановки процесса и команды bg
	запустите три параллелльных процесса архивации
	директории /etc, /home
	и /tmp.
      </listitem><listitem>
	Выясните, чем отличается реакция операционной системы (выводимое сообщение) на
	различные ошибки аутентификации (например, неправильный пользователь, неверный
	пароль и т.д.).
      </listitem><listitem>
	Сравните права доступа к директориям /bin
	и /tmp. Какие операции сможет совершать в них простой
	пользователь?
      </listitem><listitem>
	Создайте текстовый файл и задайте права на него таким образом, чтобы он мог
	просматриваться только владельцем и никем не мог редактироваться. 
      </listitem><listitem>
	Что смогут делать другие пользователями с файлами в домашней директории
	пользователя, если он задаст всем остальным пользователям право на запись в
	директорию, но удалит право исполнения на неё?
      </listitem><listitem>
	Найдите все исполняемые файлы с установленным suid-битом.
      </listitem><listitem>
	Получите имена всех пользователей системы, у которых в качестве командной оболочки
	используется программа /bin/false.
      </listitem><listitem>
	Настройте сетевой интерфейс eth0 на сеть с адресом 192.168.77.0, состоящую из 16
	машин.
      </listitem><listitem>
	С помощью программы netstat определите какие значения
	принимают локальные порты в исходящих TCP-соединениях? В какой диапазон они
	попадают?
      </listitem><listitem>
	Подсчитайте число устанавливаемых tcp соеднинений в сети за одну минуту.
      </listitem><listitem>
	Проследите сожержимое tcp-сессии telnet- и ssh-соединения. Сравните результаты.
      </listitem></orderedlist>
</appendix>
<!-- TODO
<appendix>
  <title>Среда для практических занятий и самоподготовки</title>
  <para>
  </para>
</appendix> -->

</book>
