<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
	  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [

	  <!ENTITY % CommonEntities PUBLIC
		   "-//IU7 LUG//ENTITIES Common Documentation//RU"
		   "common.ent">
	  %CommonEntities;
	  
	  <!ENTITY BASEIMAGES "images/">

]>

  <!-- занятие №6 (лекция) -->
  <sect1 id="security-lect">
    <title>Введение в безопасность UNIX</title>

    <para>
      Поскольку ОС UNIX с самого своего рождения задумывалась как многопользовательская
      операционная система, в ней всегда была актуальна задача разделения доступа
      различных пользователей к файлам файловой системы. Схема
      разграничения прав доступа, примененная в ОС UNIX, сочетает
      простоту и значительную гибкость, благодаря чему она 
      стала фактическим стандартом современных многопользовательских операционных систем.
    </para>
    
    <sect2 id="security-lect-basis">
      <title>Основы информационной безопасности</title>
      <presentation number="5-01" name="информационная безопасность"/>
      <para>
	<definition id="def-inf-security" orig="информационная
	безопасность">Информационная безопасность</definition>&nbsp;&mdash; меры по защите
	информации от неавторизованного доступа, разрушения, модификации, раскрытия и
	задержек в доступе. Основой информационной безопасности любой организации является
	<emphasis>политика безопасности</emphasis>.
      </para>
      <sect3 id="security-lect-basis-secpol">
	<title>Политика безопасности</title>
	<para>
	  <definition id="def-security-policy" orig="политика безопасности">Политика
	    безопасности</definition>&nbsp;&mdash; это набор законов, правил и норм
	    поведения, определяющих, как организация обрабатывает, защищает и
	    распространяет информацию. Это активный компонент защиты, который включает в
	    себя анализ возможных угроз и выбор мер противодействия.
	</para>
	<question id="quest-5-1">Чем отличаются номинальный и действительный субъект? Как
	они соотносятся с объектом безопасности? Что представляют собой субъект и объект
	безопасности в UNIX?</question>	
	<para>
	  Важным элементом политики безопасности является управление доступом: ограничение
	  или исключение несанкционированного доступа к информации и программным
	  средствам. При этом используются два основных
	  понятия: <emphasis>объект</emphasis> и <emphasis>субъект</emphasis>
	  системы. <definition id="def-sec-object" orig="объект">Объектом</definition>
	  системы мы будем называть любой её идентифицируемый ресурс (например, файл или
	  устройство). <definition id="def-access" orig="доступ">Доступом</definition> к
	  объекту системы&nbsp;&mdash; некоторую заданную в ней операцию над этим объектом
	  (скажем, чтение или запись). <definition id="def-real-subject"
	  orig="действительный субъект">Действительным субъектом</definition> системы
	  назовем любую сущность, способную выполнять действия над объектами (имеющую к
	  ним доступ). Действительному субъекту системы соответствует некоторая
	  абстракция, на основании которой принимается решение о предоставлении доступа к
	  объекту или об отказе в доступе. Такая абстракция
	  называется <definition id="def-nominal-subject" orig="номинальный
	  субъект">номинальным субъектом</definition>. Например, студент МГТУ&nbsp;&mdash;
	  действительный субъект, его пропуск в МГТУ&nbsp;&mdash; номинальный. Другим
	  примером может служить злоумышленник, прокравшийся в секретную лабораторию с
	  украденной картой доступа&nbsp;&mdash; он является действительным субъектом, а
	  карта&nbsp;&mdash; номинальным (см. <xref linkend="img-object-subject"/>).
	</para>
	<para>
	  <figure id="img-object-subject">
	    <title>Объект и субъект безопасности</title>
	    <graphic fileref="&BASEIMAGES;object-subject.png"/>
	  </figure>	
	</para>
	<presentation number="5-02" name="политика безопасности"/>
	<question id="quest-5-2">Что такое политика безопасности? Какие требования
	выдвигаются по отношению к ней?</question>
	<para>
	  <emphasis>Политика безопасности</emphasis> должна
	  быть <emphasis>полной</emphasis>, <emphasis>непротиворечивой</emphasis> и
	  рассматривать <emphasis>все возможности</emphasis> доступа субъектов системы к
	  её объектам. Только соблюдение всех трех принципов гарантирует, что нарушить
	  установленные правила (например, получить несанкционированный доступ к объекту)
	  системными средствами невозможно. Если же предполагаемый злоумышленник
	  воспользовался каким-нибудь внесистемным средством и смог получить статус
	  номинального субъекта, к которому он не имеет отношения (например, подглядел
	  чужой пароль и работает под чужим именем), никаких гарантий быть не может.
	</para>
	<para>
	  Полнота политики безопасности означает, что в ней должны быть отражены все
	  существующие ограничения доступа. Непротиворечивость заключается в том, что
	  решение об отказе или предоставлении доступа конкретного субъекта к конкретному
	  объекту не должно зависеть от того, какими путями система к нему
	  приходит. Третье требование, называемое также <emphasis>отсутствием
	  недокументированных возможностей</emphasis>, должно гарантировать нам, что
	  доступ не может быть осуществлен иначе как описанным в политике безопасности
	  способом.
	</para>
	<para>
	  Политика безопасности включает в себя технические, организационные и правовые
	  аспекты, в рамках этих лекций рассматривается только технический аспект.
	</para>
      </sect3>
      <sect3 id="security-lect-basis-access">
	<title>Управление доступом</title>
	<presentation number="5-03" name="управление доступом"/>
	<question id="quest-5-3">Какие существуют наиболее распространённые схемы доступа?
	В чём заключаются основные отличия между ними? Какая схема доступа используется в
	UNIX?</question>
	<para>
	  Существует несколько схем управления доступом,
	  называемых <definition id="def-access-model" orig="модель доступа">моделями
	  доступа</definition>. Рассмотрим самые известные из них:
	  <variablelist>
	    <varlistentry>
	      <term><definition id="def-am-marker" orig="мандатная модель">Мандатная
	      модель доступа</definition></term>
	      <listitem>
		<para>
		  Объектам и субъектам системы ставится в соответствие <emphasis>метка
		    безопасности</emphasis> или <emphasis>мандат</emphasis> (например,
		    гриф секретности). При этом метка безопасности субъекта описывает его
		    благонадёжность, а метка безопасности объекта&nbsp;&mdash; степень
		    закрытости информации. Доступ к объекту разрешён только субъектам с
		    соответствующей или более сильной меткой.
		</para>
		<para>
		  Недостатком такой схемы можно считать слишком грубое деление прав,
		  необходимость введения категорий доступа и т.п. Также для данной модели
		  доступа очень важно разработать механизм понижения секретности теряющих
		  важность документов.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><definition id="def-am-acl" orig="модель списков доступа">Списки доступа
	      (Accecc Control Lists, ACL)</definition></term>
	      <listitem>
		<para>
		  Все субъекты и объекты системы объединяются в таблицу, в строках которой
		  находятся субъекты (активные сущности), а в столбцах&nbsp;&mdash;
		  объекты (пассивные сущности), элементы же такой таблицы содержат
		  перечисление прав, которыми субъект обладает в отношении данного
		  объекта. Такая схема называется <emphasis>субъект-объектная
		  модель</emphasis>.
		</para>
		<para>
		  Недостатками можно считать огромный размер таблицы и сложность
		  администрирования в случае большого числа объектов и субъектов в системе.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><definition id="def-am-uac" orig="произвольное управление
	      доступом">Произвольное управление доступом</definition></term>
	      <listitem>
		<para>
		  Каждому объекту сопоставляется один субъект&nbsp;&mdash; владелец
		  объекта. Владелец может по своему усмотрению давать другим субъектам или
		  отнимать у них права на доступ к объекту. Если объект имеет несколько
		  хозяев, они могут быть объединены общим субъектом&nbsp;&mdash; группой.
		  Такая схема позволяет значительно сократить размер таблицы прав
		  субъектов по отношению к объектам.  Эта схема также
		  называется <emphasis>субъект-субъектная модель</emphasis>.
		</para>
		<para>
		  Свойством этой схемы (достоинством и одновременно
		  недостатком) является значительное упрощение управления
		  доступом, что не позволяет строить сложные отношения между субъектами
		  и объектами.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
      </sect3>
      <sect3 id="security-lect-basis-auth">
	<title>Аутентификация и авторизация</title>
	<presentation number="5-04" name="аутентификация и авторизация"/>
	<para>
	  <definition id="def-authorization"
	  orig="авторизация">Авторизация</definition>&nbsp;&mdash; это процесс определения
	  того, имеет или не имеет некоторый субъект доступ к некоторому
	  объекту. Авторизация может быть:
	  <variablelist>
	    <varlistentry>
	      <term>статической</term>
	      <listitem>
		<para>
		  вопрос о доступе к объекту решается один раз, когда права задаются или
		  изменяются, при этом пользователю ставится в соответствие некоторый
		  номинальный субъект системы;
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>динамической</term>
	      <listitem>
		<para>
		  принятие решения о доступе производится при каждом обращении к объекту,
		  часто это носит характер ограничения возможностей пользователя по объёму
		  памяти и дискового пространства, времени работы и т.&nbsp;п.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
	<para>
	  Процессу <emphasis>авторизации</emphasis> всегда должен предшествовать процесс
	  <emphasis>аутентификации</emphasis>. <definition id="def-authentication"
	  orig="аутентификация">Аутентификация</definition>&nbsp;&mdash; это механизм
	  сопоставления работающего пользователя системы некоторому номинальному субъекту.
	  Как правило, при этом пользователю необходимо ввести пароль или предоставить
	  секретный ключ.
	</para>
      </sect3>
    </sect2>
    <sect2 id="security-lect-unix">
      <title>Концепции безопасности UNIX</title>
      <presentation number="5-05" name="концепции безопасности UNIX"/>
      <para>
	В операционной системе UNIX используется достаточно простая модель доступа,
	основанная на <emphasis>субъект-субъектной модели</emphasis> и статической
	авторизации. В современных версиях UNIX помимо общей схемы можно также
	использовать <emphasis>списки доступа</emphasis>.
	</para>
      <sect3 id="security-lect-unix-users">
	<title>Пользователи и группы</title>
	<para>
	  В UNIX роль <emphasis>номинального</emphasis> субъекта безопасности
	  играет <definition id="def-user">пользователь</definition>. Каждому пользователю
	  выдается (обычно&nbsp;&mdash; одно) входное имя (login). Каждому входному имени
	  соответствует уникальный числовой идентификатор пользователя (User
	  IDentifier, UID). Это и есть ярлык
	  субъекта (<emphasis>номинальный субъект</emphasis>), которым
	  система пользуется для определения прав доступа.
	</para>
	<para>
	  Каждый пользователь входит в одну или более групп. <definition id="def-group"
	  orig="группа">Группа</definition>&nbsp;&mdash; это список
	  пользователей системы, имеющий 
	  собственный идентификатор (Group IDentifier, GID).
	  Поскольку группа объединяет несколько пользователей
	  системы, в терминах политики безопасности она соответствует понятию
	  <emphasis>множественный субъект</emphasis>. Значит, GID&nbsp;&mdash; это ярлык множественного
	  субъекта, которых у номинального субъекта может быть более одного. Таким
	  образом, одному UID соответствует список GID.
	</para>	  
	<para>
	  Роль <emphasis>действительного</emphasis> (работающего с объектами) субъекта
	  играет <emphasis>процесс</emphasis>. Каждый процесс снабжен единственным UID:
	  это идентификатор запустившего процесс номинального
	  субъекта, т.&nbsp;е. пользователя. Процесс, порожденный
	  некоторым процессом пользователя, наследует его
	  UID<footnote>
	  <para>Из этого правила есть некоторые
	  исключения, обеспечивающие штатные для системы способы повышения и
	  понижения уровня доступа процесса (см. раздел <xref linkend="security-lect-unix-suid"/>).</para>
	</footnote>. Таким образом, все процессы, запускаемые
	  по желанию пользователя, будут иметь его идентификатор. UID учитываются,
	  например, когда один процесс посылает другому сигнал. В общем случае разрешается
	  посылать сигналы <quote>своим</quote> процессам (тем, что имеют такой же
	  UID).
	</para>
      </sect3>
      <sect3 id="security-lect-unix-rights">
	<title>Права доступа</title>
	<question id="quest-5-4">Какие существуют права доступа в UNIX? Какие из них
	являются специфичными для простых файлов, а какие для директорий?</question>
	<para>
	  Роль основного <emphasis>объекта</emphasis> доступа в UNIX играют
	  объекты файловой системы. В архитектуре UNIX в файловой
	  системе представлены не только обычные файлы с данными, там
	  присутствуют и специальные файлы для устройств, каналов,
	  сокетов и т.&nbsp;д. Благодаря этому регулирование доступа к
	  файлам позволяет покрыть очень широкий спектр ситуаций
	  доступа и служит основным средством организации политики
	  доступа в UNIX.
	</para>
        <para>
	В соответствии с субъект-субъектной моделью каждый файл
	снабжен ярлыком, в котором хранятся идентификаторы номинальных
	субъектов, которые вправе распоряжаться доступом к данному
	файлу. В случае UNIX, это идентификатор пользователя-владельца
	(UID) и идентификатор группы-владельца (GID). Обратите
	внимание, что файл может принадлежать только одной группе, в
	то время как пользователь может входить в несколько групп.
	</para>
	<para>
	  На уровне файловой системы в UNIX определяются
	  <definition id="def-unix-rights" orig="права доступа в UNIX"> три вида
	  доступа</definition>: чтение (read,
	  <literal>r</literal>), запись (write, <literal>w</literal>) и использование
	  (execution, <literal>x</literal>). Право на чтение из файла дает доступ к
	  содержащейся в нем информации, а право записи&nbsp;&mdash; возможность ее
	  изменять. Право <emphasis>использования</emphasis> трактуется по-разному в зависимости от
	  типа файла. В случае обычного файла оно означает
	  возможность <emphasis>исполнения</emphasis> файла,
	  т.&nbsp;е. запуска программы или командного сценария,
	  содержащихся в этом файле. Для каталога использование&nbsp;&mdash; это возможность доступа к
	  файлам этого каталога (точнее говоря, к атрибутам этих файлов&nbsp;&mdash;
	  имени, правам доступа и т.&nbsp;п.).
	</para>
        <para>
	  При каждом файле имеется ярлык, в котором
	  зафиксированы права доступа к нему. Права доступа
	  включают список из девяти пунктов (три тройки): по три вида
	  доступа для трех групп&nbsp;&mdash; пользователя-владельца,
	  группы-владельца и всех остальных. Каждый пункт в этом
	  списке может быть либо разрешён, либо запрещён (равен 0 либо
	  1). Таким образом, для хранения этой информации о правах
	  доступа достаточно 9 бит.
	</para>

      <!-- применение прав ниже?
      того, что с ним может делать владелец
	  (если совпадает UID процесса и файла), член группы владельцев (если совпадает
	  GID) и кто угодно (если ничего не совпадает)
	  (см. <xref linkend="img-unix-rights"/>). Такой список для каждого объекта
	  системы занимает всего несколько байт.
	</para>
      -->
	<para>
	  <figure id="img-unix-rights">
	    <title>Базовые права доступа в UNIX</title>
	    <graphic fileref="&BASEIMAGES;unix_rights.png"/>
	  </figure>	
	</para>

	<para>
	  При обращении процесса к файлу (с запросом доступа
	  определённого вида, т.&nbsp;е. на чтение, запись или
	  исполнение) система проверяет совпадение 
	  идентификаторов владельцев процесса и владельцев файла в
	  определённом порядке, и в зависимости от результата,
	  применяет ту или иную группу прав.
	  Рассмотрим последовательность проверки прав на примере
	  (см. <xref linkend="img-unix-checking-rights"/>). Пусть файл имеет следующие
	  атрибуты:
	  <informalexample>
	    <screen>file.txt   alice:users   rw- r-- ---</screen>
	  </informalexample>
	  Т.&nbsp;е. файл принадлежит пользователю <command>alice</command>,
	  группе <command>users</command> и имеет права на чтение и запись для владельца, и
	  только на чтение для группы, для всех остальных не
	  разрешается никакой вид доступа.
	</para>
	<presentation number="5-06" name="последовательность проверки"/>
        <para>
	  Пусть к файлу обращается с запросом на чтение процесс, владельцем которого
	  является пользователь <command>bob</command>. Bob не является
	  владельцем данного файла, однако он является членом группы
	  <command>users</command>. Значит, он имеет права на чтение этого файла. 
	</para>
	<para>Строго говоря, при этом проверяется не собственно
	  идентификатор пользователя процесса (UID), а
	  т.&nbsp;н. <definition id="euid">исполнительный
	  идентификатор пользователя</definition>, EUID. Он существует в связи с тем, что
	  в ходе выполнения процесс может менять субъект, от имени которого он
	  исполняется. Подробнее об этом сказано в разделе <xref
	  linkend="security-lect-unix-suid"/>.
	</para>

	<para>
	  <figure id="img-unix-checking-rights">
	    <title>Последовательнось проверки прав доступа в UNIX</title>
	    <graphic fileref="&BASEIMAGES;checking_rights.png"/>
	  </figure>	
	</para>
	<sect4 id="security-lect-unix-dirs">
	  <title>Разделяемые каталоги</title>
	  <para>
	    Право на запись для каталога трактуется как возможность
	    создания и удаления файлов в нём,
	    а также возможность изменения атрибутов файлов (например,
	    переименование или удаление). При этом субъекту
	    не обязательно иметь права на запись для этих файлов,
	    поскольку и переименование и удаление файла затрагивают только
	    сам каталог.
	  </para>
	  <para>
	    Таким образом, из своего каталога пользователь может
	    удалить любой файл. Часто возникает ситуация, когда
	    каталог нужно использовать совместно&nbsp;&mdash; в этом
	    случае необходимо разрешить запись в него либо группе
	    пользователей, либо всем пользователям (например,
	    общесистемный каталог для временных файлов). А если
	    запись в каталог разрешена всем, то любой пользователь сможет удалить в нём
	    любой файл. Для избежания этой проблемы был добавлен
	    специальный атрибут&nbsp;&mdash; <definition
	    id="def-sticky-bit" orig="sticky-бит">sticky
	    bit</definition><footnote>
	    <para>На русский этот термин не очень удачно
	    переводится либо как <quote>липкий бит</quote>, либо как
	    <quote>бит навязчивости</quote>. Чтобы избежать неудобного
	    термина многие просто называют его
	    <emphasis>t-битом</emphasis>
	    (<emphasis>t-атрибутом</emphasis>), по обозначению,
	    которое используется для указания этого атрибута в
	    символьной записи прав доступа.</para>
	  </footnote> При установке этого атрибута пользователь,
	    имеющий доступ на запись в этот каталог, может изменять 
	    только <emphasis>принадлежащие ему</emphasis> файлы.
	  </para>
	</sect4>
	<sect4 id="security-lect-unix-suid">
	  <title>Подмена идентификатора процесса</title>
	  <presentation number="5-07" name="подмена идентификатора процесса"/>
	  <question id="quest-5-5">Что такое подмена идентификатора процесса? Как такое
	  право устанавливается и в каких случаях применяется?</question>
	  <para>
	    В UNIX существует механизм <definition id="def-suid"
	    orig="подмена идентификатора">подмены
	    идентификатора</definition> (SetUID), позволяющий пользователям 
	    запускать процессы с идентификаторами других
	    пользователей. Этот механизм применяется в тех случаях, когда
	    процессу для выполнения определённых операций необходимо 
	    предоставить повышенные права (например,
	    суперпользователя) или права другого пользователя. 
	  </para>
	<para>
	  Подмена идентификатора в том случае, если процесс запустит
	  вместо себя при помощи системного вызова <command>exec()</command> программу <emphasis>из
	  файла</emphasis>, в правах доступа которого установлен <definition
	  id="def-suid-bit" orig="SUID-бит">бит подмены 
	    идентификатора пользователя</definition> (SUID-бит,
	  обозначается <literal>s</literal> в символьной записи прав
	  доступа). Запущенный из этого файла процесс получит
	  исполнительный идентификатор владельца (EUID) файла вместо идентификатора владельца
	  процесса-родителя (см. <xref linkend="img-suid"/>), благодаря чему UID процесса
	  сохраняет информацию о том, кто <emphasis>на самом деле</emphasis> запустил
	  программу.
	</para>
	<para>
	  <figure id="img-suid">
	    <title>Подмена идентификатора процесса</title>
	    <graphic fileref="&BASEIMAGES;suid.png"/>
	  </figure>
	</para>	  
	<para>
	  В современных UNIX-системах предусмотрен и ещё один
	  дополнительный атрибут&nbsp;&mdash; SetGID, бит подмены
	  идентификатора группы. Этот механизм работает совершенно
	  аналогично подмене идентификатора пользователя, с тем
	  отличием, что процесс, запущенный из файла с атрибутом
	  SetGID, получает идентификатор группы-владельца файла, UID
	  же его остается неизменным.
	  Использование SetGID позволяет весьма гибким образом
	  контролировать ситуацию повышения прав доступа
	  процесса.	
	</para>
	<para>
	  Особое значение имеют атрибуты подмены идентификатора
	  (SetUID и SetGID), установленные на каталогах (о других правах доступа для
	  каталогов сказано в разделе <xref linkend="security-lect-unix-dirs"/>)&nbsp;&mdash;
	  для каталогов тоже используются права на исполнение, хотя и
	  имеют другой смысл, чем у исполняемых файлов. Атрибут
	  SetGID, установленный на каталоге, указывает, что файлы и
	  подкаталоги, создаваемые внутри этого подкаталога любыми
	  процессами, будут получать тот же идентификатор группы, что
	  и сам каталог. Причем подкаталоги будут также наследовать
	  атрибут SetGID. Такой механизм используется для организации
	  общих каталогов, файлы в которых должны быть доступны на
	  равных условиях группе пользователей. Атрибут SetUID,
	  установленный на каталоге, просто игнорируется.
	</para>
	<para>
	  Атрибуты подмены идентификаторов пользователя и группы несут
	  потенциальную угрозу безопасности системы и должны
	  использоваться с осторожностью.
	</para>
	</sect4>
	<sect4 id="security-lect-unix-fails">
	  <title>Ограничения и расширения базовой модели доступа</title>
	  <para>
	    Простота системы прав доступа UNIX приводит к некоторым
	    ограничениям. К примеру, стандартными средствами UNIX
	    <emphasis>невозможно</emphasis> создать такое положение
	    вещей, когда одна группа пользователей могла бы только читать из файла, другая&nbsp;&mdash;
	    только запускать его, а всем остальным файл вообще не был бы доступен. Другое
	    дело, что такое положение вещей встречается нечасто.
	  </para>
	  <para>
	    Со временем в различных версиях UNIX стали появляться расширения прав доступа,
	    позволяющие устанавливать права на отдельные объекты системы. Поначалу это
	    были так называемые <emphasis>флаги</emphasis>&nbsp;&mdash; дополнительные атрибуты файла, не
	    позволяющие, например, переименовывать его или удалять из него информацию при
	    записи (можно только дописывать). Флаги не устраняют главного недостатка, зато
	    их легко организовать без изменения файловой системы: каждый флаг занимает
	    ровно один бит.
	  </para>
	  <para>
	    Многие современные файловые системы UNIX поддерживают также <emphasis>списки
	    доступа</emphasis> (ACL), с помощью которых можно для
	    каждого объекта задавать права всех субъектов на доступ к нему.
	  </para>
	  <para>
	    На практике флаги или списки доступа использовать приходится нечасто. В
	    большинстве случаев такая необходимость возникает в виде
	    исключения&nbsp;&mdash; например, для временного понижения прав или для
	    временного предоставления доступа некоторым пользователям (легко сделать с
	    помощью ACL), а также при работе с очень важными файлами.
	  </para>
	</sect4>
      </sect3>
      <sect3 id="security-lect-unix-root">
	<title>Суперпользователь</title>
	<presentation number="5-08" name="суперпользователь"/>
	<para>
	  Пользователь root (он
	  же <definition id="def-root">суперпользователь</definition>) имеет нулевые UID и
	  GID и играет роль <emphasis>доверенного субъекта UNIX</emphasis>. Это значит,
	  что он не подчиняется законам, которые управляют правами доступа, и может по
	  своему усмотрению эти права изменять. Большая часть
	  общезначимых (не принадлежащих конкретным пользователям)
	  компонентов системы доступна для модификации только суперпользователю.
	</para>
	<para>
	  Как было сказано ранее (см. раздел <xref linkend="intro-unix-concepts-arch"/>),
	  в UNIX существует уровень доступа ядра и уровень доступа
	  системы. Суперпользователь работает на уровне доступа ядра, так что он является, по
	  сути, неотъемлемым компонентом самой системы.
	</para>
	<para>
	  Многие команды должны исполняться только от имени суперпользователя, так как в
	  них производится взаимодействие с частями ядра, отвечающими за взаимодействие с
	  аппаратурой, правом доступа и т.&nbsp;п. Если же такие команды разрешается запускать
	  простым пользователям, применяется рассмотренный выше механизм подмены
	  идентификатора пользователя.
	</para>
	<para>
	  Администрирование в UNIX (т.&nbsp;е. управление
	  общезначимыми характеристиками системы) требует привилегий суперпользователя.
	  При работе с повышенными привилегиями, в особенности от
	  имени пользователя <emphasis>root</emphasis> следует быть
	  очень осторожным: выполнение неверной команды может привести
	  к выходу системы из строя и утрате информации. Поэтому даже
	  администраторы никогда не работают в командной оболочке с
	  правами суперпользователя всё время, а переходят в режим суперпользователя только
	  тогда, когда это действительно необходимо (например, с помощью
	  команды <command>su</command>).
	</para>
      </sect3>
      <sect3 id="security-lect-unix-auth">
	<title>Аутентификация пользователей</title>
	<presentation number="5-09" name="вход пользователя в систему"/>
	<question id="quest-5-6">Из каких этапов состоит процесс аутентификации пользователя в
	UNIX?</question>
	<para>
	  В UNIX <definition id="def-session">сеанс работы</definition> пользователя
	  начинается с его аутентификации и заканчивается его выходом из системы. При
	  входе в систему выполняется следующая последовательность действий
	  (см. <xref linkend="img-login"/>):
	  <orderedlist>
	    <listitem>
	      процесс <command>getty</command> ожидает реакции пользователя на одной из
	      терминальных линий, в случае активности пользователя
	      выводит приглашение ввести регистрационные данные пользователя;
	    </listitem>
	    <listitem>
	      после ввода имени пользователя запускается
	      программа <command>login</command>, которая проверяет подлинность
	      данных пользователя. Стандартным механизмом является
	      проверка <emphasis>пароля</emphasis>, заданного для данного пользователя;
	    </listitem>
	    <listitem>
	      убедившись, что пароль введён правильно, <command>login</command>
	      запускает командную оболочку с установленными UID и GID данного
	      пользователя. Таким образом, права доступа любого процесса (действительного
	      субъекта), запущенного пользователем в этом сеансе работы, будут определяться
	      правами номинального субъекта UID+GID.
	    </listitem>
	  </orderedlist>
	</para>
	<para>
	  <figure id="img-login">
	    <title>Регистрация пользователя в системе</title>
	    <graphic fileref="&BASEIMAGES;login.png"/>
	  </figure>
	</para>	  
	<para>
	  При работе регистрации на удалённом компьютере роль
	  <command>getty</command> исполняет сетевой демон, 
	  например <command>ssh</command>.
	</para>
	<para>
	  В современных UNIX-системах существуют расширения систем авторизации и
	  аутентификации, позволяющие интегрировать в процесс
	  аутентификации любые дополнительные процедуры. Например, в Linux-системах этот механизм
	  называется <emphasis>подключаемые модули аутентификации</emphasis> (Pluggable
	  Authentication Modules,
	  PAM). Рассмотрение этих средств выходит за рамки
	  данного курса.
	</para>
      </sect3>
    </sect2>
    <sect2 id="security-lect-config">
      <title>Управление пользователями и правами доступа</title>
      <sect3 id="security-lect-config-passwd">
	<title>База данных пользователей системы</title>
	<presentation number="5-10" name="база данных пользователей"/>
	<question id="quest-5-7">Каким образом хранится информация обо всех пользователях
	системы?</question>
	<para>
	  Все <definition id="def-usersdb" orig="база данных пользователей">данные о
	  пользователях</definition> UNIX хранит в файле <filename>/etc/passwd</filename>
	  в текстовом виде. Каждому пользователю соответствует одна строка, поля которой
	  разделяются двоеточиями:
	  <command>входное имя:x:UID:GID:полное имя:домашний каталог:стартовый shell</command>
	</para>
	<para>
	  <example>
	    <title>Пример файла <filename>/etc/passwd</filename></title>
	    <programlisting>
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/bin/false
daemon:x:2:2:daemon:/sbin:/bin/false
adm:x:3:4:adm:/var/adm:/bin/false
...</programlisting>
	  </example>
	</para>
	<para>
	  Каждый пользователь явно связан с одной из групп&nbsp;&mdash; это
	  <definition id="def-main-group">основная группа</definition> пользователя. Это
	  сделано для того, чтобы каждый пользователь состоял хотя бы в одной группе. Все
	  новые файлы, создаваемые процессами этого пользователя, в
	  качестве группы-владельца будут получать основную группу
	  данного пользователя.
	</para>
	<para>
	  Из примера видно, что некоторые пользователи имеют <quote>неправильные</quote>
	  командные оболочки, такие как <filename>/bin/false</filename>, работа в которых
	  невозможна (команда <command>false</command> только и делает, что возвращает
	  ошибку и немедленно завершается). Это сделано специально для того, чтобы исключить возможность входа
	  таких пользователей в систему, а соответствующие учётные записи в
	  <filename>/etc/passwd</filename> принадлежат
	  <emphasis>псевдопользователям</emphasis>, от имени которых
	  выполняются некоторые системные задачи и которыми не
	  пользуются реальные люди.
	</para>
	<para>
	  Пароли на вход в систему пользователей в UNIX не хранятся в открытом виде,
	  хранятся только их хэши (набор байт, получаемый из пароля с помощью
	  односторонней функции). Даже если злоумышленник получит значение этого хэша, ему
	  придется <emphasis>подбирать</emphasis> пароль, применяя данную одностороннюю
	  функцию к различным словам и сравнивая со значением хэша. Часто хэши хранятся в
	  специальном файле (например, <filename>/etc/shadow</filename>), доступ к
	  которому разрешен только системе, так что перебор вообще не возможен.
	</para>
	<para>
	  Аналогичным образом информация о группах хранится в
	  файле <filename>/etc/group</filename>. Каждой строке файла соответствует
	  информация о группе: её имя, числовой идентификатор и список пользователей,
	  входящих в эту группу.
	</para>
	<para>
	  В современных версиях операционной системы Linux используется альтернативный
	  механизм хранения паролей&nbsp;&mdash; TCB. Основное отличие состоит в том, что
	  содержимое файла <filename>/etc/shadow</filename> <quote>размазывается</quote>
	  по множеству каталогов, так что хэш пароля каждого пользователя хранится в каталоге, к
	  которому только он один имеет доступ. Это позволяет
	  ограничить привилегии утилиты <command>passwd</command>, с
	  помощью которой пользователь может сам себе изменить
	  пароль. При использовании схемы TCB для выполнения этой операции
	  не требуется повышение привелений <command>passwd</command>
	  (получение прав суперпользователя) с помощью атрибута SetUID.
	</para>
	<para>
	  Изменение информации о пользователях, так же как и добавление новых
	  пользователей, может производиться прямым редактированием этих файлов, однако
	  более корректным способом является использование <emphasis>специальных
	  утилит</emphasis>, которые рассматриваются далее.
	</para>
      </sect3>
      <sect3 id="security-lect-config-users">
	<title>Изменение базы данных пользователей</title>
	<para>
	  Для добавления и удаления пользователей и групп существует
	  набор специальных утилит:
	  <command>useradd</command>, <command>userdel</command>,
	  <command>groupadd</command>, <command>groupdel</command>.
	  Эти команды доступны только суперпользователю и имеют единственный обязательный
	  параметр: имя пользователя или группы.
	</para>
	<para>
	  С помощью команд <command>usermod</command> и <command>groupmod</command> можно
	  изменять информацию в базах данных пользователей и групп. Эти команды также
	  может выполнять только администратор системы.
	</para>
	<para>
	  Команда <command>passwd</command> позволяет простым пользователям изменять свой
	  системный пароль, а суперпользователю&nbsp;&mdash; изменять пароль любого из
	  пользователей системы.
	</para>
      </sect3>
      <sect3 id="security-lect-config-rights">
	<title>Изменение прав доступа</title>
	<para>
	  Для изменения владельца файла или группы владельцев используются
	  команды <command>chown</command> и <command>chgrp</command>. Из соображений
	  безопасности эти утилиты доступны только суперпользователю.
	</para>
	<para>
	  Владелец файла может изменять права доступа к своему файлу с помощью
	  утилиты <command>chmod</command>. 
	</para>
      </sect3>
      <sect3 id="security-lect-config-session">
	<title>Ограничения сеанса пользователя</title>
	<presentation number="5-11" name="ограничения сеанса пользователя"/>
	<para>
	  В UNIX существует ряд динамических ограничений, накладываемых на процесс
	  аутентификации пользователя и запущенные им программы. Ограничения можно
	  разделить на следующие группы:
	  <variablelist>
	    <varlistentry>
	      <term>ограничения входа в систему</term>
	      <listitem>
		<para>
		  Вход пользователя в систему может быть ограничен видом терминала,
		  удалённым адресом (в случае сетевого входа в систему), временем работы.
		  Для задания этих ограничений
		  в некоторых UNIX-системах используется
		  файл  <filename>/etc/login.access</filename>
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>ограничения запускаемых процессов</term>
	      <listitem>
		<para>
		  Процессы пользователей могут быть ограничены по одному из следующих
		  параметров: объём используемой памяти, число одновременно открытых
		  файлов, число запускаемых процессов и т.&nbsp;п. Для задания этих ограничений
		  в некоторых UNIX-системах используется
		  файл <filename>/etc/limits</filename>. 
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>ограничения использования диска</term>
	      <listitem>
		<para>
		  <definition id="def-quotes" orig="дисковые квоты">Дисковые
		  квоты</definition> позволяют ограничить объём используемого пространства
		  жёсткого диска для каждого из пользователей системы. Для настройки
		  данного ограничения необходима утилита <command>quota</command>, а
		  также поддержка квот в выбранной файловой системе. При каждой записи на
		  диск ядро операционной системы производит проверку квот на объём и число
		  файлов для данного субъекта.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>	  
	  Ограничения действуют на протяжении всего сеанса работы пользователя.
	</para>
      </sect3>
    </sect2>
    <sect2 id="security-lect-summary">
      <title>Резюме</title>
      <presentation number="5-12" name="резюме"/>
      <para>
	Основой информационной безопасности любого предприятия является политика
	безопасности, которая включает в себя технические, организационные и правовые
	аспекты.
      </para>
      <para>
	Основными элементами политики безопасности являются субъект, объект и отношения
	между ними. Выделяют ряд моделей доступа, среди которых мандатный доступ,
	списки доступа (субъект-объектная модель) и произвольное управление доступом
	(субъект-субъектная модель). 
      </para>
      <para>
	В операционной системе UNIX номинальным субъектом является учётная
	запись пользователя, действительным субъектом&nbsp;&mdash;
	процесс пользователя, а объектом&nbsp;&mdash; 
	файл. Три основных вида прав доступа:
	чтение, запись и исполнение, а также дополнительные права
	(подмены субъекта и разделяемости каталога). Права доступа
	указываются для трех групп: владельца объекта,
	группы-владельца и всех остальных.
      </para>
      <para>
	Аутентификация пользователя (сопоставление ему номинального
	субъекта) при входе в систему состоит в проверке пароля, 
	соответствующего входному имени пользователя.
      </para>
      <para>
	Информация о пользователях системы хранится в специальном
	файле <filename>/etc/passwd</filename>. Существует набор системных утилит для
	управления базой данных пользователей и групп.
      </para>
      <para>
	В UNIX можно устанавливать динамические ограничения на сеанс пользователя.
      </para>
      <list-of-definitions/>
    </sect2>    
    <sect2 id="security-lect-additional">
      <title>Дополнительные материалы</title>
      <para>
	<orderedlist>
	  <listitem>
	    Скотт Манн, Эленн Митчелл, Митчелл Крелл <emphasis>Безопасность
	    Linux</emphasis>.&nbsp;&mdash; М.: Вильямс, 2003.&nbsp;&mdash; 624 с.: ил.
	  </listitem>
	  <listitem>
	    Курячий Г.В. <emphasis>Операционная система UNIX</emphasis>.&nbsp;&mdash;
	    М.: Интуит.Ру, 2004.&nbsp;&mdash; 292 с.: ил.
	  </listitem>
	</orderedlist>
      </para>
    </sect2>    
    <list-of-questions id="security-lect-questions"/>
    <small-presentation id="security-lect-presentaion"/>
  </sect1>

