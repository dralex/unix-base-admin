<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
	  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [

	  <!ENTITY % CommonEntities PUBLIC
		   "-//IU7 LUG//ENTITIES Common Documentation//RU"
		   "common.ent">
	  %CommonEntities;
	  
	  <!ENTITY BASEIMAGES "images/">

]>

  <!-- занятие №8 (лекция) -->
  <sect1 id="network-lect">
    <title>Сеть в UNIX</title>
    <presentation number="6-01" name="введение в сети"/>

    <para>
      Сети стали неотъемлемой составляющей современных вычислительных систем. 
      Технологии взаимодействия между информационными системами развиваются с 1970-х
      годов, ненамного опередив развитие UNIX. Операционная система UNIX почти с самого
      рождения интегрировала в себя технологии организации локальных сетей, на её основе затем была
      построена сеть Internet, распространившаяся ныне по всему миру.
    </para>
    
    <sect2 id="network-lect-intro">
      <title>Введение в сети</title>
      <para> Организация взаимодействия между устройствами и программами в сети является
	сложной задачей. Сеть объединяет разное оборудование, различные операционные
	системы и программы&nbsp;&mdash; их успешное взаимодействие было бы невозможно без принятия общепринятых
	правил, стандартов.
      </para>
      <para>
	В области компьютерных сетей существует множество международных и промышленных
	стандартов, среди которых следует особенно выделить международный
	стандарт OSI и набор стандартов IETF
	(Internet Engineering Task Force).
      </para>
      <sect3 id="network-lect-intro-osi">
	<title>Семиуровневая модель OSI</title>
	<presentation number="6-02" name="взаимодействие открытых систем"/>
	<para>
	  В модели <definition id="def-osi">OSI</definition>,
	  называемой также моделью взаимодействия открытых систем (Open Systems
	  Interconnection&nbsp;&mdash; OSI) и разработанной
	  Международной Организацией по Стандартам (International Organization for
	  Standardization&nbsp;&mdash; ISO), средства сетевого
	  взаимодействия делятся на семь уровней, для которых определены стандартные
	  названия и функции (см. <xref linkend="img-osi"/>).
	</para>
	<para>
	  <figure id="img-osi">
	    <title>Уровни ISO OSI</title>
	    <graphic fileref="&BASEIMAGES;osi.png"/>
	  </figure>	
	</para>
	<para>
	  Каждый уровень предоставляет <emphasis>интерфейс</emphasis> к вышележащему
	  уровню, скрывая детали реализации. При построении транспортной подсистемы
	  какого-либо приложения наибольший интерес представляют функции физического,
	  канального и сетевого уровней, тесно связанные с используемым в данной сети
	  оборудованием: сетевыми адаптерами, концентраторами, мостами, коммутаторами,
	  маршрутизаторами. Функции прикладного и сеансового уровней, а также уровня
	  представления реализуются операционными системами и системными приложениями
	  конечных узлов. Транспортный уровень выступает посредником между этими двумя
	  группами протоколов.
	</para>
	<para>
	  Находящиеся на разных узлах сети процессы при обмене
	  информацией взаимодействуют только с самым верхним
	  уровнем, но данные при продвижении по сети проходят сначала
	  через все уровни&nbsp;&mdash; от самого верхнего к самому
	  нижнему&nbsp;&mdash; на одном узле и затем в обратном порядке на другом узле.
	</para>
	<para>
	  Рассмотрим подробнее назначение каждого из уровней:
	</para>
	<question id="quest-6-1">Какие уровни входят в модель ISO OSI? Какие можно
	провести аналогии с реально существующими протоколами?</question>
	<sect4 id="network-lect-intro-osi-phys">
	  <title>Физический уровень</title>
	  <para>
	    <definition id="def-osi-phys" orig="физический уровень">Физический
	    уровень</definition> выполняет передачу битов по физическим каналам, таким
	    как витая пара, оптоволоконный кабель или радиоволны. На этом уровне
	    определяются характеристики физических сред передачи данных и параметров
	    электромагнитных сигналов.
	  </para>
	</sect4>
	<sect4 id="network-lect-intro-osi-datalink">
	  <title>Канальный уровень</title>
	  <para>
	    <definition id="def-osi-dl" orig="канальный уровень">Канальный
	    уровень</definition> обеспечивает передачу кадра данных между любыми узлами в
	    сетях с типовой топологией либо между двумя соседними узлами в сетях с
	    произвольной топологией, отвечает за установление соединения и корректность
	    доставки данных по физическим каналам. В протоколах канального уровня заложена
	    определенная структура связей между компьютерами и способы их
	    адресации. Адреса, используемые на канальном уровне в локальных сетях, часто
	    называют <definition id="def-mac-address"
	    orig="МАС-адрес">МАС-адресами</definition> (Media Access Control, управление
	    доступом к среде). Часть канального уровня требует аппаратной реализации, в
	    операционной системе он, как правило, представлен драйвером сетевой карты.
	  </para>
	</sect4>
	<sect4 id="network-lect-intro-osi-network">
	  <title>Сетевой уровень</title>
	  <para>
	    <definition id="def-osi-network" orig="сетевой уровень">Сетевой
	      уровень</definition> в первую очередь должен предоставлять средства для решения
	    следующих задач:
	  </para>	  
	  <itemizedlist>
	    <listitem>доставки пакетов в сети с произвольной топологией;</listitem>
	    <listitem>структуризации сети путем надежной локализации трафика;</listitem>
	    <listitem>согласования различных протоколов канального уровня.</listitem>
	  </itemizedlist>
	  <para>
	    Сетевой уровень позволяет передавать данные между любыми, произвольно
	    связанными узлами сети (при этом не берёт на себя никаких обязательств по
	    надежности передачи данных). Это достигается благодаря
	    наличию <emphasis>адресации</emphasis>&nbsp;&mdash; каждый узел в сети имеет
	    свой уникальный идентификатор.
	  </para>	  
	  <para>
	    Реализация протокола сетевого уровня подразумевает наличие в сети специального
	    устройства&nbsp;&mdash; <definition id="def-router"
	    orig="маршрутизатор">маршрутизатора</definition>. Маршрутизаторы объединяют
	    отдельные сети в общую составную сеть. К каждому маршрутизатору могут быть
	    присоединены несколько сетей (по меньшей мере две). 
	  </para>
	</sect4>
	<sect4 id="network-lect-intro-osi-trans">
	  <title>Транспортный уровень</title>
	  <para>
	    <definition id="def-osi-trans" orig="транспортный уровень">Транспортный
	    уровень</definition> обеспечивает передачу данных между любыми узлами сети с
	    требуемым уровнем надежности. Для этого на транспортном уровне имеются
	    средства установления соединения, нумерации, буферизации и упорядочивания
	    пакетов.
	  </para>
	</sect4>
	<sect4 id="network-lect-intro-osi-session">
	  <title>Сеансовый уровень</title>
	  <para>
	    <definition id="def-osi-sess" orig="сеансовый уровень">Сеансовый
	    уровень</definition> предоставляет средства управления диалогом, позволяющие
	    фиксировать, какая из взаимодействующих сторон является активной в настоящий
	    момент, а также предоставляет средства синхронизации в рамках процедуры обмена
	    сообщениями.
	  </para>
	</sect4>
	<sect4 id="network-lect-intro-osi-pres">
	  <title>Уровень представления</title>
	  <para>
	    В отличие от нижележащих уровней, задача которых&nbsp;&mdash; надежная и эффективная
	    передача битов от отправителя к
	    получателю, <definition id="def-osi-pres">уровень представления</definition>
	    имеет дело с внешним представлением данных. На этом уровне могут выполняться
	    различные виды преобразования данных, такие как компрессия и декомпрессия,
	    шифровка и дешифровка данных.
	  </para>
	</sect4>
	<sect4 id="network-lect-intro-osi-app">
	  <title>Прикладной уровень</title>
	  <para>
	    <definition id="def-osi-app" orig="прикладной уровень">Прикладной
	    уровень</definition>&nbsp;&mdash; это в сущности набор разнообразных сетевых
	    сервисов, предоставляемых конечным пользователям и приложениям. Примерами
	    таких сервисов являются, например, электронная почта, передача файлов,
	    подключение удаленных терминалов к компьютеру по сети.
	  </para>
	</sect4>
	<para>
	  Существует несколько групп взаимосвязанных протоколов (называемые также <emphasis>стеки
	  протоколов</emphasis><footnote><para>Слово <quote>стек</quote>
	  отсылает в данном случае к многоуровневой организации группы
	  протоколов, логически взаимосвязанных как лежащие друг над
	  другом <quote>слои</quote>.</para></footnote>), которые
	  частично или полностью соответствуют уровням 
	  эталонной модели OSI. Для нас наибольший
	  интерес представляет стек протоколов TCP/IP.
	</para>
      </sect3>
      <sect3 id="network-lect-intro-tcpip"> 
	<title>Протоколы Internet: TCP/IP</title>
	<presentation number="6-03" name="протоколы Internet: TCP/IP"/>
	<para>
	  Протоколы TCP/IP (Transmission Control Protocol / Internet Protocol) были
	  разработаны по заказу Министерства обороны США 30 лет назад
	  для организации связи в рамках
	  экспериментальной сети ARPAnet и представляет собой набор
	  общих протоколов для разнородной вычислительной среды. Первая реализация 
	  стека TCP/IP была создана в стенах университета Беркли для операционнной
	  системы UNIX. Популярность UNIX и удачные идеи, заложенные в TCP/IP, привели к
	  образованию и бурному развитию международной сети Internet. Все протоколы
	  семейства TCP/IP и связанные с ними проходят стандартизацию в
	  организации IETF через выпуск так
	  называемых RFC-документов (Request For Comment).
	</para>
	<para>
	  Протоколы, входящие в TCP/IP, частично соответствуют модели OSI
	  (см. <xref linkend="img-tcpip"/>). Стек TCP/IP поддерживает на нижнем уровне все
	  популярные стандарты физического и канального уровней: для локальных
	  сетей&nbsp;&mdash; Ethernet, Token Ring, FDDI, для глобальных&nbsp;&mdash; PPP,
	  ISDN. Основными протоколами стека, давшими ему название, являются протоколы IP и
	  TCP, относящиеся к сетевому и транспортному уровням соответственно. IP
	  обеспечивает продвижение пакета по сети, TCP гарантирует надёжность его доставки.
	</para>
	<para>
	  За долгие годы использования стек TCP/IP пополнился множеством протоколов
	  прикладного уровня: FTP, SMTP, HTTP и т.&nbsp;п.
	</para>
	<para>
	  <figure id="img-tcpip">
	    <title>Соответствие стека TCP/IP модели OSI</title>
	    <graphic fileref="&BASEIMAGES;tcpip.png"/>
	  </figure>	
	</para>
	<para>
	  Поскольку стек TCP/IP изначально создавался для глобальной сети, он имеет много
	  особеностей, дающих ему преимущество перед другими протоколами, когда речь
	  заходит о глобальных коммуникациях. Это возможность фрагментации пакетов, гибкая
	  система адресации, простота широковещательных запросов. На
	  сегодня TCP/IP&nbsp;&mdash; самый распространённый протокол вычислительных
	  сетей. 
	</para>
	<para>
	  Для UNIX-систем TCP/IP исторически являлся первым и остается
	  основным сетевым протоколом. Рассмотрим, как в UNIX осуществляется
	  администрирование сетевых соединений на основе TCP/IP. 
	</para>
      </sect3>	
    </sect2>
    <sect2 id="network-lect-iface">
      <title>Сетевой интерфейс в UNIX</title>

	  <presentation number="6-04" name="сетевой интерфейс в UNIX"/>
      <question id="quest-6-2">Что такое сетевой интерфейс в UNIX? Для чего он
      используется и каким образом настраивается?</question>
      <para>
	Основной сетевой подсистемы UNIX является сетевой интерфейс.
	<definition id="def-iface" orig="сетевой интерфейс">Сетевой
	интерфейс</definition>&nbsp;&mdash; это абстракция, связывающая канальный и
	сетевой (протокол TCP/IP) уровни сети в UNIX.
      </para>
      <para>
	Сетевой интерфейс создается в момент загрузки драйвера
	сетевого устройства (например, сетевой карты)
	или создания логического соединения (например, в случае PPP). 
	Каждый сетевой интерфейс в системе имеет уникальное имя, состоящее
	из <emphasis>типа устройства</emphasis> и <emphasis>номера</emphasis> (0 или
	больше для однотипных устройств). Под типами устройств в различных UNIX-системах
	может пониматься вид протокола канального уровня
	(Ethenet&nbsp;&mdash; <command>eth</command>) или название драйвера устройства
	(Realtek&nbsp;&mdash; <command>rl</command>).
      </para>
      <para>
	Интерфейс имеет набор параметров, большая часть которых относятся к сетевому уровню
	(IP-адрес, маска сети и т.&nbsp;п.). Важным параметром сетевого интерфейса является
	аппаратный адрес (в случае Ethernet аппаратный адрес называется MAC-адресом и состоит из
	шести байтов, которые принято записывать в шестнадцатеричной системе счисления и
	разделять двоеточиями).
      </para>
      <para>
	Основной утилитой для просмотра и управления параметрами сетевых интерфейсов в
	UNIX служит <command>ifconfig</command>. В настоящее время в
	ряде систем наряду с ней используется более современная
	утилита <command>ip</command> с отличающимся синтаксисом
	параметров командной строки. Далее в приводимых примерах мы
	будем использовать в первую очередь традиционную и на
	сегодняшний день более распространённую утилиту <command>ifconfig</command> 
      </para>
    <para>
      Утилита <command>ifconfig</command>, вызванная в командной
      строке без параметров, выводит сведения обо всех настроенных
      в данный момент сетевых интерфейсах. Чтобы просмотреть
      информацию о конкретном интерфейсе, необходимо указать его имя в
      качестве параметра <command>ifconfig</command>:
    </para>
      <para>
	<example>
	  <title>Просмотр параметров сетевых интерфейсов (<command>ifconfig</command>)</title>
	  <screen>desktop ~ # ifconfig eth0
eth0      Link encap:Ethernet  HWaddr 00:0D:60:8D:42:AA  
          inet addr:192.168.1.5  Bcast:192.168.1.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:6160 errors:0 dropped:0 overruns:0 frame:0
          TX packets:5327 errors:0 dropped:0 overruns:0 carrier:0
          collisions:1006 txqueuelen:1000 
          RX bytes:3500059 (3.3 Mb)  TX bytes:2901625 (2.7 Mb)
          Base address:0x8000 Memory:c0220000-c0240000
desktop ~ # ifconfig lo
lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:188 errors:0 dropped:0 overruns:0 frame:0
          TX packets:188 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:14636 (14.2 Kb)  TX bytes:14636 (14.2 Kb)</screen>
	</example>
      </para>
    <para>
      Обычно выполнение <command>ifconfig</command> требует прав
      суперпользователя или разрешается пользователям, входящим в
      специальную <quote>административную</quote> группу (например,
      netadmin). Настройка сетевых параметров, связанных с
      интерфейсом, выполняется с помощью той же 
      утилиты <command>ifconfig</command>, о чем будет сказано
      далее.
    </para>
      <para>
	Для диагностики трафика на канальном уровне применяются специальные
	программы. Самыми распространёнными в UNIX
	являются <command>tcpdump</command> и <command>ethereal</command>.
	При <quote>прослушивании</quote> канала эти программы взаимодействуют с заданным
	сетевым интерфейсом. 
      </para>
    </sect2>    
    <sect2 id="network-lect-ip">
      <title>Конфигурация IP-сетей</title>
      <sect3 id="network-lect-ip-address"> 
	<title>Сетевой адрес</title>
	<presentation number="6-05" name="сетевой адрес"/>
	<para>
	  В IP-сетях каждому сетевому интерфейсу присваивается некоторый единственный
	  на всю глобальную сеть адрес, который не зависит от среды передачи данных и
	  всегда имеет один и тот же формат. 
	</para>
	<para>
	  Формат адреса зависит от версии протокола. В наиболее распространённой сейчас
	  четвёртой версии <definition id="def-ip-addr" orig="IP-адрес">адрес</definition>
	  состоит из четырёх байт, записываемых традиционно
	  в десятичной системе счисления и разделяемых точкой. Тогда как в шестой
	  версии протокола IP адрес состоит уже из 16 байт и обычно записывается в
	  шестнадцатиричной системе счисления.
	</para>
	<para>
	  IP-адрес сетевого интерфейса <command>eth0</command> из
	  приведенного выше примера&nbsp;&mdash; <systemitem
	  class="ipaddress">192.168.1.5</systemitem>.
	  Второй сетевой интерфейс из примера &mdash; lo &mdash; так называемая заглушка (loopback),
	  которая используется для организации сетевых взаимодействий компьютера с самим
	  собой: любой посланный в заглушку пакет немедленно обрабатывается как принятый
	  оттуда. Заглушке обычно назначается адрес <systemitem
	  class="ipaddress">127.0.0.1</systemitem>.
	</para>
	<para>
	  Для того чтобы назначить интерфейсу IP-адрес, достаточно
	выполнить <command>ifconfig</command>, указав после имени
	интерфейса IP-адрес:
	  <informalexample>       
	    <screen>desktop ~ # ifconfig eth0 192.168.1.1</screen>
	  </informalexample>	  
	</para>
      </sect3>
      <sect3 id="network-lect-ip-routing"> 
	<title>Маршрутизация</title>
	<presentation number="6-06" name="маршрутизация"/>
	<question id="quest-6-3">Как управлять IP-маршрутизацией в UNIX?</question>
	<para>
	  IP-адрес, представленный как последовательность из 32-х 
          битов, подразделяется на две части: адрес
	  подсети и адрес конкретного узла в рамках этой подсети. Для
	  того, чтобы определить, сколько бит в IP-адресе содержат
	  адрес подсети, а сколько&nbsp;&mdash; адрес узла, используется 
	  <emphasis>маска подсети</emphasis>, также состоящая из 32-х битов. Адресу
	  подсети в ней соответствуют единицы, а адресу отдельного
	  узла&nbsp;&mdash; нули. Таким образом, располагая IP-адресом узла назначения и маской
	  подсети, всегда можно определить, относится ли узел
	  назначения к той же подсети. В этом случае пакеты к ним
	  будут доставляться напрямую через канальный уровень. 
	</para>
	<para>
	  Более сложный вопрос встает, если IP-адрес узла-адресата не входит в
	  локальную сеть узла-отправителя. Ведь и в этом случае пакет необходимо
	  отослать какому-то абоненту локальной сети, с тем, чтобы тот перенаправил его
	  дальше. Этот абонент, <emphasis>маршрутизатор</emphasis>, подключен к нескольким
	  сетям, и ему вменяется в обязанность пересылать пакеты между ними по
	  определенным правилам. В самом простом случае таких сетей
	  две: <quote>внутренняя</quote>, к которой подключены компьютеры,
	  и <quote>внешняя</quote>, соединяющая маршрутизатор со всей глобальной
	  сетью. Таблицу, управляющую маршрутизацией пакетов, можно просмотреть с помощью
	  утилиты <command>netstat -r</command> или <command>route</command> (обе утилиты имеют
	  ключ <command>-n</command>, заставляющий их использовать в
	  выдаче IP-адреса, а не имена компьютеров):
	</para>
	<para>
	  <example>
	    <title>Вывод таблицы маршрутизации (<command>route</command>)</title>
	    <screen>desktop ~ # route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0
127.0.0.0       0.0.0.0         255.0.0.0       U     0      0        0 lo
0.0.0.0         192.168.1.1     0.0.0.0         UG    0      0        0 eth0</screen>
	  </example>
	</para>
	<para>
	  Компьютер или аппаратное устройство, осуществляющее маршрутизацию между
	  локальной сетью и Internet обычно называется <definition id="def-gate"
	  orig="шлюз">шлюзом</definition>.
	</para>
	<para>
	  Для изменения таблицы маршрутизации используется та же 
	  утилита <command>route</command>. Утилита
	  <command>ip</command> объединяет возможности как по
	  настройке сетевых интерфейсов, так и таблицы маршрутизации. 
	</para>
      </sect3>
      <sect3 id="network-lect-ip-icmp"> 
	<title>Служебный протокол ICMP</title>
	<presentation number="6-07" name="протокол ICMP"/>
	<para>
	  Есть такие протоколы уровня IP, действие которых этим уровнем и
	  ограничивается. Например, служебный протокол ICMP (Internet Control Message
	  Protocol), предназначенный для передачи служебных сообщений.
	</para>
	<para>
	  Примером применения ICMP является утилита <command>ping</command>, которая
	  позволяет проверить работоспособность узлов в сети. Другое применение
	  ICMP&nbsp;&mdash; сообщать отправителю, почему его пакет невозможно доставить
	  адресату, или передавать информацию об изменении маршрута, о возможности
	  фрагментации и т.&nbsp;п.
	</para>
	<para>
	  Ещё одной задачей, которую можно решить использованием протокола ICMP, является
	  определение маршрута следования пакета. В UNIX существует ряд альтернативных
	  команд для определения приблизительного маршрута прохождения пакета по сети:
	  <command>traceroute</command>, <command>tracepath</command> и т.&nbsp;п.
	</para>
	<para>
	  <example>
	    <title>Пример выполнения команды <command>traceroute</command></title>
	    <screen>desktop ~ # traceroute ya.ru
traceroute to ya.ru (213.180.204.8), 64 hops max, 40 byte packets
 1  195.91.230.65 (195.91.230.65)  0.890 ms  1.907 ms  0.809 ms
 2  cs7206.rinet.ru (195.54.192.28)  0.895 ms  0.769 ms  0.605 ms
 3  ix2-m9.yandex.net (193.232.244.93)  1.855 ms  1.519 ms  2.95 ms
 4  c3-vlan4.yandex.net (213.180.210.146)  3.412 ms  2.698 ms  2.654 ms
 5  ya.ru (213.180.204.8)  2.336 ms  2.612 ms  3.482 ms</screen>
	  </example>
	</para>
	<para>
	  Утилита <command>traceroute</command> показывает список абонентов, через которых проходит пакет по
	  пути к адресату, и затраченное на это время. Однако список этот
	  приблизительный. Строго говоря, неизвестно, каким маршрутом шла очередная группа
	  пакетов, потому что с тех пор, как была отправлена предыдущая группа, какой-нибудь из
	  промежуточных маршрутизаторов мог изменить решение и отправить новые пакеты другим
	  путем.
	</para>
      </sect3>
      <sect3 id="network-lect-ip-tcp"> 
	<title>Информация о соединениях</title>
	<presentation number="6-08" name="сетевые соединения"/>
	<para>
	  Транспортных протоколов в TCP/IP два&nbsp;&mdash; это TCP (Transmission Control
	  Protocol, протокол управления соединением) и UDP (User Datagram Protocol). UDP
	  обеспечивает более высокую скорость обмена данными за счёт
	  простоты устройства. Пользовательские 
	  данные помещаются в единственный транспортный пакет-датаграмму, которой
	  приписываются обычные для транспортного уровня данные: адреса и порты
	  отправителя и получателя, после чего пакет уходит в сеть искать
	  адресата. Проверять, был ли адресат способен этот пакет принять, дошел ли пакет
	  до него и не испортился ли по дороге, предоставляется следующему&nbsp;&mdash;
	  прикладному&nbsp;&mdash; уровню.
	</para>
	<para>
	  Другое дело&nbsp;&mdash; TCP. Этот протокол заботится о том, чтобы
	  передаваемые данные дошли до адресата в целости и сохранности. Для этого
	  предпринимаются следующие действия:
	  <itemizedlist>
	    <listitem>
	      установление соеднинения;
	    </listitem>
	    <listitem>
	      обработка подтверждения корректной доставки;
	    </listitem>
	    <listitem>
	      отслеживание состояния абонентов.
	    </listitem>
	  </itemizedlist>
	</para>
	<para>
	  Для просмотра всех существующих в настоящий момент сетевых соединений можно
	  воспользоваться командой <command>netstat</command>:
	</para>
	<para>
	  <example>
	    <title>Пример выполнения команды <command>netstat</command></title>
	    <screen>desktop ~ # netstat -an
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 0.0.0.0:32769           0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:32770           0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN
tcp        0      0 192.168.11.5:34949      83.149.196.70:5223      ESTABLISHED
tcp        0      0 192.168.11.5:39833      213.248.55.180:5223     ESTABLISHED
tcp        0      0 192.168.11.5:59577      192.168.11.1:22         TIME_WAIT
udp        0      0 0.0.0.0:32768           0.0.0.0:*
udp        0      0 0.0.0.0:32769           0.0.0.0:*
udp        0      0 0.0.0.0:111             0.0.0.0:*</screen>
	  </example>	  
	</para>
	<para>
	  Согласно стандартам Internet для большинства протоколов прикладного уровня
	  существуют <emphasis>стандартные порты</emphasis>, на которых соответствующие
	  приложения должны принимать соединения. Например, веб-сервер, выполняющий
	  обработку соединений по протоколу HTTP, должен работать на порту с номером 80.
	</para>
	<para>
	  В UNIX существует прозрачный механизм именования протоколов прикладного уровня.
	  В файле <filename>/etc/services</filename> можно увидеть список соответствия
	  имён протоколов номерам портов. Этот файл используется базовой системной
	  библиотекой сетевого взаимодействия, так что во всех утилитах вместо номера
	  порта можно указывать имя соответствующего протокола.
	</para>
      </sect3>
      <sect3 id="network-lect-ip-sysinit">
	<title>Настройка сети при загрузке системы</title>
	<para>
	  Для того чтобы каждый раз при загрузке не задавать параметры
	  сетевым интерфейсам,
	  существует возможность задать настройки сети в конфигурационных файлах
	  операционной системы. В этом случае при старте системы будет произведена процедура
	  настройки интерфейсов, заполнена таблица маршрутизации и т.&nbsp;п.
	  Подобные конфигурационные файлы, сохраняющие настройки сети
	  между сеансами работы, а также средства управления ими, не
	  стандартизированы и зачастую различаются в разных версиях UNIX.
	  Конкретные примеры будут рассмотрены на практическом занятии.
	</para>
      </sect3>
    </sect2>    
    <sect2 id="network-lect-internet">
      <title>Службы Internet</title>
      <para>
	<sect3 id="network-lect-internet-dns">
	  <title>Служба доменных имён</title>
	  <presentation number="6-09" name="служба доменных имён"/>
	  <question id="quest-6-4">Что такое служба доменных имён в UNIX? Как
	    она конфигурируется?</question>
	  <para>
	    В предыдущих примерах использовался
	    ключ <parameter class='command'>-n</parameter> многих сетевых утилит, чтобы
	    избежать путаницы между IP-адресами и доменными именами компьютеров. С другой
	    стороны, доменные имена&nbsp;&mdash; несколько слов (часто осмысленных),&nbsp;&mdash;
	    запоминать гораздо удобнее, чем адреса (четыре числа).
	  </para>
	  <para>
	    Когда-то имена всех компьютеров в сети, соответствующие IP-адресам, хранились
	    в файле <filename>/etc/hosts</filename>. Пока абоненты Internet были
	    напересчёт, поддерживать правильность его содержимого не составляло труда. Как
	    только сеть начала расширяться, неувязок стало больше. Трудность была не
	    только в том, что содержимое <filename>hosts</filename> быстро менялось, но и в том, что за
	    соответствие имен адресам в различных сетях отвечали разные люди и разные
	    организации. Появилась необходимость структурировать глобальную сеть не только
	    топологически (с помощью IP-адресов и сетевых масок), но и административно, с
	    указанием, за какие группы адресов кто отвечает.
	  </para>
	  <para>
	    Проще всего было структурировать сами имена компьютеров. Вся сеть была
	    поделена на домены&nbsp;&mdash; зоны ответственности отдельных государств
	    (<literal>us</literal>, <literal>uk</literal>,
	    <literal>ru</literal>, <literal>it</literal> и т.&nbsp;п.) или независимые зоны
	    ответственности (<literal>com</literal>,
	    <literal>org</literal>, <literal>net</literal>,
	    <literal>edu</literal> и т.&nbsp;п.). Для каждого из таких доменов первого уровня
	    должно присутствовать подразделение, выдающее всем абонентам имена,
	    заканчивающиеся на <command>.домен</command> Подразделение обязано организовать и
	    поддерживать службу, заменяющую файл <filename>hosts</filename>: любой желающий имеет право узнать,
	    какой IP-адрес соответствует имени компьютера в этом домене или какому
	    доменному имени соответствует определенный IP-адрес.
	  </para>
	  <para>
	    Такая служба называется DNS (Domain Name
	    Service, <definition id="def-dns">служба доменных имен</definition>). Она
	    имеет иерархическую структуру. Если за какую-то группу абонентов домена
	    отвечают не хозяева домена, а кто-то другой, ему выделяется поддомен (или
	    домен второго уровня), и он сам распоряжается именами вида
	    <filename>имя_компьютера.поддомен.домен</filename>. Таким образом, получается нечто
	    вроде распределенной сетевой базы данных, хранящей короткие записи о
	    соответствии доменных имен IP-адресам.
	  </para>
	  <para>
	    В самом простом случае для того, чтобы сказать системе, какой сервер доменных
	    имён использовать, необходимо изменить
	    файл <filename>/etc/resolv.conf</filename>. В более сложных системах можно
	    установить и настроить собственный сервер доменных имён.
	  </para>
	  <para>
	    Для проверки работы системы DNS используются утилиты <command>dig</command>
	    и <command>host</command>. 
	  </para>
	</sect3>
	<sect3 id="network-lect-internet-rsh">
	  <title>Удалённый терминал</title>
	  <presentation number="6-10" name="удалённый терминал"/>
	  <para>
	    Концепция <emphasis>терминала</emphasis>, описанная в главе
	    <xref linkend="shell-base-terminal"/>, может быть
	    расширена с учетом подключения к локальной и глобальной
	    сети. Действительно, было бы удобно получить доступ к удалённой машине и
	    работать с ней как за обычными монитором и клавиатурой. Отпадает необходимость
	    иметь аппаратный терминал к каждому компьютеру, можно
	    получить терминал на одном компьютере, затем получить
	    доступ к <definition id="def-remote-terminal" orig="удалённый
	    терминал">удаленному терминалу</definition> по сети на любой другой компьютер. В
	    современных условиях повсеместного распространения сети Internet удалённые терминалы
	    становятся основным рабочим инструментом администратора системы.
	  </para>
	  <para>
	    В сетях TCP/IP существует несколько приложений,
	    предоставляющих доступ к системе посредством удаленного
	    терминала. Рассмотрим два из них: <application>telnet</application>
	    и <application>ssh</application>. Оба построены по единому клиент-серверному
	    принципу.
	  </para>
	  <para>
	    Telnet&nbsp;&mdash; стандартное приложение, которое присутствует практически в
	    каждой реализации TCP/IP. Оно может быть использовано для связи между узлами,
	    работающими под управлением различных операционных систем. Telnet использует
	    согласование настроек клиента и сервера, чтобы определить характеристики
	    системы с той и с другой стороны.
	  </para>
	  <para>
	    Клиент telnet взаимодействует и с пользователем, находящимся за терминалом, и
	    с протоколами TCP/IP. Обычно все, что пользователь вводит с клавиатуры,
	    отправляется по TCP-соединению, а все, что приходит по соединению, выводится на
	    терминал.
	  </para>
	  <para>
	    Сервер telnet обычно взаимодействует с так называемыми псевдотерминальными
	    устройствами в UNIX системах. Это делает его похожим на командный
	    интерпритатор (shell), который запускается на сервере, или на любую программу,
	    которая запускается из командной оболочки, так как они
	    аналогичным образом взаимодействуют с
	    терминальными устройствами.
	  </para>
	  <para>
	    Клиент telnet имеет еще одно полезное применение. С его помощью можно
	    тестировать стандартные сетевые протоколы&nbsp;&mdash; если в качестве порта
	    назначения указать порт соответствующего приложения. Telnet пересылает
	    текстовые строки, разделённые знаками переноса строки, что делает его
	    совместимым со многими протоколами Internel (SMTP, HTTP и т.&nbsp;п.).
	  </para>
	  <para>
	    Программа telnet обладает значительным
	    недостатком&nbsp;&mdash; вся передаваемая информация
	    (в том числе аутентификация пользователей) пересылается открытым
	    текстом. В современных условиях глобальной сети это уже небезопасно.
	    Эту проблему решает программа ssh, которая предоставляет
	    функциональность, аналогичную telnet, но при этом
	    устанавливает защищённое соединение, в котором все
	    передаваемые данные зашифрованы.
	  </para>
	  <para>
	    В настоящее время для удалённого администрирования серверов в Internet
	    повсеместно применяется ssh.
	  </para>
	</sect3>
	<sect3 id="network-lect-internet-proxy">
	  <title>Прокси-серверы</title>
	  <para>
	    <definition id="def-proxy"
	    orig="прокси-сервер">Прокси-сервер</definition>&nbsp;&mdash; специальная
	    служба, расположенная между локальной сетью и Internet, которая обеспечивает
	    доступ в Internet по протоколам прикладного уровня (HTTP,
	    FTP и т.&nbsp;п.) для всех узлов локальной сети.
	    Такой сервер может поддерживать аутентификацию пользователей, учёт и
	    фильтрацию трафика. 
	  </para>
	  <para>
	    Недостатком такой схемы является то, что клиент в локальной сети должен явным
	    образом устанавливать соединение с прокси-сервером для запроса к удаленному
	    узлу в Internet.
	  </para>
	</sect3>
      </para>
    </sect2>    
    <sect2 id="network-lect-firewall">
      <title>Межсетевой экран</title>
      <presentation number="6-11" name="межсетевой экран iptables"/>
      <question id="quest-6-5">Какие функции выполняет межсетевой экран? Каковы принципы 
      управления межсетевым экраном iptables?</question>
      <para>
	В UNIX существует мощный механизм анализа сетевых и транспортных пакетов,
	позволяющий избавляться от нежелательной сетевой активности, манипулировать
	потоками данных и даже преобразовывать служебную информацию в них. Обычно такие
	средства носят название firewall (<quote>fire wall</quote>&nbsp;&mdash;
	противопожарная стена, брандмауэр), общепринятый русский
	термин&nbsp;&mdash; <definition id="def-firewall">межсетевой экран</definition>.
      </para>
      <para>
	В различных версиях UNIX функциональность и управление межсетевым экраном может
	значительно различаться. В семействе операционных систем BSD используются
	программы <command>ipfw</command> и <command>pf</command>. В
	данном курсе будет рассматриваться приложение <command>iptables</command>,
	которое используется для организации межсетевого экрана в Linux.
      </para>
      <sect3 id="network-lect-firewall-iptables">
	<title>Концепции iptables</title>
	<para>
	  Суть <command>iptables</command> в следующем. Обработка сетевого пакета
	  системой представляется как его конвейерная обработка. Пакет нужно получить из
	  сетевого интерфейса или от системного процесса, затем следует выяснить
	  предполагаемый маршрут этого пакета, после чего отослать его через сетевой
	  интерфейс либо отдать какому-нибудь процессу, если пакет предназначался нашему
	  компьютеру. Налицо три конвейера обработки пакетов: <quote>получить&nbsp;&mdash;
	  маршрутизировать&nbsp;&mdash; отослать</quote> (действие
	  маршрутизатора), <quote>получить&nbsp;&mdash; маршрутизировать&nbsp;&mdash;
	  отдать</quote> (действие при получении пакета процессом)
	  и <quote>взять&nbsp;&mdash; маршрутизировать&nbsp;&mdash; отослать</quote>
	  (действие при отсылке пакета процессом).
	</para>
	<para>
	  Между каждыми из этих действий системы помещается модуль межсетевого экрана,
	  именуемый <definition id="def-chain"
	  orig="цепочка">цепочкой</definition>. Цепочка обрабатывает пакет, исследуя,
	  изменяя и даже, возможно, уничтожая его. Если пакет уцелел, она передает его
	  дальше по конвейеру. В этой стройной схеме есть два исключения. Во-первых, ядро
	  Linux дает доступ к исходящему пакету только после принятия решения о его
	  маршрутизации, поэтому связка <quote>взять&nbsp;&mdash; маршрутизировать</quote>
	  остается необработанной, а цепочка, обрабатывающая исходящие пакеты (она
	  называется OUTPUT) вставляется после маршрутизации. Во-вторых, ограничения
	  на <quote>чужие</quote> пакеты, исходящие не от нас и не для нас
	  предназначенные, существенно отличаются от ограничений на
	  пакеты <quote>свои</quote>, поэтому после маршрутизации транзитные пакеты
	  обрабатываются еще одной цепочкой (она называется FORWARD). Цепочка,
	  обслуживающая связку <quote>получить&nbsp;&mdash; маршрутизировать</quote>,
	  называется PREROUTING, цепочка, обслуживающая
	  связку <quote>маршрутизировать&nbsp;&mdash; отдать</quote>&nbsp;&mdash; INPUT, а
	  цепочка, стоящая непосредственно перед отсылкой пакета&nbsp;&mdash; POSTROUTING
	  (см. <xref linkend="img-iptables"/>).
	</para>
	<para>
	  <figure id="img-iptables">
	    <title>Обработка пакета в iptables</title>
	    <graphic fileref="&BASEIMAGES;iptables.png"/>
	  </figure>	
	</para>
	<para>
	  Каждая цепочка представляет собой список правил,
	  последовательно применяемых к анализируемому пакету. Каждое
	  правило описывает некоторый набор свойств пакета и указывает
	  действие, которое нужно произвести над пакетом с такими свойствами.
	  Если пакет не имеет свойств, задаваемых первым правилом, к нему применяется
	  второе, если второе также не подходит&nbsp;&mdash; третье, и так вплоть до
	  последнего, правила по умолчанию, которое применяется к любому пакету. Если
	  свойства пакета удовлетворяют правилу, над ним совершается
	  указанное в правиле действие. Действие
	  DROP уничтожает пакет, а действие ACCEPT немедленно выпускает его из таблицы,
	  после чего пакет движется дальше по конвейеру. Некоторые действия, например LOG,
	  никак не влияют на судьбу пакета, после их выполнения он остается в таблице: к
	  нему применяется следующее правило, и т.&nbsp;д. до ACCEPT или DROP.
	</para>
	<para>
	  Одной из важных функций сетевого экрана является подмена адресов и модификация
	  сетевых пакетов. <definition id="def-nat">NAT</definition>
	  (Network Address Translation&nbsp;&mdash; подмена сетевых адресов)&nbsp;&mdash;
	  это механизм, позволяющий организовать передачу пакетов между сетями, не
	  имеющими сведений о сетевых адресах друг друга. Этот процесс, чем-то схожий с
	  маршрутизацией, позволяет организовывать шлюзы локальных сетей в Internet,
	  распределять внешние соединения на отдельные машины внутри сети и т.&nbsp;п.
	</para>
	<para>
	  Следует помнить, что чем больше транспортных соединений отслеживается
	  межсетевым экраном, тем больше требуется оперативной памяти ядру Linux и тем
	  медленнее работает процедура сопоставления проходящих пакетов таблице. Впрочем,
	  мощность современных компьютеров позволяет без каких-либо затруднений
	  обслуживать преобразование адресов для сети с пропускной способностью 100Мбит/с
	  и даже выше.
	</para>
	<para>
	  Таким образом, администратору доступны несколько различных
	  средств воздействия на проходящие в системе сетевые пакеты и
	  установленные сетевые соединения:
	  фильтрация, подмена адресов, изменение различных параметров пакетов.
	  Пример организации межсетевого экрана будет рассмотрен на практическом занятии.
	</para>
      </sect3>
    </sect2>    
    <sect2 id="network-lect-summary">
      <title>Резюме</title>
      <presentation number="6-12" name="резюме"/>
      <para>
	Сеть состоит из различных аппаратно-программных узлов, для объединения которых
	используются стандартные протоколы. Эталонной моделью взаимодействия таких систем
	является семиуровневая модель OSI.
      </para>
      <para>
	Протокол TCP/IP частично реализует уровни OSI. Основные протоколы IP (сетевого
	уровня) и TCP (транспортного уровня) позволили объединить разрозненные локальные
	сети в глобальную сеть Internet.
      </para>
      <para>
	В UNIX основной сетевого взаимодействия является интерфейс, который находится
	между канальным и сетевым уровнем. Конфигурация TCP/IP включает в себя настройку
	интерфейса, маршрутизации и сервисов Internet, в первую очередь сервера доменных
	имен. 
      </para>
      <para>
	Для удаленного управления компьютерами используется программа telnet и её
	современный защищённый аналог&nbsp;&mdash; ssh.
      </para>
      <para>
	Важным элементом сетевой инфраструктуры является межсетевой экран, который
	позволяет ограничить сетевой трафик и изменить его свойства. На лекции был
	рассмотрен межсетевой экран Linux&nbsp;&mdash; iptables.
      </para>
      <list-of-definitions/>
    </sect2>    
    <sect2 id="network-lect-additional">
      <title>Дополнительные материалы</title>
      <para>
	<orderedlist>
	  <listitem>
	    Олифер В.Г., Олифер Н.А. <emphasis>Компьютерные сети. Принципы, технологии,
	    протоколы</emphasis>.&nbsp;&mdash; СПб.: Питер, 2002.&nbsp;&mdash; 672 с.:
	    ил.
	  </listitem>
	  <listitem>
	    Курячий Г.В., Маслинский К.А. <emphasis>Операционная система
	    Linux</emphasis>.&nbsp;&mdash; М.: Интуит.Ру, 2005.&nbsp;&mdash; 392 с.: ил.
	  </listitem>
	</orderedlist>
      </para>
    </sect2>    
    <list-of-questions id="network-lect-questions"/>
    <small-presentation id="network-lect-presentaion"/>
  </sect1>

