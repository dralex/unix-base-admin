<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
	  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [

	  <!ENTITY % CommonEntities PUBLIC
		   "-//IU7 LUG//ENTITIES Common Documentation//RU"
		   "common.ent">
	  %CommonEntities;
	  
	  <!ENTITY BASEIMAGES "images/">

]>

<sect1 id="shell-base">
  <title>Терминал и командная строка</title>
  <presentation number="4-01" name="терминал и командная строка"/>
  
  <para>
    Основным интерфейсом взаимодействия пользователя с операционной 
    системой UNIX во всех её модификациях была и остается 
    <emphasis>командная строка</emphasis>. Суть этого интерфейса
    состоит в <emphasis>обмене текстами</emphasis> с системой:
    пользователь набирает текстовые команды, а операционная система
    возвращает ему информацию также в текстовом виде.
    Несмотря на то, что в современных UNIX-системах широко
    используются графические пользовательские интерфейсы, командная строка остаётся
    основным рабочим инструментом администратора системы. Причина
    этого не в каких-то особенных вкусах администраторов, а в том,
    что в UNIX-подобных системах командная строка очень хорошо
    выполняет задачи интерфейса управления системой, она эффективна
    и удобна&nbsp;&mdash; и именно поэтому всеми используется.
    Этому есть разумное объяснение&nbsp;&mdash; командная строка позволяет администратору
    управлять системой, совершая меньшее количество действий
    (<emphasis>интерфейсных жестов</emphasis>), чем с помощью графического интерфейса
    и мыши. Немаловажно и то, что администратор может объединять
    сложные последовательности действий в сценарии. 
  </para>
  
  <sect2 id="shell-base-terminal">
    <title>Терминал</title>
    <question id="quest-4-1">Что такое терминал? Какие бывают терминалы?</question>

    <para>
      Текстовый принцип работы с системой позволяет отвлечься от конкретных частей
      компьютера, вроде клавиатуры и видеокарты с монитором, рассматривая
      единое оконечное устройство, посредством которого пользователь вводит текст и
      передает его системе, а система выводит необходимые пользователю данные и
      сообщения. Такое устройство называется <definition id="def-terminal"
	orig="терминал">терминалом</definition>. В общем случае терминал&nbsp;&mdash; это
      точка входа пользователя в систему, обладающая способностью передавать текстовую
      информацию. 
    </para>
    <para>
      Прототипом такого устройства был <emphasis>телетайп</emphasis>, 
      который стал использоваться
      в качестве средства обмена данными с компьютером еще в 1950-е годы.
      В современных компьютерах для организации интерфейса командной строки 
      используется клавиатура и экран монитора, работающий в текстовом режиме.
      Терминалом может быть и отдельное внешнее устройство, подключаемое к
      компьютеру через порт последовательной передачи данных
      (COM-порт). 
    </para>
    <para>
      Современные UNIX-системы предоставляют графические пользовательские
      интерфейсы (подробнее графическая подсистема UNIX рассматривается в разделе
      <xref linkend="chapter-x-windows"/>), которые также дают возможность работы в
      командной строке. Эта возможность достигается с помощью
      <definition id="def-xterms" orig="графический терминал">графических
	терминалов</definition>&nbsp;&mdash; специальных программ, которые эмулируют
      текстовый терминал в графическом окне.
    </para>
    <para>
      Роль терминала может с успехом выполнять и программа,
      исполняющаяся на сколько угодно удалённом компьютере, связанным
      с UNIX-системой, например, посредством сети
      Интернет. В современной практике такой способ доступа очень
      широко используется для удалённой работы, в особенности для
      администрирования серверов, которые зачастую устанавливаются в специальных
      помещениях, доступ в которые затруднен и нежелателен.
    </para>
    
    <sect3 id="terminal-escape-chars">
      <title>Управляющие символы</title>
      
      <para>
	Свойство терминала передавать только текст (иначе говоря, последовательности
	символов) приводит к необходимости кодировать операции по управлению вводом 
	и выводом текста также с помощью специальных символов: 
	удаление неправильно введённых символов, команда 
	передать введённый текст системе, перевод строки, графическое 
	выделение выведенного текста и т.&nbsp;п. Такие символы объединяют 
	понятием <definition id="def-control-chars">управляющие символы</definition>.
      </para>
      <para>
	Часть управляющих символов вводится специальными клавишами, предусмотренными
	для управления вводом текста, такими как Backspace и Enter.
	Управляющих символов может быть больше, чем нетекстовых клавиш 
	на клавиатуре, в этом случае их необходимо извлекать с помощью
	какого-либо клавиатурного модификатора, например,
	<keycap>Ctrl</keycap>. 
      </para>
      <para>
	Количество различных управляющих символов зачастую
	ограничено и оказывается меньше количества необходимых 
	терминалу команд. В этом случае для передачи команд используются 
	<definition id="def-control-seq" orig="управляющая
	  последовательность">управляющие последовательности</definition>, которые
	начинаются управляющим символом, за которым следует строго определенное число
	обычных символов, в данном случае интерпретируемых терминалом
	как та или иная команда.
      </para>
      <para>
	Специальные управляющие символы могут быть также зарезервированы
	для команд межпроцессного взаимодействия (передачи сигналов).
	В частности, для завершения командной оболочки можно использовать
	символ конца ввода 
	<keycombo><keycap>Ctrl</keycap><keycap>D</keycap></keycombo>. 
	Эту команду интерпретирует при вводе с терминала система. Она же
	превращает некоторые другие управляющие символы
	(например, <keycombo><keycap>Ctrl</keycap>
	  <keycap>C</keycap></keycombo>&nbsp;&mdash; <quote>прерывание</quote> или 
	<keycombo><keycap>Ctrl</keycap>
	  <keycap>Z</keycap></keycombo>&nbsp;&mdash; <quote>засыпание</quote>) в
	соответствующие сигналы.
      </para>
      <para>
	Одной из полезных особенностей терминала является возможность
	его <quote>прокрутки</quote> с помощью
	клавиш <keycombo><keycap>Shift</keycap><keycap>PgUp</keycap></keycombo>
	и <keycombo><keycap>Shift</keycap><keycap>PgDn</keycap></keycombo>. Это может быть
	полезно, если вывод программы занимает больший объём, чем размер экрана.
      </para>
      <!--FIXME: может, добавить пару слов про псевдотерминалы (pty)? но только если кратко -->
      <para>
	Каждое устройство или программа, выполняющие функции терминала, 
	имеет свои <emphasis>возможности</emphasis> по вводу и
	выводу информации. Примерами таких возможностей являются: число цветов
	отображения, способность перемещать курсор и изменять размер экрана, набор
	управляющих символов и т.&nbsp;п. При этом для операционной системы 
	важна возможность работать с любыми терминалами одинаковым способом. 
	Для этого в операционных системах семейства UNIX вводится понятие
	<definition id="def-termtype" orig="тип терминала">тип терминала</definition>:
	каждый тип сводится к набору возможностей, регламентированных в
	специальном конфигурационном файле. Информация о всех существующих 
	типах терминалов хранится в специализированной базе данных 
	(terminfo или termcap). Примерами типов являются: tty (телетайп) или
	xterm (графический терминал). 
      </para>
      </sect3>

    <sect3 id="shell-base-vc">
      <title>Одновременный доступ к системе</title>
      <presentation number="4-02" name="одновременный доступ к системе"/>
      <para>
	То, что UNIX&nbsp;&mdash; многопользовательская и многозадачная система,
	проявляется не только в разграничении прав доступа (см. раздел
	<xref linkend="security-lect"/>), но и в организации рабочего места:
	ничто не препятствует подключить к операционной системе произвольное
	число терминалов одновременно, в особенности, если функции терминала
	выполняет программа. Благодаря этому каждый
	компьютер, на котором работает UNIX, предоставляет возможность зарегистрироваться
	и получить доступ к системе с нескольких терминалов одновременно. Даже если в
	распоряжении всех пользователей есть только один монитор и одна системная
	клавиатура, эта возможность небесполезна: одновременная регистрация в системе
	на нескольких терминалах позволяет работать поочередно с несколькими 
	задачами без необходимости каждый раз их завершать и затем возобновлять. 
      </para>
      <para>
	Характерный для современных версий UNIX способ организации параллельной работы
	пользователей&nbsp;&mdash; <definition id="def-vc" orig="виртуальная
	  консоль">виртуальные консоли</definition>. Виртуальные консоли (virtual
	console)&nbsp;&mdash; это несколько параллельно выполняемых операционной системой
	программ, предоставляющих пользователю возможность зарегистрироваться в системе в
	текстовом режиме и получить доступ к командной строке
	(см. <xref linkend="img-virtual-consoles"/>).
      </para>
      <para>
	Например, в операционной системе Linux переключение между виртуальными консолями в текстовом
	режиме производится с помощью комбинации клавиш
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>, 
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo> и т.&nbsp;п. При этом
	каждая виртуальная консоль обозначается специальным
	именем: <filename>tty1</filename>, <filename>tty2</filename> и т.&nbsp;д. По умолчанию в Linux
	доступно не менее шести виртуальных консолей, переключаться между которыми можно
	при помощи сочетания клавиши <keycap>Alt</keycap> с одной из функциональных клавиш
	(<keycap>F1</keycap>-<keycap>F6</keycap>). С каждым сочетанием связана
	соответствующая по номеру виртуальная консоль. Виртуальные консоли обозначаются
	<filename>ttyN</filename>, где <literal>N</literal>&nbsp;&mdash; номер виртуальной консоли.
	На самом деле, каждая из таких конcолей связана с
	собственным <emphasis>терминалом</emphasis>, который характеризуется файлом
	устройства с соответствующим именем (например, <filename>/dev/tty1</filename>).
      </para>
      <para>
	Также существует возможность запуска нескольких графических подсистем, тогда
	переключение между ними будет осуществляться аналогично переключению между
	виртуальными консолями&nbsp;&mdash; комбинацией клавиш 
	<keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap>
	  <keycap>F1</keycap></keycombo>.
      </para>
      <para>
	<figure id="img-virtual-consoles">
	  <title>Виртуальные и графические консоли</title>
	  <graphic fileref="&BASEIMAGES;virtual_consoles.png"/>
	</figure>
      </para>
    </sect3>
  </sect2>
  
  <sect2 id="shell-base-shellfeat">
    <title>Командная строка</title>
    <question id="quest-4-2">Командная строка UNIX: из каких частей состоит, основные
      управляющие клавиши, примеры команд?</question>
    <para>
      Основная среда взаимодействия с
      UNIX&nbsp;&mdash; <definition id="def-command-string">командная
	строка</definition>. Суть её в том, что каждая строка, передаваемая пользователем
      системе,&nbsp;&mdash; это команда, которую та должна выполнить. Пока не нажата
      клавиша
      <keycap>Enter</keycap>, строку можно редактировать, затем она отсылается системе.
    </para>
    <sect3 id="shell-base-shell">
      <title>Командная оболочка</title>
      <para>
	Команды, введённые пользователем, интерпретируются и выполняются специальной программой&nbsp;&mdash;
	<definition id="def-command-shell" orig="командная оболочка">командной
	  оболочкой</definition> (shell). Через командную
	оболочку производится управление пользовательскими процессами&nbsp;&mdash; для
	этого используются средства межпроцессного обмена, описанные ранее
	(см. <xref linkend="intro-unixproc-interproc"/>).
      </para>
      <para>
	Ввод и вывод командной оболочки непосредственно связаны с терминалом, через который
	осуществляется передача управляющих последовательностей и текста от пользователя и обратно. На рисунке
	<xref linkend="img-terminal"/> представлена общая схема взаимодействия пользователя
	с системой при работе с командной строкой.
      </para>
      <para>
	Существует несколько различных командных оболочек, используемых для 
	управления системой в UNIX, далее в примерах мы будем рассматривать
	<application>bash</application>&nbsp;&mdash; самую распространенную
	современную командную оболочку.
      </para>    
      <para>
	<figure id="img-terminal">
	  <title>Интерфейс командной строки</title>
	  <graphic fileref="&BASEIMAGES;terminal.png"/>
	</figure>
      </para>
    </sect3>
    <sect3 id="shell-base-cmd-prompt">
      <title>Приглашение</title>
      <para>
	Для удобства пользователя командная строка оформляется в виде 	
	<definition id="def-command-prompt" orig="приглашение">приглашения</definition>
	&mdash; специальной последовательности символов,
	которую командная оболочка выводит на терминал в знак того, что она готова 
	принять очередную команду.
	Заодно приглашение командной строки служит целям визуальной организации 
	интерфейса пользователя: прежде всего, она указывает область 
	экрана, где будет отображаться вводимая пользователем команда 
	(непосредственно справа от приглашения, в той же строке), кроме того, 
	в приглашении принято помещать информацию о некоторых текущих свойствах 
	командной оболочки (имени пользователя, текущем каталоге и т.&nbsp;п.)&nbsp;&mdash; такая
	информация выполняет роль <quote>подсказок</quote> пользователю, которые 
	облегчают ориентацию в интерфейсе.
      </para>
      <para>
	<example>
	  <title>Пример выполнения команды</title>
	  <screen>user@desktop ~ $ date
Втр Окт  4 23:15:37 MSD 2005
user@desktop ~ $</screen>
	</example>
      </para>
      <para>
	Здесь приглашением является строка <command>user@desktop ~ $</command>, которая
	содержит: имя пользователя, с правами которого исполняется командная оболочка 
	(<command>user</command>), имя компьютера
	(<command>desktop</command>), имя текущего каталога (<literal>~</literal>, этим символом 
	в командных оболочках UNIX принято обозначать домашний каталог пользователя).
	Заканчивается приглашение символом начала ввода <literal>$</literal>, который, по существу, 
	является единственным обязательным элементом приглашения и показывает, собственно, 
	готовность командной оболочки к вводу команды. 
	В качестве символа начала ввода могут выступать разные символы, но чаще 
	всего используется именно <literal>$</literal> для обозначения командной строки обычного
	пользователя и символ <literal>#</literal> для обозначения командной строки суперпользователя
	(root).
	Пользователь имеет возможность произвольным образом изменить оформление
	приглашения командной строки.
      </para>
    </sect3>

    <sect3 id="shell-base-cmd-format">
      <title>Команды</title>

      <presentation number="4-03" name="формат команды"/>
      
      <para>Приведенный выше пример демонстрирует простейшую команду, которая
	состоит только из <definition id="def-cmd-name" orig="имя команды">имени
	  команды</definition>: <command>date</command>. Для исполнения этой команды командная
	оболочка находит и запускает программу, имя которой совпадает с именем
	команды. В данном примере это утилита date, которая и выводит на терминал
	пользователя информацию о текущей дате и времени. Некоторые команды
	(такие как <command>echo</command>) являются <definition
	  id="def-internal-cmd" orig="встроенная
	  команда">встроенными</definition> для данной командной оболочки, и для
	их выполнения вызывается не программа, а внутренняя функция оболочки.
      </para>
      
      <para>
	В качестве имени команды, помимо внешней программы и встроенной функции, 
	может выступать еще и 
	<definition id="def-alias" orig="псевдоним">псевдоним</definition> (alias). 
	Псевдонимы &mdash; это определяемые пользователем сокращения, позволяющие
	заменить длинную, но часто используемую команду, более короткой. 
	В конфигурационных файлах командного интерпретатора пользователя
	обычно уже определено несколько сокращений, список которых можно посмотреть с
	помощью команды <command>alias</command> без параметров:
      </para>
      <para>
	<screen>user@desktop ~ $ alias
alias cp='cp -i'
alias l='ls -lapt'
alias ll='ls -laptc'
alias ls='ls --color=auto'
alias md='mkdir'
alias mv='mv -i'
alias rd='rmdir'
alias rm='rm -i'</screen>
      </para>
      <para>
	Например, по команде <command>ls</command> вместо
	утилиты <filename>/bin/ls</filename> <application>bash</application>
	запускает собственную команду-сокращение, превращающуюся в команду
	<command>ls --color=auto</command>. Повторно появившуюся в команде подстроку
	"ls" интерпретатор уже не обрабатывает, во избежание вечного цикла. Например,
	команда <command>ls -al</command> превращается в результате
	в <command>ls --color=auto -al</command>.
      </para>
      <para>
	Сокращения не наследуются с окружением.
      </para>
    </sect3>
 
    <sect3 id="shell-base-parameters">
      <title>Параметры</title>
      <para>
	Однако команды UNIX могут быть устроены и более сложным образом, когда необходимо
	не только выполнить внешнюю программу, но и передать ей какую-то дополнительную
	информацию, чтобы так или иначе модифицировать ее работу.
	Модификаторы поведения в этом случае вводятся в командной строке после имени 
	команды&nbsp;&mdash; это <definition id="def-cmd-params" orig="параметры
	  команды">параметры команды</definition>. Параметров может быть произвольное 
	количество (оно зависит только от смысла передаваемой внешней программе информации),
	друг от друга параметры отделяются пробелами. Параметры будут переданы программе
	в том порядке, в котором они указаны в командной строке.
      </para>
      <para>
	  <example>
	    <title>Пример выполнения команды c параметром</title>
	    <screen>user@desktop ~ $ cal 1 2006
    Января 2006     
Вс Пн Вт Ср Чт Пт Сб
 1  2  3  4  5  6  7
 8  9 10 11 12 13 14
15 16 17 18 19 20 21
22 23 24 25 26 27 28
29 30 31</screen>
	  </example>
	</para>

      <para>
	Командная оболочка передает внешней программе ее параметры 
	не в виде единой строки, как их ввел пользователь, а в виде 
	упорядоченного списка (первый параметр, второй параметр...). 
	Для этого командную строку необходимо разбить на отдельные 
	<quote>слова</quote>.
	При разбиении на слова командная оболочка использует понятие разделитель (delimiter). 
	Разделитель&nbsp;&mdash; это символ, разделяющий слова; таким образом, 
	командная строка&nbsp;&mdash; это последовательность слов (которые имеют
	значение) и разделителей (которые значения не имеют). Для командной оболочки
	разделителями являются символ пробела, символ табуляции и символ перевода строки.
	Количество разделителей между двумя соседними словами значения не имеет. 
	Если необходимо передать в качестве параметра строку, содержащую 
	символы-разделители, необходимо эту строку окружить одинарными или двойными 
	кавычками.
      </para>
      <para>
	  <screen>user@desktop ~ $ echo "Hello, world."
Hello, world.</screen>
      </para>

      <para>
	Параметры, которые могут быть переданы команде, подразделяются на два вида: первые
	&mdash; это внешние объекты, с которыми должна работать вызываемая команда
	(например, имена файлов, числа), вторые&nbsp;&mdash; это принимаемые программой
	модификаторы поведения.  Последовательность в командной строке обычно такая:
	<emphasis>имя команды &mdash; модификаторы &mdash; объект(ы)</emphasis>, где и
	модификаторы, и объекты необязательны.
      </para>
      <para>
	В программах для UNIX параметры-модификаторы принято называть <definition
	id="def-key" orig="ключ">ключами</definition> (а также опциями и иногда флагами).
	Для формата ключей нет жёсткого стандарта, однако существуют договорённости,
	нарушать которые не принято. Однобуквенные ключи должны начинаться с символа
	<literal>-</literal> (как <command>-h</command>), такие ключи
	можно объединять: <command>du -s -h</command> и <command>du -sh</command>
	эквивалентны. Другой вид ключей&nbsp;&mdash; полнословные&nbsp;&mdash; начинается
	с двух символов <literal>-</literal>
	(например, <command>--help</command>, который чаще всего
	выдаёт подсказку).  Особый вид
	ключей&nbsp;&mdash; <emphasis>параметрические</emphasis>, которые принимают
	собственный параметр: например, в команде
	<command>grep -f access.log -n test</command> имя файла
	<filename>access.log</filename>&nbsp;&mdash; часть параметра
	<command>-f</command>.
      </para>
      <para>
	Проблемы могут возникнуть, если с символа <literal>-</literal>
	начинается не ключ, а обычный параметр, например, имя файла. В
	этом случае команда может интерпретировать этот параметр как
	ключ, что повлечет ошибку. Для выхода из этой ситуации
	используется специальная конструкция <literal>--</literal>,
	указывающая, что список ключей закончен, и любые последующие
	строки следует интерпретировать как параметры. Например:
      </para>
      <para>
	<screen>user@desktop ~ $ ls -l -- -test-file
-rw-r--r--   1 user  users      90 Сен 19 00:20 -test-file</screen>
      </para>

    </sect3>

      <sect3 id="shell-base-shellfeat-templates">
	<title>Шаблоны</title>
	<para>
	  Если же нужно работать сразу с несколькими объектами, например,
	  перемещать группу файлов в другой каталог, перечислять их
	  все в качестве параметров команды перемещения будет
	  неэффективно. Необходим способ задать одно <quote>общее</quote> имя
	  для группы файлов, с которыми будет работать команда. В подавляющем большинстве
	  случаев это можно сделать при помощи <definition id="def-template"
	  orig="шаблон">шаблона</definition>.
	</para>
	<para>
	  Шаблон в командном интерпретаторе используется примерно в тех же целях, что и
	  регулярное выражение, которое будет описано в разделе
	  <xref linkend="shell-maincmd-text-regexp"/>: для поиска строк определенной
	  структуры среди множества разнообразных строк. В отличие от регулярного
	  выражения, шаблон всегда примеряется к строке целиком, кроме того, он устроен
	  значительно проще (а значит, и беднее).
	</para>
	<para>
	  Символы в шаблоне разделяются на обычные и специальные. Обычные символы
	  соответствуют таким же символам в строке, а специальные&nbsp;&mdash;
	  обрабатываются особым образом:
	</para>
	<para>
	  <itemizedlist>
	    <listitem>
	      <para>
		Шаблону, состоящему только из обычных символов, соответствует единственная
		строка, состоящая из тех же символов в том же порядке. Например, шаблону
		<command>abc</command> соответствует строка <literal>abc</literal>, но
		не <literal>aBc</literal> или <literal>ABC</literal>, потому что большие и
		маленькие буквы различаются.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		Шаблону, состоящему из единственного спецсимвола <literal>*</literal>,
		соответствует любая строка любой длины (в том числе и пустая).
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		Шаблону, состоящему из единственного спецсимвола <literal>?</literal>,
		соответствует любая строка длиной в один символ,
		например, <literal>a</literal>, <literal>+</literal>
		или <literal>@</literal>, но не <literal>ab</literal>
		или <literal>8888</literal>.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		Шаблону, состоящему из любых символов, заключенных в квадратные
		скобки <literal>[</literal> и <literal>]</literal> соответствует строка длиной в
		один символ, причем этот символ должен встречаться среди заключенных в
		скобки. Например, шаблону <command>[bar]</command> соответствуют только строки
		<literal>a</literal>, <literal>b</literal> и <literal>r</literal>, но не
		<literal>c</literal>, <literal>B</literal>, <literal>bar</literal> или
		<literal>ab</literal>. Символы внутри скобок можно не перечислять
		полностью, а задавать диапазон, в начале которого стоит символ с
		наименьшим ASCII-кодом, затем следует <literal>-</literal>, а
		затем&nbsp;&mdash; символ с наибольшим ASCII-кодом. Например, шаблону
		<command>[0-9a-fA-F]</command> соответствует одна шестнадцатеричная цифра
		(скажем, <literal>5</literal>, <literal>e</literal>
		или <literal>C</literal>). Если после <literal>[</literal> в шаблоне
		следует <literal>!</literal>, то ему соответствует строка из одного символа,
		не перечисленного между скобками.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		Шаблону, состоящему из нескольких частей, соответствует строка, которую
		можно разбить на столько же подстрок (возможно, пустых), причем первая
		подстрока будет отвечать первой части шаблона, вторая&nbsp;&mdash; второй
		и т.&nbsp;д. Например, шаблону <command>a*b?c</command> будут соответствовать
		строки <literal>ab@c</literal> (<literal>*</literal> соответствует пустая
		подстрока), <literal>a+b=c</literal> и <literal>aaabbc</literal>, но не
		будут соответствовать <literal>abc</literal> (<literal>?</literal>
		соответствует подстрока <literal>c</literal>, а для <literal>c</literal>
		соответствия не находится), <literal>@ab@c</literal> (нет соответствия для
		<literal>a</literal>) или <literal>aaabbbc</literal> (из
		трех <literal>b</literal> первое соответствует <literal>b</literal>,
		второе&nbsp;&mdash; <literal>?</literal>, а вот третье приходится
		на <literal>c</literal>).
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>
	<para>
	  Шаблоны используются в нескольких конструкциях shell. Главное место их
	  применения&nbsp;&mdash; командная строка. Если оболочка <quote>видит</quote> в
	  командной строке шаблон, она немедленно заменяет его списком файлов, имена
	  которых ему соответствуют. Команда, которая затем вызывается, получает в
	  качестве параметров список файлов уже без всяких шаблонов, как если бы этот
	  список пользователь ввел вручную. 
      </para>	  
    </sect3>
    
    <sect3 id="shell-redirect">
      <title>Перенаправление ввода и вывода</title>
      
      <para>
	По умолчанию, ввод и вывод каждой команды, выполняемой в
	командной строке, связан с терминалом, за которым работает
	пользователь. Однако командная оболочка предусматривает
	средства перенаправления ввода и вывода команд. Один из самых
	важных случаев&nbsp;&mdash; перенаправление ввода/вывода в
	файл и из файла. Для этого в командной строке используются
	специальные
	символы <literal>&gt;</literal>), <literal>&gt;&gt;</literal>
	и <literal>&lt;</literal>. Символы
	перенаправления указываются в командной строке после всех
	параметров команды, за символом перенаправления должно
	следовать имя файла, в который или из которого следует
	передать данные.
      </para>

      <screen>user@desktop ~ $ date &gt; /tmp/date
user@desktop ~ $ cat &lt; /tmp/date
Втр Окт  4 23:15:37 MSD 2005
user@desktop ~ $</screen>

      <para>
	В данном примере вывод команды <command>date</command> перенаправляется в файл
	<filename>/tmp/date</filename> (при этом если такой файл
	существовал, то он будет уничтожен и создан заново с нуля), а затем команде cat
	перенаправляется на ввод содержимое этого файла. Обратите
	внимание, здесь команда <command>cat</command> выполняется <emphasis>без
	параметров</emphasis>, она получает содержимое файла
	<filename>/tmp/date</filename> непосредственно со стандартного
	ввода, как если бы пользователь ввел его прямо с
	терминала. Обращение к файлу и передачу данных выполняет в
	этом случае <emphasis>командная оболочка</emphasis>.
      </para>
      <para>
	Современные оболочки, в том числе и bash, предусматривают
	также специальные символы для особых случаев перенаправления,
	в частности, &gt;&gt; служит для недеструктивного
	перенаправления в файл (данные не заместят содержимое файла, а
	будут дописаны в конец) или &amp;&gt; для направления в один
	файл двух потоков: стандартного ввода и стандартного вывода ошибок.
      </para>
      
    </sect3>

    <sect3 id="shell-base-env">
      <title>Программное окружение</title>
      <presentation number="4-04" name="программное окружение"/>
      <question id="quest-4-5">Что такое программное окружение? Какие стандартные
      переменные окружения существуют в UNIX?</question>
      
      <para>
	В командной оболочке можно просматривать и изменять <emphasis>переменные
	окружения</emphasis>, которые соответствуют процессу оболочки (о
	переменных окружениях уже было сказано в разделе <xref
	linkend="intro-unixproc-interproc-env"/>). Программы могут исполняться по-разному,
	в зависимости от значений переменных окружения:
      </para>
      <para>
	<screen>user@desktop ~ $ date
Птн Ноя 5 16:20:16 MSK 2004
user@desktop ~ $ LC_TIME=C date
Fri Nov 5 16:20:23 MSK 2004</screen>
      </para>
      <para>
	В последнем примере пользователь присвоил некоторое значение переменной окружения
	в командной строке перед именем команды. Командный интерпретатор,
	увидев <literal>=</literal> внутри первого слова командной строки, приходит к выводу,
	что это&nbsp;&mdash; операция присваивания, а не имя команды, и запоминает, как
	надо изменить окружение команды, которая последует далее. Переменная окружения
	<envar>LC_TIME</envar> предписывает использовать определенный язык при выводе даты
	и времени, а значение <literal>C</literal> соответствует стандартному
	системному языку (чаще всего&nbsp;&mdash; английскому).
      </para>
      <para>
	Для получения значения переменной окружения необходимо воспользоваться
	символом <literal>$</literal>:
      </para>
      <para>
	<screen>user@desktop ~ $ echo $PWD
/home/user</screen>
	  </para>
	  </sect3>
<sect3 id="shell-base-env-std">
	<title>Стандартные переменные окружения</title>
	<para>
	  В большинстве UNIX-систем существует набор переменных окружения, сопровождающих
	  все процессы системы. При старте командной оболочки, инициализируется это
	  множество системных переменных. Их можно посмотреть с помощью
	  команды <command>env</command>. Некоторые из них представляют особый интерес для
	  пользователя системы:
	</para>
	<para>
	  <variablelist>
	    <varlistentry>
	      <term><envar>DISPLAY</envar></term>
	      <listitem>
		<para>
		  Переменная используется графической подсистемой X11 и указывает на адрес
		  X-сервера и номер используемого экрана (подробнее об этом будет сказано
		  в разделе <xref linkend="chapter-x-windows"/>).
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><envar>EDITOR</envar></term>
	      <listitem>
		<para>
		  Если какая-то утилита требует редактирования файла, то вместо
		  написания и использования встроенного редактора, этот файл можно
		  передать на редактирование программе, путь к которой хранится в
		  переменной <envar>EDITOR</envar>. 
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><envar>HOME</envar></term>
	      <listitem>
		<para>
		  Переменная содержит имя домашней директории текущего пользователя.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><envar>LANG</envar> и <envar>LC_...</envar></term>
	      <listitem>
		<para>
		  Переменные, задающие язык интерфейса и другие параметры локализации программы.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><envar>PATH</envar></term>
	      <listitem>
		<para>
		  Переменная окружения содержит список директорий, разделённый
		  символом <literal>:</literal>. Этот список просматривается при каждом
		  запуске команды&nbsp;&mdash; в нём производится поиск исполняемых файлов
		  с соответствующим команде именем. Примером значения переменной окружения
		  может быть <filename>/bin:/usr/bin:/usr/local/bin</filename>.
		</para>
		<para>
		  Как правило, значение этой переменной различается для простого
		  пользователя и администратора&nbsp;&mdash; для того, чтобы разделить их
		  рабочий инструментарий.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><envar>SHELL</envar></term>
	      <listitem>
		<para>
		  Имя текущей программы оболочки.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><envar>TERM</envar></term>
	      <listitem>
		<para>
		  Тип терминала, используемого в настоящий момент. Эта переменная
		  анализируется программами для того, чтобы варьировать свой интерфейс в
		  зависимости от возможностей терминала.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><envar>USER</envar></term>
	      <listitem>
		<para>
		  Имя текущего пользователя.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><envar>_</envar> (одиночный символ подчёркивания)</term>
	      <listitem>
		<para>
		  В точности последняя команда, выполненная в командной оболочке.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
      </sect3>
    <sect3 id="shell-base-cmd-chars">
      <title>Служебные символы</title>
      <presentation number="4-05" name="служебные символы"/>
      <para>
	Из предыдущих разделов видно, что некоторые символы
	используются в качестве команд самой командной оболочке,
	например, символы перенаправления ввода/вывода&nbsp;&mdash; 
	<definition id="def-reservesd-chars" orig="служебные символы">служебные
	  символы</definition>. Поскольку служебные символы адресованы
	самой командной оболочке, то при обработке командной строки
	они из нее <quote>изымаются</quote> и не передаются
	выполняющейся команде. Чтобы передать команде параметр,
	содержащий служебные символы, необходимо их тем или иным
	способом <emphasis>экранировать</emphasis>. С одним из
	способов экранирования&nbsp;&mdash; заключением параметра
	в одинарные или двойные кавычки&nbsp;&mdash; мы уже
	сталкивались раньше, когда говорили о параметрах, содержащих
	символы-разделители. Другой распространённый
	способ&nbsp;&mdash; постановка символа обратной косой черты
	(\) непосредственно перед служебным символом.
	</para>
	<para>
	  Рассмотрим основные группы служебных символов командной оболочки:
	  <variablelist>
	    <varlistentry>
	      <term>Символы-разделители</term>
	      <listitem>
		<para>
		  Используются для отделения частей команды или нескольких команд. К ним
		  относятся: пробел, табуляция. По умолчанию команды разделяются символом
		  перевода строки. 
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Символы пути</term>
	      <listitem>
		<para>
		  Используются для разделения элементов пути. Сюда можно отнести символ
		  корня <literal>/</literal>) и символ домашней директории
		  <literal>~</literal>)&nbsp;&mdash; в командной строке он автоматически
		  заменяется на полный путь к домашней директории. 
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Символы команд</term>
	      <listitem>
		<para>
		  Применяются в аргументах команд, для отделения нескольких команд, для
		  запуска процессов на заднем фоне и т.п. К таким символам можно отнести:
		  <literal>*</literal>, <literal>&amp;</literal>, <literal>&lt;</literal>,
		  <literal>&gt;</literal>, <literal>;</literal>, <literal>(</literal>,
		  <literal>)</literal>, <literal>|</literal>, <literal>&quot;</literal>.  
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Символы управления переменными</term>
	      <listitem>
		<para>
		  Используются для задания (<literal>=</literal>) и подстановки
		  (<literal>$</literal>) значений переменных среды. При этих символах в именах
		  файлов, необходимо предварять их знаком обратной косой
		  (<literal>\</literal>).
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>ESC-символы</term>
	      <listitem>
		<para>
		  Для использования перечисленных выше специальных символов в именах
		  файлов, необходимо перед ними использовать знак обратной косой:
		  <literal>\&amp;</literal>, <literal>\;</literal> и т.&nbsp;п. К этой же группе
		  относятся специальные ASCII-символы, зарезервированные для команд вывода
		  текста, например, символ возврата каретки или табуляции
		  (<literal>\n</literal> и <literal>\t</literal> соответственно).
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
    </sect3>

    <sect3 id="shell-base-cmd-exec">
      <title>Процесс выполнения команды</title>
      <presentation number="4-06" name="исполнение команды"/>
      <question id="quest-4-3">Что такое командная оболочка? Что происходит при запуске
	команды?</question>
	
      <para>
	  Командная оболочка&nbsp;&mdash; это обычный процесс в операционной системе
	  UNIX. Когда пользователь вводит команду (например, по
	  нажатию <keycap>Enter</keycap>), командная оболочка выполняет следующие
	  действия:
	  <orderedlist>
	    <listitem>анализ команды: выделение имени, параметров и аргументов;</listitem>
	  <listitem>если это <emphasis>сокращение</emphasis> (alias),
	    то оно раскрывается и анализ команды продолжается;</listitem>
	    <listitem>если это <emphasis>встроенная команда</emphasis>, для неё вызывается
	      функция-обработчик;</listitem>
	    <listitem>если это <emphasis>внешняя команда</emphasis>:
	      <orderedlist>
		<listitem>производится поиск программы с соответствующим именем;</listitem>
		<listitem>создаётся дочерний процесс оболочки (системный вызов
		  fork);</listitem>
		<listitem>в дочернем процессе запускается необходимая команда с
		  расшифрованными параметрами и аргументами (системный вызов
		exec);</listitem>
		<listitem>оболочка контролирует выполнение дочернего процесса, передаёт
		  ему сигналы и ввод пользователя, ожидает его завершения (системный вызов
		  wait);</listitem>
	      </orderedlist>
	    </listitem>
	    <listitem>результаты работы возвращаются пользователю, отображается
	    приглашение&nbsp;&mdash; он может вводить следующую команду.</listitem>
	  </orderedlist>
	</para>
	<para>
	  <figure id="img-running-child">
	    <title>Запуск команды оболочкой</title>
	    <graphic fileref="&BASEIMAGES;running_child.png"/>
	  </figure>
	</para>
      </sect3>
      <sect3 id="shell-base-cmd-retval">
	<title>Возвращаемое значение</title>
	<presentation number="4-07" name="возвращаемое значение"/>
	<para>
	  Каждый процесс при завершении возвращает своему родительскому процессу
	  специальный <definition id="def-return-value">код завершения</definition>
	  программы. Этот код может использоваться для получения результата выполнения
	  программы и для проверки корректности её выполнения (возврата кода ошибки).
	</para>
	<para>
	  Традиционно для UNIX, в случае успешного выполнения программа (а также
	  большинство системных функций) возвращает значение <literal>0</literal>. Другие
	  значения (все, отличные от <literal>0</literal>) означают тот или иной вид
	  ошибки. Так как программы часто выводят информацию об ошибках через специальный
	  <emphasis>поток вывода ошибок</emphasis> (stderr), возвращаемые значения чаще
	  всего могут принимать только два значения: <quote>ноль</quote> и <quote>не
	  ноль</quote>. 
	</para>
	<para>
	  Если рассмотреть простейший пример программы на языке C:
	</para>
	<para>
	  <example>
	    <title>Возвращаемое значение в программе на языке C</title>
	    <programlisting>
int main(int argc, char* argv[]) {
    ...
    if(error) {
        exit(1);
    }
    ...
    return 0;
}
	    </programlisting>
	  </example>
	</para>
	<para>
	  видно, что программы передают код завершения через возвращаемое значение
	  главной функции (<command>main</command>) или как параметр
	  функции <command>exit</command>.
	</para>
	<para>
	  В командной строке результат выполнения программы можно проанализировать с
	  помощью специальной переменной (<envar>?</envar>):
	</para>
	<para>
	  <screen>user@desktop ~ $ test -f /tmp/file.txt
user@desktop ~ $ echo $?
0</screen>
	</para>
    </sect3>
  </sect2>

  <sect2>
      <title>Эффективное использование командной строки</title>
    <presentation number="4-08" name="возможности командной оболочки"/>

    <para>
      При первом знакомстве командная строка может производить
      впечатление сложного и неудобного интерфейса. При более
      внимательном изучении и использовании выясняется, что в этом
      принципе построения интерфейса есть внутренние ресурсы,
      позволяющие строить эффективную и удобную рабочую среду. В этом
      разделе мы кратко обсудим два принципиальных способа достижения эффективности.
    </para>
    <para>
      Во-первых, поскольку командная строка&nbsp;&mdash; основной интерфейс
      взаимодействия с системой в UNIX-подобных операционных системах,
      пользователь значительную часть времени работает с командной
      строкой. Поэтому для пользователя очень важны средства экономии
      усилий, позволяющие свести к минимуму число интерфейсных жестов (в случае
      командной строки в качестве жестов выступают главным образом
      нажатия на клавиши). Современные командные оболочки UNIX-систем
      включают целый ряд средств для экономии нажатий, основные мы
      перечислим ниже.
    </para>
    <para>
      Второй путь к эффективному использованию командной строки
      заложен в самой природе <emphasis>командного языка</emphasis>
      как типа интерфейса. Так, язык любой командной оболочки UNIX 
      предоставляет гибкие средства объединения команд, 
      которые позволяют запрограммировать логику взаимодействия 
      нескольких программ в виде одной, пусть сложной, команды в командной
      строке. Дополнительной особенностью UNIX являются гибкие
      возможности объединения ввода/вывода разных команд. 
      Так, одной командой могут быть описаны весьма сложные
      многоступенчатые действия, вовлекающие произвольное количество
      объектов, например, сотни файлов. Таким образом, одна команда
      способна заменить сотни монотонных повторений однотипных
      действий.
    </para>

    <para>
      По существу, все средства интеграции команд&nbsp;&mdash;
      операторы циклов, условные операторы, присваивания
      переменных&nbsp;&mdash; в совокупности составляют
      полноценный язык программирования, интерпретатором
      которого и является командная оболочка. А все утилиты, имеющиеся
      в системе, можно считать его операторами. Так, последовательность
      команд shell, записанная в файл при соблюдении определённых
      правил представляет собой готовую к выполнению самостоятельную
      программу&nbsp;&mdash; <definition id="def-scenario" orig="сценарий">командный сценарий</definition>
      (в обиходе именуемый калькой с английского <emphasis>скрипт</emphasis>).
    </para>
    <para>
      Программирование на shell выходит за рамки данного курса, однако
      ниже будут рассмотрены основные средства связывания команд,
      необходимые любому пользователю.
    </para>

    <sect3 id="shell-base-shellfeat-edit">
      <title>Редактирование командной строки</title>
      <para>
	Вводимую команду можно редактировать с помощью
	клавиш <keycap>Backspace</keycap> и <keycap>Delete</keycap>, перемещаться
	стрелками по всей строке. При редактировании полезны функции 
	<keycombo><keycap>Ctrl</keycap><keycap>W</keycap></keycombo>&nbsp;&mdash;
	удаление слова перед курсором и <keycombo><keycap>Ctrl</keycap><keycap>U</keycap></keycombo>&nbsp;&mdash; удаление всей строки.
      </para>
    </sect3>

    <sect3 id="shell-base-shellfeat-history">
      <title>История команд</title>
      <para>
	Двумя другими клавишами со стрелками&nbsp;&mdash; вверх и вниз&nbsp;&mdash;
	задействуется весьма мощный
	механизм <application>bash</application>&nbsp;&mdash; работа с
	<definition id="def-history" orig="история команд">историей
	  команд</definition>. Все команды, набранные пользователем, командная оболочка
	запоминает и позволяет обращаться к ним впоследствии. По стрелке вверх, список
	поданных команд <quote>прокручивается</quote> от последней к первой, а по
	стрелке вниз&nbsp;&mdash; обратно. Соответствующая команда отображается в
	командной строке, как только что набранная, её можно отредактировать и подать
	оболочке (подгонять курсор к концу строки при этом необязательно).
      </para>
      <para>
	Чтобы история команд могла сохраняться <emphasis>между</emphasis> сеансами
	работы пользователя, <application>bash</application> записывает ее в файл
	<filename>.bash_history</filename>, находящийся в домашнем каталоге
	пользователя. Делается это в момент завершения оболочки: накопленная за время
	работы история дописывается в конец этого файла. При следующем запуске командной
	оболочки считывает <filename>.bash_history</filename> целиком. История хранится
	не вечно, количество запоминаемых команд в <filename>.bash_history</filename>
	ограничено (обычно сохраняется 500 команд, но это можно и перенастроить).
      </para>
    </sect3>

    <sect3 id="shell-base-shellfeat-autocompl">
      <title>Автодополнение</title>
      <para>
	Автодополнениe позволяeт быстро набирать команды и имена файлов. Во
	время набора имени команды или файла пользователь может нажать
	клавишу <keycap>Tab</keycap>, и командная оболочка
	попытается <quote>дополнить</quote> указанную команду или файл: предложит
	возможные варианты с данным началом или же дополнит имя, ведь часто набранной
	строки&nbsp;&mdash; пути к файлу и нескольких первых букв его имени&nbsp;&mdash;
	достаточно для однозначного указания на этот файл, потому что по введенному пути
	других файлов, чье имя начинается на эти буквы, просто нет.
      </para>
    </sect3> 


      <sect3 id="shell-base-cmd-join">
	<title>Средства объединения команд</title>
	<presentation number="4-09" name="средства объединения команд"/>
	<question id="quest-4-4">Какие существуют средства объединения команд? Чем они
	различаются?</question>
	<para>
	  Существует возможность объединять несколько команд в одной командной строке. Это
	  можно делать несколькими способами:
	  <variablelist>
	    <varlistentry>
	      <term>Последовательное выполнение</term>
	      <listitem><para>
		  Команды выполняются одна за другой, независимо от результата их
		  исполнения. В качестве разделителя выступает символ точки с запятой
		  (<literal>;</literal>).
		</para>
		<para>
		  В качестве примера можно рассмотреть составную команду
		  <command>mkdir /tmp/test; cd /tmp/test</command>,
		  которая сначала создает каталог
		  <filename>/tmp/test</filename>, а затем делает его
		  текущим. 
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Условное выполнение (И)</term>
	      <listitem><para> Проверяется код завершения первой программы, если он
		  равен <literal>0</literal>, производится выполнение второй программы, и
		  так далее. Таким образом, последняя команда выполнится только при
		  успешном завершении всех предыдущих. В качестве разделителя выступают
		  два амперсанда
	      (<quote>&amp;&amp;</quote>). 
		</para>
		
		<para>
		Например, команда
	      <command>mkdir /tmp/test &amp;&amp; cd /tmp/test</command>
	      создает каталог <filename>/tmp/test</filename>, но
	      переход в этот каталог будет выполнен только в том
	      случае, если при выполнении первой части не возникло ошибки
	      (например, каталог может уже существовать, и создать его невозможно).
	      </para>
	      </listitem>  
	    </varlistentry>
	    <varlistentry>
	      <term>Условное выполнение (ИЛИ)</term>
	      <listitem><para>
		  Проверяется код завершения первой программы, если он
		  <emphasis>не</emphasis> равен <literal>0</literal>, производится
		  выполнение второй программы, и так далее. Последняя команда будет
		  запущена, только если ни одна из предыдущих не закончилась успешно. В
		  качестве разделителя выступают две вертикальные черты
		  (<quote>||</quote>).
		</para>
		<para>
		  В качестве примера можно рассмотреть составную команду
		  <command>test -d /tmp/test || mkdir /tmp/test</command>, которая
		  проверяет существование директории <filename>/tmp/test</filename> и, если
		  её нет, создаёт её.
		</para>
	      </listitem>  
	    </varlistentry>
	    <varlistentry>
	      <term><definition id="def-conv" orig="конвейер">Конвейер</definition></term>
	    <listitem><para> При выполнении списка команд,
		объединённых в конвейер, стандартный вывод команды
		направляется на стандартный ввод следующей за ней
		команды в конвейере напрямую. Передаваемые данные
		рассматриваются как текстовые, передача производится
		построчно. Таким образом возникает поток данных,
		проходящих через несколько команд последовательно,
		как по конвейеру. Этот механизм является одной из самых фундаментальных
		особенностей UNIX и широко используется при работе в командной стоке.
	      </para>
		<para>
		  Все программы могут быть запущены одновременно, так чтобы обеспечить
		  интерактивность вывода при прохождении данных через цепочку
		  программ. Если одна из программ в цепочке конвейера завершится
		  (например, в случае ошибки), остальным будет
		  отправлен сигнал <command>SIGPIPE</command>. 
		</para>
		<para>
		  В качестве разделителя команд в конвейере используется символ вертикальный черты
		  (<literal>|</literal>).
		</para>
		<para>
		  Рассмотрим пример команды <command>cat file.txt | uniq | sort</command>,
		  которая читает содержимое файла <filename>file.txt</filename>, удаляет
		  из него повторяющиеся строки и сортирует оставшиеся строки по
		  алфавиту. Результат выводится на экран.
		</para>
	      </listitem> 
	    </varlistentry>
	  </variablelist>
	</para>
	<para>
	  Современные командные оболочки позволяют строить более гибкие условные выражения
	  (с использованием скобок и знака отрицания) из выполняющихся команд.
	</para>
      </sect3>
  </sect2>     
	      
    <sect2 id="shell-base-help">
      <title>Справочная подсистема</title>
      <presentation number="4-10" name="справочная подсистема"/>
      <question id="quest-4-6">Что входит в справочную систему UNIX?</question>
      <para>
	Работать с операционной системой, не заглядывая в документацию, довольно сложно. В
	UNIX это не вызывает проблем, потому что документированы практически все области
	операционной системы. Всем пользователям настоятельно рекомендуется, приступая к
	работе, а тем более&nbsp;&mdash; к изучению UNIX, пользоваться всеми доступными
	руководствами. Исторически первым и основным средством документации во всех
	версиях являются <emphasis>страницы руководства</emphasis> (manual pages), которые
	будут подробно рассмотрены далее.
      </para>
      <para>
	Документация в подавляющем большинстве случаев пишется на простом английском
	языке. Если английский&nbsp;&mdash; не родной язык для автора документации, она
	будет только проще. Традиция писать по-английски идет от немалого вклада США в
	развитие компьютерной науки вообще и UNIX в частности. Кроме того, английский
	становится языком международного общения во всех областях, не только в
	компьютерной. Необходимость писать на языке, который будет более или менее понятен
	большинству пользователей, объясняется постоянным развитием UNIX. Дело не в том,
	что страницу руководства нельзя перевести, а в том, что ее придется переводить
	всякий раз, когда изменится описываемый ею объект! Например, выход новой версии
	программного продукта сопровождается изменением его возможностей и особенностей
	работы, а следовательно, и новой версией документации.
      </para>
      <para>
	Документация в UNIX играет важнейшую роль. Решение любой задачи должно начинаться
	с изучения руководств. Не стоит жалеть на это времени. Даже если рядом есть
	опытный пользователь UNIX, который, возможно, знает ответ, не стоит беспокоить его
	сразу же. Возможно, даже зная, что нужно сделать, он не помнит как
	именно&nbsp;&mdash; и поэтому (а также потому, что он&nbsp;&mdash; опытный
	пользователь) начнет с изучения руководства. Это&nbsp;&mdash; закон, у которого
	даже собственное название: RTFM, что означает <quote>Read That
	Fine Manual</quote>.
      </para>
      <para>
	Современные свободные UNIX-системы обладают большим сообществом пользователей и
	разработчиков, объединённых через Интернет. В этих сообществах является нормальной
	практикой взаимопомощь и ответы на вопросы по системе. Однако здесь необходимо
	следовать описанному выше принципу RTFM.
      </para>
      <sect3 id="shell-base-help-man">
	<title>Страницы руководства</title>
	<presentation number="4-11" name="страницы руководств (man)"/>
	<para>
	  Больше всего полезной информации содержится в <definition id="def-manpage"
	  orig="страница руководства">страницах руководства</definition>, для краткости мы
	  будем называть их просто <quote>руководство</quote>. Каждая страница посвящена
	  какому-нибудь одному объекту системы. Для того чтобы посмотреть страницу
	  руководства, нужно дать команду системе <command>man объект</command>:
	</para>
	<para>
	  <screen>user@desktop ~ $ man cal
CAL(1)       BSD General Commands Manual   CAL(1)
NAME
        cal - displays a calendar
SYNOPSIS
        cal [-smjy13] [[month] year]
DESCRIPTION
        Cal displays a simple calendar. If arguments
        are not specified, the current month is 
        displayed. 
        The options are as follows:
...</screen>
	</para>
	<para>
	  Страница руководства занимает, как правило, больше одной страницы экрана. Для
	  того чтобы читать было удобнее, <command>man</command> запускает программу постраничного просмотра
	  текстов&nbsp;&mdash; <xref linkend="def-cmd-less"/>. Управлять
	  программой <command>less</command> просто: страницы перелистываются пробелом, а
	  когда читать надоест, надо нажать
	  <keycap>q</keycap> (Quit). Перелистывать страницы можно и клавишами
	  <keycap>Page Up</keycap>/<keycap>Page Down</keycap>, для сдвига на одну строку
	  вперед можно применять <keycap>Enter</keycap> или стрелку вниз, а на одну строку
	  назад&nbsp;&mdash; стрелку вверх. Переход на начало и конец текста выполняется
	  по командам <keycap>g</keycap> и <keycap>G</keycap> соответственно (Go). Полный
	  список того, что можно делать с текстом в <command>less</command>, выводится по
	  команде <keycap>h</keycap> (Help). Для поиска и подсветки интересующего понятия
	  можно воспользоваться командой <keycap>/</keycap>, после которой необходимо
	  ввести интересующий Вас термин&nbsp;&mdash; по нажатию
	  клавиши <keycap>Enter</keycap>, курсор перейдёт к первому упоминанию термина,
	  который будет выделен серым цветом. Последующие нажатия <keycap>/</keycap>
	  и <keycap>Enter</keycap> приведут к продолжению поиска слова по документу.
	</para>
	<para>
	  Страница руководства состоит из полей&nbsp;&mdash; стандартных разделов, с
	  разных сторон описывающих заинтересовавший объект&nbsp;&mdash; например, команду
	  <command>cal</command>. В поле NAME содержится краткое описание объекта (такое,
	  чтобы его назначение было понятно с первого взгляда). В поле SYNOPSIS дается
	  формализованное описание способов использования объекта (в данном
	  случае&nbsp;&mdash; того, как и с какими параметрами запускать
	  команду <command>cal</command>). Как правило, в квадратные скобки в этом поле
	  заключены необязательные параметры команды, которые можно ей передать, а можно и
	  опустить. Например, строка <command>[[month] year]</command> означает, что в этом
	  месте командной строки параметров у команды может не быть вообще, может быть
	  указан год или пара&nbsp;&mdash; месяц и год. Наконец, текст в поле
	  DESCRIPTION&nbsp;&mdash; это развернутое описание объекта, достаточное для того,
	  чтобы им воспользоваться.
	</para>
	<para>
	  Одно из самых важных полей руководства находится в конце текста. Если в процессе
	  чтения NAME или DESCRIPTION пользователь понимает, что не нашел в руководстве
	  того, что искал, он может захотеть посмотреть, а есть ли другие руководства или
	  иные источники информации по той же теме. Список таких источников содержится в
	  поле SEE ALSO:
	</para>
	<para>
	  <screen>user@desktop ~ $ man man
...
SEE ALSO
    apropos(1), whatis(1), less(1), groff(1), man.conf(5).</screen>
	</para>
	<para>
	  Справочные руководства делятся на разделы&nbsp;&mdash; в зависимости от типа
	  описываемых объектов. Если один и тот же термин описывается в нескольких
	  разделах, необходимо явно указать, какой из них использовать,
	  например, <command>man 3 printf</command> для 3-го раздела руководств.
	</para>
	<para>
	  Всего существует 8 разделов руководств:
	</para>
	<para>
	  <orderedlist>
	    <listitem>пользовательские утилиты и прочие инструменты</listitem>
	    <listitem>системные вызовы</listitem>
	    <listitem>библиотечные функции</listitem>
	    <listitem>внешние устройства (и их представление в системе)</listitem>
	    <listitem>форматы и таблицы (типы файлов, протоколы и прочее)</listitem>
	    <listitem>игры и всевозможные <quote>ненужные</quote> утилиты</listitem>
	    <listitem><quote>остальное</quote>, т.е. то, что не подходит под другие
	      разделы</listitem>
	    <listitem>команды и инструменты системного администратора</listitem>
	  </orderedlist>
	</para>
      </sect3>
      <sect3 id="shell-base-help-mansearch">
	<title>Поиск по руководствам</title>
	<para>
	  В примере выше в поле SEE ALSO обнаружились ссылки на руководства
	  по <command>less</command>, <command>groff</command> (программе форматирования
	  страницы руководства), структуре конфигурационного файла для man, а также по
	  двум сопутствующим командам с такими говорящими
	  названиями <quote>apropos</quote> и <quote>whatis</quote>. Как и
	  команда <command>apropos</command>, <command>whatis</command> ищет подстроку в
	  некоторой базе данных, состоящей из полей NAME всех страниц помощи в
	  системе. Различие между ними в том, что <command>whatis</command>&nbsp;&mdash;
	  только среди имен объектов (в левых частях полей NAME), а <command>apropos</command>&nbsp;&mdash;
	  по всей базе. В результате у <command>whatis</command> получается список кратких
	  описаний объектов с именами, включающими искомое слово, а
	  у <command>apropos</command>&nbsp;&mdash; список, в котором это слово
	  упоминается. Для того чтобы это узнать, все равно пришлось один раз прочесть
	  документацию.
	</para>
	<para>
	  Описания объектов, выводимые <command>whatis</command>
	  или <command>apropos</command>, отличаются числом в скобках&nbsp;&mdash; номером
	  раздела:
	</para>
	<para>
	  <screen>user@desktop ~ $ whatis passwd
passwd (1) - update a user's authentication tokens(s)
passwd (5) - password file
passwd (8) - manual page for passwd wrapper version 1.0.5</screen>
	</para>
      </sect3>
      <sect3 id="shell-base-help-info">
	<title>Программа info</title>
	<para>
	  Другой источник информации о UNIX (а точнее, в UNIX-подобных системах,
	  базирующихся на программном обеспечении от GNU) и составляющих ее
	  программах&nbsp;&mdash; справочная подсистема <command>info</command>. Страница
	  руководства, несмотря на обилие ссылок различного типа,
	  остается <quote>линейным</quote> текстом, структурированным только
	  логически. Документ info структурирован прежде всего
	  топологически&nbsp;&mdash; это настоящий гипертекст, в котором множество
	  небольших страниц объединены в дерево. В каждом разделе документа info всегда
	  есть оглавление, из которого можно перейти сразу к нужному подразделу, откуда
	  всегда можно вернуться обратно. Кроме того, info-документ можно читать и как
	  непрерывный текст, поэтому в каждом подразделе есть ссылки на предыдущий и
	  последующий подразделы.
	</para>
	<para>
	  Программа <command>info</command> использует весь экран: на большей его
	  части она показывает текст документа, а первая и две последних строки ориентации
	  в его структуре.
	</para>
	<para>
	  Одна или несколько страниц, которые можно перелистывать
	  клавишей <keycap>Пробел</keycap> или <keycap>Page Up</keycap>/<keycap>Page
	  Down</keycap>&nbsp;&mdash; это узел (node). Узел содержит обычный текст и меню
	  (menu)&nbsp;&mdash; список ссылок на другие узлы, лежащие в дереве на более
	  низком уровне. Ссылки внутри документа имеют вид <quote>* имя_узла::</quote> и
	  перемещать по ним курсор можно клавишей <keycap>Tab</keycap>, а переходить к
	  просмотру выбранного узла&nbsp;&mdash;
	  клавишей <keycap>Enter</keycap>. Вернуться к предыдущему просмотренному узлу
	  можно клавишей <keycap>l</keycap> (Last). И, главное, выйти из
	  программы info можно, нажав <keycap>q</keycap> (Quit). Более
	  подробную справку об управлении программой info можно в любой момент получить у
	  самой <command>info</command>, нажав <keycap>?</keycap>.
	</para>
      </sect3>
      <sect3 id="shell-base-help-docs">
	<title>Документация, поставляемая с программой</title>
	<para>
	  Некоторые объекты системы не имеют документации ни в формате man, ни в формате
	  info. В этом случае можно надеяться, что при них есть сопроводительная
	  документация, не имеющая, увы, ни стандартного формата, ни тем более ссылок на
	  руководства по другим объектам системы. Такая документация (равно как и примеры
	  использования объекта), обычно помещается в
	  каталог <filename>/usr/share/doc/имя_объекта</filename>. Как правило, <emphasis>имя
	  объекта</emphasis> здесь&nbsp;&mdash; это имя программы и её текущая версия.
	</para>
	<para>
	  Существует ещё одна довольно распространённая ситуация, в которой обширная
	  документация по продукту, расположенная в
	  директории <filename>/usr/share/doc/</filename> выходит далеко за рамки man или
	  info&nbsp;&mdash; если продукт достаточно сложен и имеет собственную
	  структурированную и очень объёмную документацию. Примерами могут служить
	  веб-сервер <application>Apache</application> или почтовый
	  сервер <application>Postfix</application>.
	</para>
	<para>
	  Широко распространённым видом тематической документации являются
	  HOWTO&nbsp;&mdash; статьи, часто объёмом не уступающие книгам, которые посвящены
	  решению какой-либо практической задачи, например <quote>Настройка
	  печати</quote> или <quote>Создание загрузочного диска</quote>. Подборки
	  HOWTO могут распространяться вместе с программами, но их также можно найти в
	  Internet. HOWTO могут служить хорошим вводным материалом в
	  целые большие разделы работы с операционной системой и её
	  компонентами. Однако в частностях, которые не относятся
	  к традиционным и устоявшимся основам UNIX, они быстро
	  устаревают и не могут отразить всей специфики разных
	  реализаций UNIX-систем&nbsp;&mdash; при чтении HOWTO всегда
	  следует делать на это поправку.
	</para>
      </sect3>
      <sect3 id="shell-base-help-modern">
	<title>Интегрированные системы документации</title>
	<para>
	  В современных свободных версиях UNIX существуют проекты,
	  целью которых является унификация и систематизация
	  документации на основе XML. Наиболее известный из них&nbsp;&mdash;
	  проект <application>Scrollkeeper</application>, который объединяет всю документацию (в первую очередь в
	  современных оконных средах <application>GNOME</application>
	  и <application>KDE</application>) и позволяет просматривать её с помощью
	  простого браузера, предоставляет средства поиска, построения
	  оглавления и указателей, и т.&nbsp;п.
	</para>
	<para>
	Однако подобные средства документации используются очень
	ограниченно, а роль основного источника документации в
	UNIX-системах по-прежнему сохраняют страницы
	руководства. Возможно, причина этого в
	<quote>распределённой</quote> природе руководств: нет общего
	места, где сложены все руководства системы. Напротив, каждое
	руководство посвящено определённому объекту системы, дает
	конкретные сведения, необходимые в конкретной ситуации и
	доступно в любой командной строке, то есть всегда находится
	<quote>под рукой</quote>.
      </para>
    </sect3>
  </sect2>      

  <sect2 id="shell-base-summary">
    <title>Резюме</title>
    <presentation number="4-12" name="резюме"/>
      <para>
	Командная строка UNIX является основным средством интерфейса
	взаимодействия с системой, как для администратора, так и для пользователя
	системы. Это происходит еще и потому, что в настоящее время широко распространены
	средства удалённой работы с системой через сетевые терминалы.
      </para>
    <para>
      Интерфейс командной строки реализуется посредством
      <emphasis>терминала</emphasis>&nbsp;&mdash; логического или физического устройства,
      способного принимать и передавать текстовые данные&nbsp;&mdash;
      и связанного с терминалом процесса&nbsp;&mdash;
      <emphasis>командной оболочки</emphasis>, которая организует
      интерактивную работу пользователя, интерпретирует  команды
      пользователя и передает их на выполнение системе.
    </para>
    <para>
      Команда строится по стандартной схеме: <emphasis>имя
      команды&nbsp;&mdash; модификаторы (ключи)&nbsp;&mdash; прочие
      параметры</emphasis>. В качестве имени команды может выступать
      название внешней программы, встроенной функции или сокращение (alias).
    </para>
    <para>
      При обработке командной строки служебные символы
      интерпретируются самой командной оболочкой и не передаются в
      качестве параметров командам. Чтобы включить служебные символы в
      состав параметра, их необходимо экранировать.
    </para>
    <para>
      Документация&nbsp;&mdash; необходимый инструмент при работе в
      UNIX. Основной вид документации&nbsp;&mdash; страницы руководств
      (man). Также следует обращаться к расширенной обучающей
      документации (info) и к документации, поставляемой вместе с
      программой (которую можно найти в каталоге <filename>/usr/share/doc</filename>).
    </para>
    <list-of-definitions/>
  
  </sect2>    
    <sect2 id="shell-base-additional">
      <title>Дополнительные материалы</title>
      <para>
	<orderedlist>
	  <listitem>
	    Д. Тейнсли <emphasis>Linux и UNIX: программирование в shell. Руководство
	    разработчика</emphasis>.&nbsp;&mdash; К.: Издательская группа BHV,
	    2001.&nbsp;&mdash; 464 с.: ил.
	  </listitem>
	  <listitem>
	    Курячий Г.В., Маслинский К.А. <emphasis>Операционная система
	    Linux</emphasis>.&nbsp;&mdash; М.: Интуит.Ру, 2005.&nbsp;&mdash; 392 с.: ил.
	  </listitem>
	  <listitem>
	    Курячий Г.В. <emphasis>Операционная система UNIX</emphasis>.&nbsp;&mdash;
	    М.: Интуит.Ру, 2004.&nbsp;&mdash; 292 с.: ил.
	  </listitem>
	  <listitem>
	    Соловьёв А. <emphasis>Программирование на shell</emphasis>.&nbsp;&mdash;
	    <ulink url="http://www.linuxcenter.ru/lib/books/shell/">http://www.linuxcenter.ru/lib/books/shell/</ulink>
	  </listitem>
	  <listitem>
	    Mendel Cooper <emphasis>Advanced Bash-Scripting Guide</emphasis>.&nbsp;&mdash;
	    <ulink url="http://tldp.org/LDP/abs/html/">http://tldp.org/LDP/abs/html/</ulink>
	  </listitem>
	</orderedlist>
      </para>
    </sect2>    
    <list-of-questions id="shell-base-questions"/>
    <small-presentation id="shell-base-presentaion"/>
  </sect1>

